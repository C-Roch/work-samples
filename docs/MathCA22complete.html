<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />


<meta name="author" content="Dr. Claudia Roch M.A." />

<meta name="date" content="2022-11-08" />

<title>Math of Correspondence Analysis</title>

<script src="MathCA22complete_files/header-attrs-2.17/header-attrs.js"></script>
<script src="MathCA22complete_files/jquery-3.6.0/jquery-3.6.0.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="MathCA22complete_files/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="MathCA22complete_files/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="MathCA22complete_files/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="MathCA22complete_files/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="MathCA22complete_files/navigation-1.1/tabsets.js"></script>
<script src="MathCA22complete_files/navigation-1.1/codefolding.js"></script>
<script src="MathCA22complete_files/navigation-1.1/sourceembed.js"></script>
<link href="MathCA22complete_files/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="MathCA22complete_files/highlightjs-9.12.0/highlight.js"></script>
<link href="MathCA22complete_files/pagedtable-1.1/css/pagedtable.css" rel="stylesheet" />
<script src="MathCA22complete_files/pagedtable-1.1/js/pagedtable.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>




<style type="text/css">
#rmd-source-code {
  display: none;
}
</style>





<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
details > summary > p:only-child {
  display: inline;
}
pre code {
  padding: 0;
}
</style>



<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before, .tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "\e259";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "\e258";
  font-family: 'Glyphicons Halflings';
  border: none;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->
<style type="text/css">
.code-folding-btn { margin-bottom: 4px; }
</style>




</head>

<body>


<div class="container-fluid main-container">




<div id="header">

<div class="btn-group pull-right float-right">
<button type="button" class="btn btn-default btn-xs btn-secondary btn-sm dropdown-toggle" data-toggle="dropdown" data-bs-toggle="dropdown" aria-haspopup="true" aria-expanded="false"><span>Code</span> <span class="caret"></span></button>
<ul class="dropdown-menu dropdown-menu-right" style="min-width: 50px;">
<li><a id="rmd-download-source" href="#">Download Rmd</a></li>
</ul>
</div>



<h1 class="title toc-ignore">Math of Correspondence Analysis</h1>
<h4 class="author">Dr. Claudia Roch M.A.</h4>
<h4 class="date">2022-11-08</h4>

</div>

<div id="TOC">
<ul>
<li><a
href="#math-of-correspondence-analysis---case-study-pragmatic-extenders-used-by-english-teenagers"
id="toc-math-of-correspondence-analysis---case-study-pragmatic-extenders-used-by-english-teenagers">Math
of Correspondence Analysis - Case Study “Pragmatic Extenders used by
English Teenagers”</a></li>
<li><a href="#sources-preparation" id="toc-sources-preparation">Sources
&amp; Preparation</a></li>
<li><a
href="#case-study---pragmatic-extenders-used-by-english-teenagers"
id="toc-case-study---pragmatic-extenders-used-by-english-teenagers">0.
Case Study - Pragmatic Extenders used by English Teenagers</a>
<ul>
<li><a href="#research-questions" id="toc-research-questions">0.1
Research questions</a></li>
<li><a href="#dataset" id="toc-dataset">0.2 Dataset</a></li>
<li><a href="#performing-statistical-tests"
id="toc-performing-statistical-tests">0.3 Performing statistical
tests</a>
<ul>
<li><a href="#chi2-test" id="toc-chi2-test">0.3.1 Chi^2-test</a></li>
<li><a href="#pearsons-residuals" id="toc-pearsons-residuals">0.3.2
Pearson’s residuals</a></li>
<li><a href="#cramers-v-intensity-of-the-relationship"
id="toc-cramers-v-intensity-of-the-relationship">0.3.3 Cramer’s V:
intensity of the relationship</a></li>
</ul></li>
<li><a href="#a-first-look-at-ca-analysis-and-interpretation"
id="toc-a-first-look-at-ca-analysis-and-interpretation">0.4 A first look
at ca analysis and interpretation</a></li>
<li><a href="#validation-of-calculations-with-the-ca-package"
id="toc-validation-of-calculations-with-the-ca-package">0.5 Validation
of calculations with the <code>ca</code> package</a></li>
</ul></li>
<li><a href="#observed-proportions-profiles-and-masses"
id="toc-observed-proportions-profiles-and-masses">1.0 Observed
proportions, profiles and masses</a>
<ul>
<li><a href="#row-and-column-totals" id="toc-row-and-column-totals">1.1
Row and Column Totals</a></li>
<li><a
href="#calculating-observed-proportions-p-in-a-correspondence-matrix"
id="toc-calculating-observed-proportions-p-in-a-correspondence-matrix">1.2
Calculating observed proportions P in a correspondence matrix</a></li>
<li><a href="#profiles-and-masses" id="toc-profiles-and-masses">1.3
Profiles and Masses</a>
<ul>
<li><a href="#row-and-column-profiles"
id="toc-row-and-column-profiles">1.3.1 Row and column profiles</a>
<ul>
<li><a href="#row-profiles" id="toc-row-profiles">Row profiles</a></li>
<li><a href="#column-profiles" id="toc-column-profiles">Column
profiles</a></li>
</ul></li>
<li><a href="#masses-of-rows-and-columns"
id="toc-masses-of-rows-and-columns">1.3.2 Masses of rows and
columns</a></li>
</ul></li>
</ul></li>
<li><a href="#expected-proportions-and-frequencies"
id="toc-expected-proportions-and-frequencies">2. Expected Proportions
and Frequencies</a>
<ul>
<li><a href="#expected-proportions-expected-proportions-e"
id="toc-expected-proportions-expected-proportions-e">2.1 Expected
proportions (expected proportions) E</a></li>
<li><a href="#expected-frequencies" id="toc-expected-frequencies">2.2
Expected Frequencies</a></li>
</ul></li>
<li><a href="#chi-squared-statistics-and-distances"
id="toc-chi-squared-statistics-and-distances">3. Chi-squared statistics
and distances</a>
<ul>
<li><a href="#chi-square-statistic" id="toc-chi-square-statistic">3.1
Chi-square statistic</a>
<ul>
<li><a href="#total-inertia" id="toc-total-inertia">3.1.1 <em>Total
Inertia</em></a></li>
</ul></li>
<li><a href="#chi-squared-distance" id="toc-chi-squared-distance">3.2
Chi-squared distance</a></li>
</ul></li>
<li><a href="#residuals-standardized-residuals"
id="toc-residuals-standardized-residuals">4. Residuals, standardized
Residuals</a>
<ul>
<li><a href="#residuals" id="toc-residuals">4.1 Residuals</a></li>
<li><a href="#calculation-of-the-standardized-residual-z"
id="toc-calculation-of-the-standardized-residual-z">4.2 Calculation of
the standardized residual Z</a></li>
</ul></li>
<li><a href="#singular-value-decomposition"
id="toc-singular-value-decomposition">5. Singular Value
Decomposition</a>
<ul>
<li><a href="#singular-value-decomposition-svd"
id="toc-singular-value-decomposition-svd">5.1 Singular Value
Decomposition (SVD)</a></li>
<li><a href="#eigenvalues" id="toc-eigenvalues">5.2 Eigenvalues</a>
<ul>
<li><a href="#scree-plot" id="toc-scree-plot">5.2.1 Scree-Plot</a></li>
</ul></li>
<li><a href="#coordinates" id="toc-coordinates">5.3 Coordinates</a>
<ul>
<li><a href="#principal-coordinates"
id="toc-principal-coordinates">5.3.1 Principal Coordinates</a></li>
<li><a href="#standard-coordinates" id="toc-standard-coordinates">5.3.2
Standard coordinates</a></li>
<li><a href="#reciprocal-calculation-of-the-coordinates"
id="toc-reciprocal-calculation-of-the-coordinates">5.3.3 Reciprocal
calculation of the coordinates</a></li>
</ul></li>
</ul></li>
<li><a href="#results-numerical-values-of-the-analysis"
id="toc-results-numerical-values-of-the-analysis">6. Results: Numerical
values of the analysis</a>
<ul>
<li><a href="#further-inertia-weights"
id="toc-further-inertia-weights">6.1 Further inertia weights</a>
<ul>
<li><a
href="#contribution-of-the-rows-related-to-the-axes-ctr-value-of-the-summary"
id="toc-contribution-of-the-rows-related-to-the-axes-ctr-value-of-the-summary">6.1.1
Contribution of the rows related to the axes (<code>ctr</code>-value of
the summary)</a></li>
<li><a href="#inertia-of-the-rows-and-columns-inr--value-of-the-summary"
id="toc-inertia-of-the-rows-and-columns-inr--value-of-the-summary">6.1.2
Inertia of the rows and columns: <code>inr</code>- value of the
summary</a></li>
</ul></li>
<li><a
href="#values-of-correlations-with-the-axes-cor-and-quality-qlt-value-of-the-summary"
id="toc-values-of-correlations-with-the-axes-cor-and-quality-qlt-value-of-the-summary">6.2
Values of correlations with the axes (<code>cor</code>) and quality
(<code>qlt</code> value of the summary)</a></li>
</ul></li>
<li><a href="#validation-by-ca-package"
id="toc-validation-by-ca-package">7.0 Validation by <code>ca</code>
package</a>
<ul>
<li><a href="#validation-of-row-and-column-masses"
id="toc-validation-of-row-and-column-masses">7.1 Validation of row and
column masses</a></li>
<li><a href="#validation-of-chi-squared-distances"
id="toc-validation-of-chi-squared-distances">7.2 Validation of
chi-squared distances</a></li>
<li><a href="#validation-of-standard-coordinates-of-row-and-columns"
id="toc-validation-of-standard-coordinates-of-row-and-columns">7.3
Validation of standard coordinates of row and columns</a></li>
<li><a href="#validation-of-principal-coordinates"
id="toc-validation-of-principal-coordinates">7.4 Validation of principal
coordinates</a></li>
<li><a href="#validation-of-inertia-values-inertia-weights"
id="toc-validation-of-inertia-values-inertia-weights">7.5 Validation of
inertia-values (inertia weights)</a></li>
<li><a href="#validation-of-cor-and-qlt-values"
id="toc-validation-of-cor-and-qlt-values">7.6 Validation of
<code>cor</code> and <code>qlt</code> values</a></li>
</ul></li>
<li><a href="#different-visualisations"
id="toc-different-visualisations">8. Different Visualisations</a>
<ul>
<li><a href="#method-symmetric-map" id="toc-method-symmetric-map">8.1
Method: Symmetric map:</a></li>
<li><a href="#method-rowprincipal" id="toc-method-rowprincipal">8.2
Method: “rowprincipal”</a></li>
<li><a href="#method-colprincipal" id="toc-method-colprincipal">8.3
Method: “colprincipal”</a></li>
</ul></li>
<li><a href="#references" id="toc-references">References</a></li>
</ul>
</div>

<div
id="math-of-correspondence-analysis---case-study-pragmatic-extenders-used-by-english-teenagers"
class="section level1">
<h1>Math of Correspondence Analysis - Case Study “Pragmatic Extenders
used by English Teenagers”</h1>
</div>
<div id="sources-preparation" class="section level1">
<h1>Sources &amp; Preparation</h1>
<p>This notebook has been created for the <a
href="https://vvz.ruhr-uni-bochum.de/campus/all/event.asp?objgguid=NEW&amp;from=vvz&amp;gguid=0xE2AC2ABDE5C3474A92007FEE6D3FECBA&amp;mode=own&amp;tguid=0xBEC4EBD3E08E451BB6DEBD69F230152F&amp;lang=en">Exploratory
Data Analysis</a> Advanced Course at Linguistic Data Science Lab, Ruhr
University Bochum.</p>
<p>The primary aim of this notebook is to follow along the mathematical
foundations of correspondence analysis. We “manually” calculate all
coordinates and summary statistics and compare the values to the output
of pre-compiled <code>ca</code>-packages.</p>
<p>The secondary aim is to explore a case study that deals with a
linguistic phenomenon - the local dialect in different social classes of
English teenagers from three local cities.</p>
<p><strong>Sources:</strong></p>
<p>The notebook is based on the following sources:</p>
<ul>
<li><p>Desagulier (2017), chapter 10, see also <a
href="http://extras.springer.com/2017/978-3-319-64570-4">additional
materials</a>.</p></li>
<li><p>The part on the mathematical foundation of CA relies on a <a
href="https://www.displayr.com/math-correspondence-analysis/">script by
Tim Bock</a>.</p></li>
</ul>
<p><strong>Required R packages:</strong> <code>ca</code>,
<code>data.table</code></p>
<pre class="r"><code>library(&quot;ca&quot;); library(&quot;data.table&quot;)</code></pre>
<pre><code>## Warning: Paket &#39;ca&#39; wurde unter R Version 4.2.2 erstellt</code></pre>
</div>
<div id="case-study---pragmatic-extenders-used-by-english-teenagers"
class="section level1">
<h1>0. Case Study - Pragmatic Extenders used by English Teenagers</h1>
<p>We use the <code>extenders</code> dataset following a case study as
presented in ch. 10 of Desagulier (2017). The original dataset was
recorded by Cheshire (2007) and contains frequencies for pragmatic
extenders (<em>and that</em>, <em>and all that</em>, <em>and stuff</em>,
<em>and things</em>, <em>and everything</em>, <em>or
something</em>).</p>
<blockquote>
<p>General extenders are clause-final pragmatic particles appended to a
word, a phrase, or a clause (Cheshire 2007, p. 156).</p>
</blockquote>
<blockquote>
<p>Their basic pattern is a conjunction (<em>and</em> or <em>but</em>)
followed by a noun phrase. (Desagulier 2017:257)</p>
</blockquote>
<p>The following examples (after Desagulier 2017:257) illustrate their
usage:</p>
<ul>
<li><em>Steve works in the engineering office and has taken over some of
the er you know purchasing function as well, like enquiries <strong>and
stuff</strong>.</em> (BNC–JP2)</li>
<li><em>And I don’t think we do it so much with the erm (pause) careers
service training, but with the careers teachers often we’ve got them
doing action plans <strong>and things</strong>.</em> (BNC–G4X)</li>
<li><em>I knew exactly where to stop it so that I could get off and go
down the ladder, sneak a cup of tea <strong>or something</strong>.</em>
(BNC–FXV)</li>
</ul>
<p>Following Desagulier (2017), we aim to explore the use of extenders
in the language of English teenagers from different social classes
(working class (WC) or middle class(MC)) from three English towns
(Reading, Milton-Keynes, Hull) applying correspondence analysis. The
towns are located in three distinct regional locations in England.
Cheshire (2007:164) argues that</p>
<blockquote>
<p>“there [is] a robust socialclass distinction in the use of certain
forms (. . . )”</p>
</blockquote>
<p>The variables for correspondence analysis are hence <strong>pragmatic
extender</strong> vs. the conflated variable <strong>Region_social
class</strong> of the teenagers.</p>
<p>Before we take a look at the data and explore it by applying
correspondence analysis, let us formulate a few research questions:</p>
<div id="research-questions" class="section level2">
<h2>0.1 Research questions</h2>
<ul>
<li><p>Are there geographic/social differences across the data set? And,
if so, what are these differences?</p></li>
<li><p>Which linguistic forms have the same regional and social
profiles?</p></li>
<li><p>What are the linguistic profiles of each region/social class with
respect to general extenders?</p></li>
</ul>
</div>
<div id="dataset" class="section level2">
<h2>0.2 Dataset</h2>
<pre class="r"><code># read rds file which stores the dataset as a single R object
extendersdata &lt;- readRDS(&quot;df_extenders.rds&quot;)
extendersdata</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["int"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["int"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["int"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["int"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["int"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["int"],"align":["right"]}],"data":[{"1":"4","2":"49","3":"9","4":"44","5":"10","6":"66","_rn_":"and that"},{"1":"4","2":"14","3":"2","4":"4","5":"1","6":"4","_rn_":"and all that"},{"1":"36","2":"6","3":"45","4":"5","5":"62","6":"18","_rn_":"and stuff"},{"1":"32","2":"0","3":"35","4":"0","5":"12","6":"5","_rn_":"and things"},{"1":"21","2":"16","3":"22","4":"18","5":"30","6":"31","_rn_":"and everything"},{"1":"72","2":"20","3":"30","4":"17","5":"23","6":"3","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>class(extendersdata)</code></pre>
<pre><code>## [1] &quot;data.frame&quot;</code></pre>
<p>The dataset’s format is a <strong>contingency table</strong>.</p>
<blockquote>
<p>A contingency table or crosstab indicates, for two or more
categorical variables, how frequently the combinations of characteristic
values occur.</p>
</blockquote>
<p>The frequencies in the rows are referred to as n<sub>ij</sub> where i
numbers the rows 1 to I (I=6) and j numbers the columns 1 to J (J=6). In
the data matrix IxJ e.g. we grasp that n<sub>42</sub> = 0.</p>
<pre class="r"><code>N = extendersdata
I &lt;- nrow(N)
J &lt;- ncol(N)
I</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>J</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>N[4,2]</code></pre>
<pre><code>## [1] 0</code></pre>
<p>The values of a variable (e.g. ‘<em>and that</em>’) are referred to
as points (in case of ‘<em>and that</em>’ it is actually a row point.)
Row points and column points can be depicted in a joint space in a
map.</p>
</div>
<div id="performing-statistical-tests" class="section level2">
<h2>0.3 Performing statistical tests</h2>
<p>The background of performing statistical tests is that we want to
check whether the rows and columns are not independent (this means
basically whether the research question is reasonable at all), although
theoretically in exploratory analyses, we would not make assumptions
regarding groupings to be found.</p>
<div id="chi2-test" class="section level3">
<h3>0.3.1 Chi^2-test</h3>
<p>The χ 2 test checks the significance of the overall deviation of the
data in the contingency table from the independence model. It computes
the contribution of each cell to χ 2 and sums up all contributions.</p>
<pre class="r"><code>chisq &lt;- chisq.test(extendersdata)</code></pre>
<pre><code>## Warning in chisq.test(extendersdata): Chi-Quadrat-Approximation kann inkorrekt
## sein</code></pre>
<pre class="r"><code>chisq</code></pre>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  extendersdata
## X-squared = 384.12, df = 25, p-value &lt; 2.2e-16</code></pre>
<p>[Eventually, consider a tool for converting scientific notation
e.g. <a
href="https://calculator.name/scientific-notation/scientific-notation-to-decimal.php"
class="uri">https://calculator.name/scientific-notation/scientific-notation-to-decimal.php</a>]</p>
<p>Here, χ 2 has a high value and it is associated with very small
p-value (0.00000000000000022). This implies that the row and column
variables are not independent and that there is a relationship. However,
the magnitude of the χ 2 value should not be interpreted as quantifying
the effect of the correlation, because it depends on the sample
size.</p>
<p>How do we know if the determined Chi-square value is a large
value?</p>
<p>We can use statistics tables with the Chi-squared distribution to
compare our values, like e.g. <a
href="https://en.wikibooks.org/wiki/Engineering_Tables/Chi-Squared_Distibution"
class="uri">https://en.wikibooks.org/wiki/Engineering_Tables/Chi-Squared_Distibution</a>.
We have to check the cell for the corresponding degrees of freedom (see
df=25 value in output) and the assumed significance level (e.g. 0.05.).
If the calculated chi-square value is smaller than the critical value,
the null hypothesis can be retained.</p>
<p>For an IxJ table (6x6=36), the number of degrees of freedom is given
by (I-1)x(J-1) or (5x5=25)). Degrees of freedom refers to the number of
values that can be varied without changing the relevant statistical
parameter. For example, if you take the arithmetic mean of three values,
then you can freely vary two and get the same result, the last value
cannot be freely varied, because it is already determined.</p>
<p><span class="math display">\[1+2+3/3 = 2\]</span> <span
class="math display">\[2+4+0/3 = 2\]</span> but not <span
class="math display">\[2+4+1\]</span></p>
<p>As the most important significance levels we distinguish: 0,05 (&lt;
= 5% significant), (95%) 0,01 (&lt; = 1% very significant), (99%)
0,001(&lt; = 0,1% highly significant) (99,9%).</p>
<p>The test statistic is usually associated with a P-value which
indicates the small probability (0.001 corresponds to 1 in 1000) of yet
reconciling the observed frequencies with the independence hypothesis.
The P-value indicates how incompatible data are with a particular
statistical model: the smaller the value, the greater the
incompatibility with the null hypothesis. P-values do not measure the
probability that a hypothesis under investigation is true (see
Wasserstein &amp; Lazar 2016).</p>
<p>In general the test imposes conditions that all observations are
independent and that 80+% of the expected frequencies are larger than
5.</p>
<pre class="r"><code>chisq$exp</code></pre>
<pre><code>##                Reading_MC Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## and that        39.945455  24.818182        33.800000        20.800000
## and all that     6.364935   3.954545         5.385714         3.314286
## and stuff       37.750649  23.454545        31.942857        19.657143
## and things      18.436364  11.454545        15.600000         9.600000
## and everything  30.288312  18.818182        25.628571        15.771429
## or something    36.214286  22.500000        30.642857        18.857143
##                  Hull_MC   Hull_WC
## and that       32.618182 30.018182
## and all that    5.197403  4.783117
## and stuff      30.825974 28.368831
## and things     15.054545 13.854545
## and everything 24.732468 22.761039
## or something   29.571429 27.214286</code></pre>
<p>In our case, the dataset does not meet the second assumption (only
67% of the sample size is greater 5) but Greenacre (2007) argues that it
can be applied . Given very small p-value, the significance of the
deviation of the table from independence is not deniable.</p>
<p>Later on, in section 3.1, we will see how to calculate the chi-square
value manually, with some more in depth discussion.</p>
</div>
<div id="pearsons-residuals" class="section level3">
<h3>0.3.2 Pearson’s residuals</h3>
<p>Pearson’s r is a correlation measure for the association between two
random variables (x and y).</p>
<p>If the Pearson residual in a cell is positive/negative, then the
observed frequency in that cell is greater/less than the expected
frequency in that cell. Second, the more the Pearson residual deviates
from 0, the stronger that effect, or, in other words, the closer the
coefficient is to 0, the weaker the correlation.</p>
<pre class="r"><code>chisq$res</code></pre>
<pre><code>##                Reading_MC Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## and that       -5.6873545  4.8540469       -4.2657297        5.0869365
## and all that   -0.9373941  5.0515110       -1.4589105        0.3766589
## and stuff      -0.2849292 -3.6040851        2.3102622       -3.3058955
## and things      3.1589191 -3.3844564        4.9117859       -3.0983867
## and everything -1.6877155 -0.6496511       -0.7167595        0.5611656
## or something    5.9466137 -0.5270463       -0.1161314       -0.4276686
##                   Hull_MC    Hull_WC
## and that       -3.9602975  6.5673614
## and all that   -1.8411427 -0.3580726
## and stuff       5.6148026 -1.9467451
## and things     -0.7872502 -2.3788668
## and everything  1.0591891  1.7269367
## or something   -1.2084360 -4.6416586</code></pre>
<p>Upon inspection of the values we observe a strong effect for:</p>
<ul>
<li>‘<em>and that</em>’ - ‘<em>Reading_MC</em>’ (-5.69), -
‘<em>Milton_Keynes_MC</em>’ (-4.27),- ‘<em>Milton_Keynes_WC</em>’
(5.09), - ‘<em>Hull_WC</em>’ (6.57)</li>
<li>‘<em>or something</em>’ - ‘<em>Reading_MC</em>’ (5.95), -
‘<em>Hull_WC</em>’ (-4.64)</li>
<li>‘<em>and all that</em>’ - ‘<em>Reading_WC</em>’ (5.05)</li>
<li>‘<em>and things</em>’ - ‘<em>Milton_Keynes_MC</em>’ (4.91)</li>
<li>‘<em>and stuff</em>’ - ‘<em>Hull_MC</em>’ (5.61) …</li>
</ul>
</div>
<div id="cramers-v-intensity-of-the-relationship"
class="section level3">
<h3>0.3.3 Cramer’s V: intensity of the relationship</h3>
<p>The intensity of the relationship is measured with Cramér’s V, and it
is non negligible for the dataset. The perfect score of 1 is unrealistic
here, as the association between the use of extenders and the
socio-geographic background is not exclusive (cf. Desagulier
2017:269).</p>
<pre class="r"><code>Vdif &lt;- sqrt(chisq$stat/(sum(extendersdata) * (min(dim(extendersdata))-1)))
round(Vdif, 3)</code></pre>
<pre><code>## X-squared 
##     0.316</code></pre>
<p>See also section 3.1 for the formula how to calculate it.</p>
</div>
</div>
<div id="a-first-look-at-ca-analysis-and-interpretation"
class="section level2">
<h2>0.4 A first look at ca analysis and interpretation</h2>
<p>Before we proceed with complex mathematical operations, let us have a
first look at what a CA analysis of the dataset looks and what initial
observations can be made.</p>
<p>Without the help of a CA graph, Cheshire (2007, p. 164) interprets
the table of frequencies as follows:</p>
<blockquote>
<p>Of the adjunctives, <em>and that</em> was preferred by the
working-class speakers in all three towns, as was the less frequent
<em>and all that</em>. The middle-class speakers, on the other hand,
preferred <em>and stuff</em> and <em>and things</em> again in all three
towns, though in Hull the middle-class adolescents used <em>and
stuff</em> far more often than <em>and things</em> (the relatively high
frequency of <em>and stuff</em> for the working-class group in Hull was
due to just three speakers, one of whom was responsible for 10 of the 18
tokens).</p>
</blockquote>
<p>Keeping in mind those observations, we will now plot the
low-dimensional map resulting from the CA analysis and inspect it.</p>
<pre class="r"><code>library(ca)
# performing ca with ca package
ca_ext &lt;- ca(extendersdata, graph=F)
par(mfrow=c(1,2)) # set the plotting area into a 1*2 array
# plotting first two dimensions
plot(ca_ext, dim=c(1:2))
# and second and third dimension
plot(ca_ext, dim=c(3:2))</code></pre>
<p><img src="MathCA22complete_files/figure-html/unnamed-chunk-9-1.png" width="672" /></p>
<p>When we interpret the map of the first and second dimension, we
find</p>
<ul>
<li>a clear divide between the use of extenders by middle-class and
working-class informants on the first axis
<ul>
<li>extenders favored by middle-class teenagers are <em>or
something</em>, <em>and things</em>, and <em>and stuff</em></li>
<li>extenders favored by working-class teenagers are <em>and all
that</em>, and <em>and that</em></li>
<li><em>and everything</em> in the middle is well projected along the
vertical axis, and seems to be indifferent to socio-geographic
groups</li>
</ul></li>
<li>that the vertical axis shows a difference between Hull and Reading
representing the geographical dissimilarity with Milton Keynes somewhere
in between; Note: Hull is in Yorkshire (northern England), whereas
Reading and Milton Keynes are much further south.</li>
</ul>
<p>When inspecting the second and third dimensional view zooming in a
little bit, we observe that</p>
<ul>
<li><em>and all that</em> (Freq. R:18, M:6, H:5) and <em>or
something</em> (Freq. R:92, M:47, H:26) group with Reading</li>
<li><em>and stuff</em> (Freq. R:42, M:50, H:80) and <em>and
everything</em> (Freq: R: 37, M: 40, H:61) group with Hull</li>
<li><em>and things</em> (Freq. R:32, M:35, H:17) and <em>and that</em>
(Freq. R: 53, M:53, H:76) which are very dissimilar in the first
dimension (because of being differently associated with middle and
working class) are not separated by the third dimension. They appear
close to Milton Keynes but are relatively frequently used in all
towns.</li>
</ul>
<p>In sum, we find that the dimension-reduction technique to represent
the (dis-)similarity between variables in a map, yields insights which
are in line with the interpretation of raw frequencies. For the moment,
we have skipped a look at the numerical results of correspondence
analysis which are equally important in interpretation, and we will turn
to those when considering the mathematical foundation.</p>
</div>
<div id="validation-of-calculations-with-the-ca-package"
class="section level2">
<h2>0.5 Validation of calculations with the <code>ca</code> package</h2>
<p>There are different R packages for performing correspondence
analysis: throughout this notebook we use Greenacre &amp; Nenadic’s
(2020) <code>ca</code> package and apply the <code>ca()</code> command
for simple correspondence analysis. In the output below, you will see
the existing variables of a ca-analysis object. We will load the single
predefined variables during our calculations to check whether our
manually obtained results are correct.</p>
<pre class="r"><code>library(ca)
ca_validation &lt;- ca(N)
str(ca_validation)</code></pre>
<pre><code>## List of 16
##  $ sv        : num [1:5] 0.60601 0.30081 0.16076 0.12343 0.00644
##  $ nd        : logi NA
##  $ rownames  : chr [1:6] &quot;and that&quot; &quot;and all that&quot; &quot;and stuff&quot; &quot;and things&quot; ...
##  $ rowmass   : num [1:6] 0.2364 0.0377 0.2234 0.1091 0.1792 ...
##  $ rowdist   : num [1:6] 0.934 1.053 0.613 0.855 0.244 ...
##  $ rowinertia: num [1:6] 0.2062 0.0418 0.084 0.0798 0.0107 ...
##  $ rowcoord  : num [1:6, 1:5] -1.534 -1.141 0.771 1.246 -0.209 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:6] &quot;and that&quot; &quot;and all that&quot; &quot;and stuff&quot; &quot;and things&quot; ...
##   .. ..$ : chr [1:5] &quot;Dim1&quot; &quot;Dim2&quot; &quot;Dim3&quot; &quot;Dim4&quot; ...
##  $ rowsup    : logi(0) 
##  $ colnames  : chr [1:6] &quot;Reading_MC&quot; &quot;Reading_WC&quot; &quot;Milton_Keynes_MC&quot; &quot;Milton_Keynes_WC&quot; ...
##  $ colmass   : num [1:6] 0.219 0.136 0.186 0.114 0.179 ...
##  $ coldist   : num [1:6] 0.694 0.841 0.593 0.731 0.624 ...
##  $ colinertia: num [1:6] 0.1058 0.0964 0.0653 0.0611 0.0699 ...
##  $ colcoord  : num [1:6, 1:5] 0.955 -1.214 0.883 -1.149 0.651 ...
##   ..- attr(*, &quot;dimnames&quot;)=List of 2
##   .. ..$ : chr [1:6] &quot;Reading_MC&quot; &quot;Reading_WC&quot; &quot;Milton_Keynes_MC&quot; &quot;Milton_Keynes_WC&quot; ...
##   .. ..$ : chr [1:5] &quot;Dim1&quot; &quot;Dim2&quot; &quot;Dim3&quot; &quot;Dim4&quot; ...
##  $ colsup    : logi(0) 
##  $ N         : int [1:6, 1:6] 4 4 36 32 21 72 49 14 6 0 ...
##  $ call      : language ca.matrix(obj = as.matrix(obj))
##  - attr(*, &quot;class&quot;)= chr &quot;ca&quot;</code></pre>
<p>We can also print a condensed summary of the analysis’ results with
<code>summary</code> where variables are abbreviated in the output. We
will explain the values’ significance in short.</p>
<pre class="r"><code># print summary
summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
</div>
</div>
<div id="observed-proportions-profiles-and-masses"
class="section level1">
<h1>1.0 Observed proportions, profiles and masses</h1>
<p>Before we start with the mathematical calculations to obtain observed
proportions, we need to transform the raw frequencies in the contingency
table, e.g. by adding the margin totals.</p>
<div id="row-and-column-totals" class="section level2">
<h2>1.1 Row and Column Totals</h2>
<p>We create the row sums (<code>rowSums</code>) and column sums
(<code>colSums</code>) of N, bind them to the margins of the original
table and name the additional row and column.</p>
<pre class="r"><code>N_total = rbind(N, colSums(N))
N_total = cbind(N_total, rowSums(N_total))
rownames(N_total)[7] &lt;- &quot;columntotal&quot;
colnames(N_total)[7] &lt;- &quot;rowtotal&quot;
N_total</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["rowtotal"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"4","2":"49","3":"9","4":"44","5":"10","6":"66","7":"182","_rn_":"and that"},{"1":"4","2":"14","3":"2","4":"4","5":"1","6":"4","7":"29","_rn_":"and all that"},{"1":"36","2":"6","3":"45","4":"5","5":"62","6":"18","7":"172","_rn_":"and stuff"},{"1":"32","2":"0","3":"35","4":"0","5":"12","6":"5","7":"84","_rn_":"and things"},{"1":"21","2":"16","3":"22","4":"18","5":"30","6":"31","7":"138","_rn_":"and everything"},{"1":"72","2":"20","3":"30","4":"17","5":"23","6":"3","7":"165","_rn_":"or something"},{"1":"169","2":"105","3":"143","4":"88","5":"138","6":"127","7":"770","_rn_":"columntotal"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="calculating-observed-proportions-p-in-a-correspondence-matrix"
class="section level2">
<h2>1.2 Calculating observed proportions P in a correspondence
matrix</h2>
<p>In this step, we transform the frequencies of the contingency table
into proportions.</p>
<p>Therefore, we first need the total frequency n of all observed
instances in table <code>N</code> which can be obtained by applying the
function <code>sum()</code> to the table.</p>
<pre class="r"><code>n &lt;- sum(N)
n</code></pre>
<pre><code>## [1] 770</code></pre>
<p>Next, we create the table with the observed proportions
<code>P</code> through the following formula. To calculate the
<em>correspondence matrix</em> of relative frequencies p<sub>ij</sub>,
frequencies are divided by the total frequency n.</p>
<pre class="r"><code>P &lt;- N/n

P</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.005194805","2":"0.063636364","3":"0.011688312","4":"0.057142857","5":"0.012987013","6":"0.085714286","_rn_":"and that"},{"1":"0.005194805","2":"0.018181818","3":"0.002597403","4":"0.005194805","5":"0.001298701","6":"0.005194805","_rn_":"and all that"},{"1":"0.046753247","2":"0.007792208","3":"0.058441558","4":"0.006493506","5":"0.080519481","6":"0.023376623","_rn_":"and stuff"},{"1":"0.041558442","2":"0.000000000","3":"0.045454545","4":"0.000000000","5":"0.015584416","6":"0.006493506","_rn_":"and things"},{"1":"0.027272727","2":"0.020779221","3":"0.028571429","4":"0.023376623","5":"0.038961039","6":"0.040259740","_rn_":"and everything"},{"1":"0.093506494","2":"0.025974026","3":"0.038961039","4":"0.022077922","5":"0.029870130","6":"0.003896104","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
</div>
<div id="profiles-and-masses" class="section level2">
<h2>1.3 Profiles and Masses</h2>
<p>In this section we will understand the important concepts of profiles
and masses.</p>
<div id="row-and-column-profiles" class="section level3">
<h3>1.3.1 Row and column profiles</h3>
<blockquote>
<p>A row, or a column of a contingency table in which elements have been
divided by the row sums or column sums respectively. Profiles are
visualized as points in space by correspondence analysis.(cf. Hautz
&amp; Bleuel 2018:221)</p>
</blockquote>
<p>For the next step, we note that profiles are obtained by creating
relative frequencies from the marginal sums instead of dividing them by
the total frequency n.</p>
<div id="row-profiles" class="section level4">
<h4>Row profiles</h4>
<p>Considering the row sums, we obtain relative frequencies for the
rows, that make the profile for each row point.</p>
<p>The row profile for the row point ‘<em>and that</em>’ across the
social-geographical groups of teenagers is determined in the following
way: We divide the count in each cell in the row by the row sum in
<code>N_total</code> of the respective row.</p>
<p>The calculations inside the first row are the following: <span
class="math display">\[4 : 182, 49:182, 9:182, 44:182, 10:182,
66:182\]</span></p>
<pre class="r"><code>N[1,1]/N_total[1,7]</code></pre>
<pre><code>## [1] 0.02197802</code></pre>
<pre class="r"><code>N[1,2]/N_total[1,7]</code></pre>
<pre><code>## [1] 0.2692308</code></pre>
<pre class="r"><code>N[1,3]/N_total[1,7]</code></pre>
<pre><code>## [1] 0.04945055</code></pre>
<pre class="r"><code>N[1,4]/N_total[1,7]</code></pre>
<pre><code>## [1] 0.2417582</code></pre>
<pre class="r"><code>N[1,5]/N_total[1,7]</code></pre>
<pre><code>## [1] 0.05494505</code></pre>
<pre class="r"><code>N[1,6]/N_total[1,7]</code></pre>
<pre><code>## [1] 0.3626374</code></pre>
<p>The percentages are used to normalize the row totals to the value 1,
so that the rows can now be compared with each other regardless of the
frequency of their absolute mentions.</p>
<p>The first value of the row profile indicates that the extender
‘<em>and that</em>’ is in 2% used by ‘<em>Reading_MC</em>’
teenagers.</p>
<p><strong>Matrix of row profiles or profiles of extenders</strong></p>
<p>To obtain the row profiles for the complete table we use the
<code>sweep()</code> function which is similar to
<code>apply()</code>.</p>
<p><code>sweep(x, MARGIN, STATS, FUN)</code> applies an operation to a
data matrix over the rows or over the columns. The parameter
<code>MARGIN =1</code> sweeps over the rows, while
<code>MARGIN =2</code> sweeps over the columns. STATS is the value used
in the operation (e.g. 2), FUN is the type of operation (e.g. +, -).</p>
<pre class="r"><code># sweep function divides each element of the matrix N by the sum of its respective row
# 1: The margin over which the operation is applied. 1 indicates rows, and 2 would indicate columns
# &quot;/&quot; indicates division operation
row.profiles = sweep(N, 1, (rowSums(N)), &quot;/&quot;)
row.profiles</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02197802","2":"0.26923077","3":"0.04945055","4":"0.24175824","5":"0.05494505","6":"0.36263736","_rn_":"and that"},{"1":"0.13793103","2":"0.48275862","3":"0.06896552","4":"0.13793103","5":"0.03448276","6":"0.13793103","_rn_":"and all that"},{"1":"0.20930233","2":"0.03488372","3":"0.26162791","4":"0.02906977","5":"0.36046512","6":"0.10465116","_rn_":"and stuff"},{"1":"0.38095238","2":"0.00000000","3":"0.41666667","4":"0.00000000","5":"0.14285714","6":"0.05952381","_rn_":"and things"},{"1":"0.15217391","2":"0.11594203","3":"0.15942029","4":"0.13043478","5":"0.21739130","6":"0.22463768","_rn_":"and everything"},{"1":"0.43636364","2":"0.12121212","3":"0.18181818","4":"0.10303030","5":"0.13939394","6":"0.01818182","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Note: <code>apply()</code> (returns a vector, array or a list of
values by applying a function to the margins of an array (data object
with possibly more than two dimensions) or of a matrix);</p>
<p>The <strong>average row</strong> of the matrix of row profiles can be
determined by the column totals of the table of margin totals
<code>N_Total</code> divided by the total frequency n.</p>
<pre class="r"><code># calculatin averages
row.averages &lt;-  c(N_total[7,1]/n, N_total[7,2]/n, N_total[7,3]/n, N_total[7,4]/n, N_total[7,5]/n, N_total[7,6]/n)
# appending the averages to a new row
row.profiles.av &lt;- rbind(row.profiles, row.averages)
# and naming the row
rownames(row.profiles.av) [7] &lt;- &quot;average row profile&quot;
row.profiles.av</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02197802","2":"0.26923077","3":"0.04945055","4":"0.24175824","5":"0.05494505","6":"0.36263736","_rn_":"and that"},{"1":"0.13793103","2":"0.48275862","3":"0.06896552","4":"0.13793103","5":"0.03448276","6":"0.13793103","_rn_":"and all that"},{"1":"0.20930233","2":"0.03488372","3":"0.26162791","4":"0.02906977","5":"0.36046512","6":"0.10465116","_rn_":"and stuff"},{"1":"0.38095238","2":"0.00000000","3":"0.41666667","4":"0.00000000","5":"0.14285714","6":"0.05952381","_rn_":"and things"},{"1":"0.15217391","2":"0.11594203","3":"0.15942029","4":"0.13043478","5":"0.21739130","6":"0.22463768","_rn_":"and everything"},{"1":"0.43636364","2":"0.12121212","3":"0.18181818","4":"0.10303030","5":"0.13939394","6":"0.01818182","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.17922078","6":"0.16493506","_rn_":"average row profile"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>The average row profile tells us that irrespective of the chosen
extender 21% of the usages are attributed to ‘<em>Reading_MC</em>’, 13%
to ‘<em>Reading_WC</em>’, 18% to ‘<em>Milton_Keynes_MC</em>’, 11% to
‘<em>Milton_Keynes_WC</em>’, 17% to ‘<em>Hull_MC</em>’ and 16% to
‘<em>Hull_WC</em>’ teenagers. In this way, we can compare the profiles
of extenders to each other or to the average row. The use of the
extender ‘<em>and that</em>’ e.g. lies below the average row profile in
case of ‘<em>Reading_MC</em>’, ‘<em>Milton_Keynes_MC</em>’ and
‘<em>Hull_MC</em>’, and above the average row profile in case of
‘<em>Reading_WC</em>’, ‘<em>Milton_Keynes_WC</em>’ and
‘<em>Hull_WC</em>’.</p>
</div>
<div id="column-profiles" class="section level4">
<h4>Column profiles</h4>
<p>Considering the column sums, we obtain relative frequencies for the
columns, that make the profile for each column point . For example for
the first column:</p>
<pre class="r"><code>N_total[1,1]/N_total[7,1]</code></pre>
<pre><code>## [1] 0.02366864</code></pre>
<pre class="r"><code>N_total[2,1]/N_total[7,1]</code></pre>
<pre><code>## [1] 0.02366864</code></pre>
<pre class="r"><code>N_total[3,1]/N_total[7,1]</code></pre>
<pre><code>## [1] 0.2130178</code></pre>
<pre class="r"><code>N_total[4,1]/N_total[7,1]</code></pre>
<pre><code>## [1] 0.1893491</code></pre>
<pre class="r"><code>N_total[5,1]/N_total[7,1]</code></pre>
<pre><code>## [1] 0.1242604</code></pre>
<pre class="r"><code>N_total[6,1]/N_total[7,1]</code></pre>
<pre><code>## [1] 0.4260355</code></pre>
<p><strong>Matrix of column profiles</strong>, or profiles of
social-geographical groups of teenagers</p>
<pre class="r"><code># sweep operation on columns
col.profiles = sweep(N, 2, (colSums(N)), &quot;/&quot;)
col.profiles</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02366864","2":"0.46666667","3":"0.06293706","4":"0.50000000","5":"0.072463768","6":"0.51968504","_rn_":"and that"},{"1":"0.02366864","2":"0.13333333","3":"0.01398601","4":"0.04545455","5":"0.007246377","6":"0.03149606","_rn_":"and all that"},{"1":"0.21301775","2":"0.05714286","3":"0.31468531","4":"0.05681818","5":"0.449275362","6":"0.14173228","_rn_":"and stuff"},{"1":"0.18934911","2":"0.00000000","3":"0.24475524","4":"0.00000000","5":"0.086956522","6":"0.03937008","_rn_":"and things"},{"1":"0.12426036","2":"0.15238095","3":"0.15384615","4":"0.20454545","5":"0.217391304","6":"0.24409449","_rn_":"and everything"},{"1":"0.42603550","2":"0.19047619","3":"0.20979021","4":"0.19318182","5":"0.166666667","6":"0.02362205","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>From the column profile we grasp that in the group of
‘<em>Reading_MC</em>’ teenagers, the extender ‘<em>and that</em>’ was
used in 2%, ‘<em>and all that</em>’ in 2%, ‘<em>and stuff</em>’ in 21%,
‘<em>and things</em>’ in 18%, ‘<em>and everything</em>’ in 12% and
‘<em>or something</em>’ in 42% of cases.</p>
<p>We again add the average column profile to the table in the last
column.</p>
<pre class="r"><code># calculate averages
col.averages &lt;-  c(N_total[1,7]/n, N_total[2,7]/n, N_total[3,7]/n, N_total[4,7]/n, N_total[5,7]/n, N_total[6,7]/n)
# append averages to new column
col.profiles.av &lt;- cbind(col.profiles, col.averages)
# name column
colnames(col.profiles.av) [7] &lt;- &quot;average column profile&quot;

col.profiles.av</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["average column profile"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02366864","2":"0.46666667","3":"0.06293706","4":"0.50000000","5":"0.072463768","6":"0.51968504","7":"0.23636364","_rn_":"and that"},{"1":"0.02366864","2":"0.13333333","3":"0.01398601","4":"0.04545455","5":"0.007246377","6":"0.03149606","7":"0.03766234","_rn_":"and all that"},{"1":"0.21301775","2":"0.05714286","3":"0.31468531","4":"0.05681818","5":"0.449275362","6":"0.14173228","7":"0.22337662","_rn_":"and stuff"},{"1":"0.18934911","2":"0.00000000","3":"0.24475524","4":"0.00000000","5":"0.086956522","6":"0.03937008","7":"0.10909091","_rn_":"and things"},{"1":"0.12426036","2":"0.15238095","3":"0.15384615","4":"0.20454545","5":"0.217391304","6":"0.24409449","7":"0.17922078","_rn_":"and everything"},{"1":"0.42603550","2":"0.19047619","3":"0.20979021","4":"0.19318182","5":"0.166666667","6":"0.02362205","7":"0.21428571","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>From the average column profile we can read that irrespective of the
social-geographical groups, 23% of the instances are ‘<em>and
that</em>’, 3% ‘<em>and all that</em>’, 22% ‘<em>and stuff</em>’, 10%
‘<em>and things</em>’, 17% ‘<em>and everything</em>’, 21% ‘<em>or
something</em>’. We can compare the profiles of social-geographical
groups to each other or to the average column.</p>
<p>The use in the group of ‘<em>Hull_WC</em>’ e.g. is above the average
column for ‘<em>and that</em>’ and ‘<em>and everything</em>’, and below
the average column for extenders ‘<em>and all that</em>’, ‘<em>and
stuff</em>’, ‘<em>and things</em>’, ‘<em>or something</em>’.</p>
<p>One can argue from the point of view of the row or column profiles
and reach the same conclusions (symmetric view). However, the data
tables are sometimes considered asymmetrically as a set of rows or set
of columns, depending on the interest.</p>
<p>The information from both tables can be used to calculate the
<em>contingency ratios</em> (cf. Greenacre 2007:11): those are formed
from a row profile element and the corresponding average row profile or
from a column profile element and the corresponding average column
profile. Look at the code below for the different ways to obtain the
equal ratios. In the interpretation, the ratio of ‘<em>and things</em>’
and ‘<em>Reading_MC</em>’ e.g. says that the combination occurs 1.7
times as much compared to the average.</p>
<pre class="r"><code>sweep(row.profiles, 2,row.averages, &quot;/&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.1001365","2":"1.9743590","3":"0.2662722","4":"2.1153846","5":"0.3065775","6":"2.1986675","_rn_":"and that"},{"1":"0.6284432","2":"3.5402299","3":"0.3713528","4":"1.2068966","5":"0.1924038","6":"0.8362748","_rn_":"and all that"},{"1":"0.9536260","2":"0.2558140","3":"1.4087657","4":"0.2543605","5":"2.0112909","6":"0.6344992","_rn_":"and stuff"},{"1":"1.7357002","2":"0.0000000","3":"2.2435897","4":"0.0000000","5":"0.7971014","6":"0.3608924","_rn_":"and things"},{"1":"0.6933368","2":"0.8502415","3":"0.8584169","4":"1.1413043","5":"1.2129805","6":"1.3619765","_rn_":"and everything"},{"1":"1.9881657","2":"0.8888889","3":"0.9790210","4":"0.9015152","5":"0.7777778","6":"0.1102362","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>sweep(col.profiles, 1,col.averages, &quot;/&quot;)</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.1001365","2":"1.9743590","3":"0.2662722","4":"2.1153846","5":"0.3065775","6":"2.1986675","_rn_":"and that"},{"1":"0.6284432","2":"3.5402299","3":"0.3713528","4":"1.2068966","5":"0.1924038","6":"0.8362748","_rn_":"and all that"},{"1":"0.9536260","2":"0.2558140","3":"1.4087657","4":"0.2543605","5":"2.0112909","6":"0.6344992","_rn_":"and stuff"},{"1":"1.7357002","2":"0.0000000","3":"2.2435897","4":"0.0000000","5":"0.7971014","6":"0.3608924","_rn_":"and things"},{"1":"0.6933368","2":"0.8502415","3":"0.8584169","4":"1.1413043","5":"1.2129805","6":"1.3619765","_rn_":"and everything"},{"1":"1.9881657","2":"0.8888889","3":"0.9790210","4":"0.9015152","5":"0.7777778","6":"0.1102362","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>The calculated profiles are relevant for the geometrical
representation as the following quotes by Greenacre (2007) are pointing
towards:</p>
<blockquote>
<p>Profiles consisting of m elements can be plotted as points in an
m-dimensional space. Because their m elements add up to 1, these profile
points occupy a restricted region of this space. This region is an
(m–1)-dimensional subspace known as a simplex. This simplex is enclosed
within the edges joining all pairs of the m unit vectors on the m
perpendicular axes. These unit points are also called the vertices of
the simplex or profile space. The coordinate system within this simplex
is known as the barycentric coordinate system. (Greenacre 2007:16)</p>
</blockquote>
<blockquote>
<p>Simplex: a triangle in two dimensions, a tetrahedron in three
dimensions, and generalizations of these geometric figures in higher
dimensions; in CA J-dimensional profiles lie inside a simplex defined by
J vertices in (J − 1)- dimensional space. (Greenacre 2007:265f.)</p>
</blockquote>
</div>
</div>
<div id="masses-of-rows-and-columns" class="section level3">
<h3>1.3.2 Masses of rows and columns</h3>
<p>The next step is to look at the concept of masses which are used as
weights in correspondence analysis.</p>
<blockquote>
<p>Row sums or column sums divided by the total frequency of the
contingency table.<br />
(cf. Hautz &amp; Bleuel 2018:221)</p>
</blockquote>
<p>The sum of rows and columns of the table with the proportions is
referred to as mass.</p>
<p>We calculate the column masses <code>column.masses</code> by
applying<code>colSums()</code>to the table of proportions.</p>
<pre class="r"><code>P</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.005194805","2":"0.063636364","3":"0.011688312","4":"0.057142857","5":"0.012987013","6":"0.085714286","_rn_":"and that"},{"1":"0.005194805","2":"0.018181818","3":"0.002597403","4":"0.005194805","5":"0.001298701","6":"0.005194805","_rn_":"and all that"},{"1":"0.046753247","2":"0.007792208","3":"0.058441558","4":"0.006493506","5":"0.080519481","6":"0.023376623","_rn_":"and stuff"},{"1":"0.041558442","2":"0.000000000","3":"0.045454545","4":"0.000000000","5":"0.015584416","6":"0.006493506","_rn_":"and things"},{"1":"0.027272727","2":"0.020779221","3":"0.028571429","4":"0.023376623","5":"0.038961039","6":"0.040259740","_rn_":"and everything"},{"1":"0.093506494","2":"0.025974026","3":"0.038961039","4":"0.022077922","5":"0.029870130","6":"0.003896104","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>column.masses = colSums(P)
column.masses</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##        0.2194805        0.1363636        0.1857143        0.1142857 
##          Hull_MC          Hull_WC 
##        0.1792208        0.1649351</code></pre>
<p>In the same way, we calculate row masses <code>row.masses</code> by
using <code>rowSums()</code>:</p>
<pre class="r"><code>row.masses = rowSums(P)
row.masses</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.23636364     0.03766234     0.22337662     0.10909091     0.17922078 
##   or something 
##     0.21428571</code></pre>
<p>In the next step, we want to add the masses to the corresponding
profiles. The row profile already contains the average row profile in
the last row, and we want to add the row mass as a new last column. The
column profile, on the other hand, contains the average column profile
as a last column and we want to add the column masses as the last row in
the table.</p>
<p>In order to arrive at the same number of rows and columns we have to
add NA values, because we don’t calculate a mass value for the average
row profile and average column profile.</p>
<pre class="r"><code>row.masses.na &lt;-c(row.masses[0:6],NA)
row.masses.na</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.23636364     0.03766234     0.22337662     0.10909091     0.17922078 
##   or something                
##     0.21428571             NA</code></pre>
<pre class="r"><code>column.masses.na &lt;- c(column.masses[0:6], NA)
column.masses.na</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##        0.2194805        0.1363636        0.1857143        0.1142857 
##          Hull_MC          Hull_WC                  
##        0.1792208        0.1649351               NA</code></pre>
<p>Remember, as the last row of the row profile we added the column sums
of the correspondence matrix (P); the column sums make the average row
profile and are actually identical to the column masses.</p>
<pre class="r"><code>row.averages</code></pre>
<pre><code>## [1] 0.2194805 0.1363636 0.1857143 0.1142857 0.1792208 0.1649351</code></pre>
<pre class="r"><code>as.numeric(column.masses[1:6])</code></pre>
<pre><code>## [1] 0.2194805 0.1363636 0.1857143 0.1142857 0.1792208 0.1649351</code></pre>
<p>Also, the values of the average column profile are the same as the
row masses:</p>
<pre class="r"><code>col.averages</code></pre>
<pre><code>## [1] 0.23636364 0.03766234 0.22337662 0.10909091 0.17922078 0.21428571</code></pre>
<pre class="r"><code>as.numeric(row.masses[1:6])</code></pre>
<pre><code>## [1] 0.23636364 0.03766234 0.22337662 0.10909091 0.17922078 0.21428571</code></pre>
<p>The average row profile is the <strong>centroid</strong> of the row
points in the correspondence space. This does not mean the “geographic”
center, but a weighted average so that the centroid is closer to points
with greater weight.</p>
<blockquote>
<p>Centroid: the weighted average point (Greenacre 2007:263)</p>
</blockquote>
<p>For the geometrical representation this means:</p>
<blockquote>
<p>There is an equivalent way of thinking about the positions of the
profile points in the profile space which is based on the notion of a
weighted average, or centroid, of a set of points. In the calculation of
an ordinary (unweighted) average, each point receives equal weight. A
weighted average, on the other hand, allows different weights to be
associated with each point. When points are weighted differently, then
the centroid does not lie exactly at the “geographical” centre of the
cloud of points, but tends to lie in a position closer to the points
with higher weight.(cf. Greenacre 2007:17)</p>
</blockquote>
<p>We are now in the position to add masses to the corresponding
profiles:</p>
<pre class="r"><code>row.profiles.av.mass &lt;- cbind(row.profiles.av,row.masses.na)
colnames(row.profiles.av.mass) [7] &lt;- &quot;row.masses&quot; 
row.profiles.av.mass</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["row.masses"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02197802","2":"0.26923077","3":"0.04945055","4":"0.24175824","5":"0.05494505","6":"0.36263736","7":"0.23636364","_rn_":"and that"},{"1":"0.13793103","2":"0.48275862","3":"0.06896552","4":"0.13793103","5":"0.03448276","6":"0.13793103","7":"0.03766234","_rn_":"and all that"},{"1":"0.20930233","2":"0.03488372","3":"0.26162791","4":"0.02906977","5":"0.36046512","6":"0.10465116","7":"0.22337662","_rn_":"and stuff"},{"1":"0.38095238","2":"0.00000000","3":"0.41666667","4":"0.00000000","5":"0.14285714","6":"0.05952381","7":"0.10909091","_rn_":"and things"},{"1":"0.15217391","2":"0.11594203","3":"0.15942029","4":"0.13043478","5":"0.21739130","6":"0.22463768","7":"0.17922078","_rn_":"and everything"},{"1":"0.43636364","2":"0.12121212","3":"0.18181818","4":"0.10303030","5":"0.13939394","6":"0.01818182","7":"0.21428571","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.17922078","6":"0.16493506","7":"NA","_rn_":"average row profile"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>The masses of the rows together form the average column profile. This
is the centroid of the column points in the correspondence space. We
also append the column masses (the row sums of the correspondence matrix
P) to the column profile.</p>
<pre class="r"><code>col.profiles.av.mass &lt;- rbind(col.profiles.av, column.masses.na)
rownames(col.profiles.av.mass)[7] &lt;- &quot;col.masses&quot;
col.profiles.av.mass</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["average column profile"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02366864","2":"0.46666667","3":"0.06293706","4":"0.50000000","5":"0.072463768","6":"0.51968504","7":"0.23636364","_rn_":"and that"},{"1":"0.02366864","2":"0.13333333","3":"0.01398601","4":"0.04545455","5":"0.007246377","6":"0.03149606","7":"0.03766234","_rn_":"and all that"},{"1":"0.21301775","2":"0.05714286","3":"0.31468531","4":"0.05681818","5":"0.449275362","6":"0.14173228","7":"0.22337662","_rn_":"and stuff"},{"1":"0.18934911","2":"0.00000000","3":"0.24475524","4":"0.00000000","5":"0.086956522","6":"0.03937008","7":"0.10909091","_rn_":"and things"},{"1":"0.12426036","2":"0.15238095","3":"0.15384615","4":"0.20454545","5":"0.217391304","6":"0.24409449","7":"0.17922078","_rn_":"and everything"},{"1":"0.42603550","2":"0.19047619","3":"0.20979021","4":"0.19318182","5":"0.166666667","6":"0.02362205","7":"0.21428571","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.179220779","6":"0.16493506","7":"NA","_rn_":"col.masses"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Values of the row representation can be seen as weighted values of
the column representation and the values of the column representation
can be seen as weighted values of the row representation. For
illustration, consider that a cell value is multiplied by the mass and
divided by the average row (within a profile).</p>
<p>As an example we like to go from row profile [1,1] to column profile
[1,1]. To do so we multiply the cell of the row profile by the row mass
and divide by the average row. This results in the cell of the column
profile. (Alternative: cell of the row profile multiplied by row mass
divided by column mass of the column profile) <span
class="math display">\[0.02197802*0.2363636/0.2194805 =
0.02366864\]</span></p>
<p>View of both profiles</p>
<pre class="r"><code>row.profiles.av.mass</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["row.masses"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02197802","2":"0.26923077","3":"0.04945055","4":"0.24175824","5":"0.05494505","6":"0.36263736","7":"0.23636364","_rn_":"and that"},{"1":"0.13793103","2":"0.48275862","3":"0.06896552","4":"0.13793103","5":"0.03448276","6":"0.13793103","7":"0.03766234","_rn_":"and all that"},{"1":"0.20930233","2":"0.03488372","3":"0.26162791","4":"0.02906977","5":"0.36046512","6":"0.10465116","7":"0.22337662","_rn_":"and stuff"},{"1":"0.38095238","2":"0.00000000","3":"0.41666667","4":"0.00000000","5":"0.14285714","6":"0.05952381","7":"0.10909091","_rn_":"and things"},{"1":"0.15217391","2":"0.11594203","3":"0.15942029","4":"0.13043478","5":"0.21739130","6":"0.22463768","7":"0.17922078","_rn_":"and everything"},{"1":"0.43636364","2":"0.12121212","3":"0.18181818","4":"0.10303030","5":"0.13939394","6":"0.01818182","7":"0.21428571","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.17922078","6":"0.16493506","7":"NA","_rn_":"average row profile"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>col.profiles.av.mass</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["average column profile"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02366864","2":"0.46666667","3":"0.06293706","4":"0.50000000","5":"0.072463768","6":"0.51968504","7":"0.23636364","_rn_":"and that"},{"1":"0.02366864","2":"0.13333333","3":"0.01398601","4":"0.04545455","5":"0.007246377","6":"0.03149606","7":"0.03766234","_rn_":"and all that"},{"1":"0.21301775","2":"0.05714286","3":"0.31468531","4":"0.05681818","5":"0.449275362","6":"0.14173228","7":"0.22337662","_rn_":"and stuff"},{"1":"0.18934911","2":"0.00000000","3":"0.24475524","4":"0.00000000","5":"0.086956522","6":"0.03937008","7":"0.10909091","_rn_":"and things"},{"1":"0.12426036","2":"0.15238095","3":"0.15384615","4":"0.20454545","5":"0.217391304","6":"0.24409449","7":"0.17922078","_rn_":"and everything"},{"1":"0.42603550","2":"0.19047619","3":"0.20979021","4":"0.19318182","5":"0.166666667","6":"0.02362205","7":"0.21428571","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.179220779","6":"0.16493506","7":"NA","_rn_":"col.masses"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>Calculation with relevant columns of the profile</p>
<pre class="r"><code>row.profiles.av.mass[1,1]*row.profiles.av.mass[1,7]/row.profiles.av.mass[7,1]</code></pre>
<pre><code>## [1] 0.02366864</code></pre>
<pre class="r"><code>row.profiles.av.mass[1,1]*row.profiles.av.mass[1,7]/col.profiles.av.mass[7,1]</code></pre>
<pre><code>## [1] 0.02366864</code></pre>
<pre class="r"><code>col.profiles.av.mass[1,1]</code></pre>
<pre><code>## [1] 0.02366864</code></pre>
<p>To practise a little bit more, let’s assume we want to go from column
profile [1,1] to row profile [1,1]: Therefore, the cell of the column
profile is multiplied by the column mass and divided by the average
column, so we obtain the cell of the row profile. (Alternatively, cell
of the column profile multiplied by column mass divided by row mass)</p>
<p><span class="math display">\[0.02366864*0.2194805/0.2363636
=0.02197802\]</span></p>
<p>The code below illustrates the calculation.</p>
<pre class="r"><code>col.profiles.av.mass[1,1]*col.profiles.av.mass[7,1]/col.profiles.av.mass[1,7]</code></pre>
<pre><code>## [1] 0.02197802</code></pre>
<pre class="r"><code>col.profiles.av.mass[1,1]*col.profiles.av.mass[7,1]/row.profiles.av.mass[1,7]</code></pre>
<pre><code>## [1] 0.02197802</code></pre>
<pre class="r"><code>row.profiles.av.mass[1,1]</code></pre>
<pre><code>## [1] 0.02197802</code></pre>
<p>The same holds for average profiles of rows and columns, but first
let’s view both profiles again.</p>
<pre class="r"><code>row.profiles.av.mass</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["row.masses"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02197802","2":"0.26923077","3":"0.04945055","4":"0.24175824","5":"0.05494505","6":"0.36263736","7":"0.23636364","_rn_":"and that"},{"1":"0.13793103","2":"0.48275862","3":"0.06896552","4":"0.13793103","5":"0.03448276","6":"0.13793103","7":"0.03766234","_rn_":"and all that"},{"1":"0.20930233","2":"0.03488372","3":"0.26162791","4":"0.02906977","5":"0.36046512","6":"0.10465116","7":"0.22337662","_rn_":"and stuff"},{"1":"0.38095238","2":"0.00000000","3":"0.41666667","4":"0.00000000","5":"0.14285714","6":"0.05952381","7":"0.10909091","_rn_":"and things"},{"1":"0.15217391","2":"0.11594203","3":"0.15942029","4":"0.13043478","5":"0.21739130","6":"0.22463768","7":"0.17922078","_rn_":"and everything"},{"1":"0.43636364","2":"0.12121212","3":"0.18181818","4":"0.10303030","5":"0.13939394","6":"0.01818182","7":"0.21428571","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.17922078","6":"0.16493506","7":"NA","_rn_":"average row profile"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<pre class="r"><code>col.profiles.av.mass</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]},{"label":["average column profile"],"name":[7],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.02366864","2":"0.46666667","3":"0.06293706","4":"0.50000000","5":"0.072463768","6":"0.51968504","7":"0.23636364","_rn_":"and that"},{"1":"0.02366864","2":"0.13333333","3":"0.01398601","4":"0.04545455","5":"0.007246377","6":"0.03149606","7":"0.03766234","_rn_":"and all that"},{"1":"0.21301775","2":"0.05714286","3":"0.31468531","4":"0.05681818","5":"0.449275362","6":"0.14173228","7":"0.22337662","_rn_":"and stuff"},{"1":"0.18934911","2":"0.00000000","3":"0.24475524","4":"0.00000000","5":"0.086956522","6":"0.03937008","7":"0.10909091","_rn_":"and things"},{"1":"0.12426036","2":"0.15238095","3":"0.15384615","4":"0.20454545","5":"0.217391304","6":"0.24409449","7":"0.17922078","_rn_":"and everything"},{"1":"0.42603550","2":"0.19047619","3":"0.20979021","4":"0.19318182","5":"0.166666667","6":"0.02362205","7":"0.21428571","_rn_":"or something"},{"1":"0.21948052","2":"0.13636364","3":"0.18571429","4":"0.11428571","5":"0.179220779","6":"0.16493506","7":"NA","_rn_":"col.masses"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>To calculate the 1st value of the average row profile, we multiply
the components from the table of the row profile in the 1st column by
the corresponding values of the average column profile and sum them
up:</p>
<p><span class="math display">\[(0.02197802*0.23636364) +
(0.13793103*0.03766234) + (0.20930233*0.22337662) + (0.38095238*
0.10909091) + (0.15217391*0.17922078) + (0.43636364*0.21428571) =
0.21948052   \]</span></p>
<pre class="r"><code>sum(row.profiles.av.mass[1:6 ,1]*col.profiles.av.mass[1:6,7])</code></pre>
<pre><code>## [1] 0.2194805</code></pre>
<pre class="r"><code>row.profiles.av.mass[7,1]</code></pre>
<pre><code>## [1] 0.2194805</code></pre>
<p>To practise, let’s calculate the 1st value of the average column
profile. Therefore, components from the table of the 1st row column
profile are multiplied by the corresponding values of the average row
profile and summed up</p>
<p><span class="math display">\[(0.02366864*0.21948052) +
(0.46666667*0.13636364) + (0.06293706*0.18571429) +
(0.50000000*0.11428571) + (0.072463768*0.17922078) +
(0.51968504*0.16493506) = 0.2363636\]</span></p>
<p>The calculation in R looks the following:</p>
<pre class="r"><code>sum(col.profiles.av.mass[1,1:6]*row.profiles.av.mass[7,1:6])</code></pre>
<pre><code>## [1] 0.2363636</code></pre>
<pre class="r"><code>col.profiles.av.mass[1,7]</code></pre>
<pre><code>## [1] 0.2363636</code></pre>
<p>For the validation of calculated row and column masses, see Sec.
7.1.</p>
</div>
</div>
</div>
<div id="expected-proportions-and-frequencies" class="section level1">
<h1>2. Expected Proportions and Frequencies</h1>
<div id="expected-proportions-expected-proportions-e"
class="section level2">
<h2>2.1 Expected proportions (expected proportions) E</h2>
<p>Referring back to Table P with the proportions, e.g. 0.5% of the
examples correspond to the extender ‘<em>and that</em>’ in the
social-geographical group ‘<em>Reading_MC</em>’.</p>
<pre class="r"><code>P</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"0.005194805","2":"0.063636364","3":"0.011688312","4":"0.057142857","5":"0.012987013","6":"0.085714286","_rn_":"and that"},{"1":"0.005194805","2":"0.018181818","3":"0.002597403","4":"0.005194805","5":"0.001298701","6":"0.005194805","_rn_":"and all that"},{"1":"0.046753247","2":"0.007792208","3":"0.058441558","4":"0.006493506","5":"0.080519481","6":"0.023376623","_rn_":"and stuff"},{"1":"0.041558442","2":"0.000000000","3":"0.045454545","4":"0.000000000","5":"0.015584416","6":"0.006493506","_rn_":"and things"},{"1":"0.027272727","2":"0.020779221","3":"0.028571429","4":"0.023376623","5":"0.038961039","6":"0.040259740","_rn_":"and everything"},{"1":"0.093506494","2":"0.025974026","3":"0.038961039","4":"0.022077922","5":"0.029870130","6":"0.003896104","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>For an estimation about whether this value is large or small, we can
calculate the value we expect if we assume that there is no relationship
between extender and social-geographical group.</p>
<p>From the sums calculated, we know that 23% of the extenders are
‘<em>and that</em>’ (row mass) and that 21% are in the
social-geographical group ‘<em>Reading MC</em>’ (column mass). If there
is no relationship between extender and social-geographical group, we
expect that 21% of 23% of examples ( 0.051 = 5.1%) are the extender
‘<em>and that</em>’ in the social-geographical group ‘<em>Reading
MC</em>’.</p>
<pre class="r"><code>row.masses</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.23636364     0.03766234     0.22337662     0.10909091     0.17922078 
##   or something 
##     0.21428571</code></pre>
<pre class="r"><code>column.masses</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##        0.2194805        0.1363636        0.1857143        0.1142857 
##          Hull_MC          Hull_WC 
##        0.1792208        0.1649351</code></pre>
<p>The expected proportion is calculated by multiplying the column and
row masses: <span class="math display">\[0.23636364*0.2194805 =
0.05187721 \]</span></p>
<pre class="r"><code>column.masses[1] * row.masses[1] </code></pre>
<pre><code>## Reading_MC 
## 0.05187721</code></pre>
<p><code>%o%</code> is used to create a table so that for each cell the
corresponding row masses and column masses are multiplied. The result is
table <code>E</code></p>
<pre class="r"><code>E = row.masses %o% column.masses
E</code></pre>
<pre><code>##                 Reading_MC  Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## and that       0.051877214 0.032231405      0.043896104      0.027012987
## and all that   0.008266149 0.005135773      0.006994434      0.004304267
## and stuff      0.049026817 0.030460449      0.041484230      0.025528757
## and things     0.023943329 0.014876033      0.020259740      0.012467532
## and everything 0.039335470 0.024439197      0.033283859      0.020482375
## or something   0.047031540 0.029220779      0.039795918      0.024489796
##                    Hull_MC    Hull_WC
## and that       0.042361275 0.03898465
## and all that   0.006749874 0.00621184
## and stuff      0.040033733 0.03684264
## and things     0.019551358 0.01799292
## and everything 0.032120088 0.02955979
## or something   0.038404453 0.03534323</code></pre>
</div>
<div id="expected-frequencies" class="section level2">
<h2>2.2 Expected Frequencies</h2>
<blockquote>
<p>Frequencies to be expected if there is no correlation between the
characteristics under consideration (null hypothesis of independence,
homogeneity assumption). (cf. Hautz &amp; Bleuel 2018: S. 220)</p>
</blockquote>
<p>Relative to the total frequency of n examples, each of which has a
probability of 0.05187721 of exhibiting the combination of ‘<em>and
that</em>’ and ‘<em>Reading_MC</em>’, n* the probability of examples are
expected.</p>
<p>We obtain the expected frequencies by multiplying the expected
proportions by the total frequency.</p>
<pre class="r"><code>Ew = E*n
Ew</code></pre>
<pre><code>##                Reading_MC Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## and that        39.945455  24.818182        33.800000        20.800000
## and all that     6.364935   3.954545         5.385714         3.314286
## and stuff       37.750649  23.454545        31.942857        19.657143
## and things      18.436364  11.454545        15.600000         9.600000
## and everything  30.288312  18.818182        25.628571        15.771429
## or something    36.214286  22.500000        30.642857        18.857143
##                  Hull_MC   Hull_WC
## and that       32.618182 30.018182
## and all that    5.197403  4.783117
## and stuff      30.825974 28.368831
## and things     15.054545 13.854545
## and everything 24.732468 22.761039
## or something   29.571429 27.214286</code></pre>
<p>Alternatively, we can also calculate the expected frequency for cell
ij as we practise now.</p>
<p>We multiply row sum i from table N with the column sum j from table N
and divide by n. </p>
<pre class="r"><code>rowSums(N) %o% colSums(N)/n</code></pre>
<pre><code>##                Reading_MC Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## and that        39.945455  24.818182        33.800000        20.800000
## and all that     6.364935   3.954545         5.385714         3.314286
## and stuff       37.750649  23.454545        31.942857        19.657143
## and things      18.436364  11.454545        15.600000         9.600000
## and everything  30.288312  18.818182        25.628571        15.771429
## or something    36.214286  22.500000        30.642857        18.857143
##                  Hull_MC   Hull_WC
## and that       32.618182 30.018182
## and all that    5.197403  4.783117
## and stuff      30.825974 28.368831
## and things     15.054545 13.854545
## and everything 24.732468 22.761039
## or something   29.571429 27.214286</code></pre>
</div>
</div>
<div id="chi-squared-statistics-and-distances" class="section level1">
<h1>3. Chi-squared statistics and distances</h1>
<div id="chi-square-statistic" class="section level2">
<h2>3.1 Chi-square statistic</h2>
<p>We have applied the statistical test before using the
<code>chisq()</code>function, but now, we will see how to calculate it
ourselves.</p>
<blockquote>
<p>chi-square statistic — the statistic used commonly for testing the
indepedence model for a contingency table; calculated as the sum of
squared differences between observed frequencies and frequencies
expected according to the model, each squared difference being divided
by the corresponding expected frequency. (Greenacre 2007:264)</p>
</blockquote>
<p>To calculate the value, we square the difference of the absolute
observed and expected frequencies, divide by the expected frequencies
and sum all values.</p>
<p><span class="math display">\[\chi^2 = \sum \frac {(observed -
expected)^2}{expected}\]</span></p>
<p>cf. Greenacre (2007:27)</p>
<p>In the formula below, we have to insert frequencies from table N and
expected frequencies from table Ew.</p>
<p><span class="math display">\[ \chi^2 = \sum^{I}_{i=1}
\sum^{J}_{j=1}\frac{(n_{ij}- \hat{n}_{ij})^2}{\hat{n}_{ij}} = \frac
{(4-39.945455)^2}{39.945455}+ \frac{(49 -
24.818182)^2}{24.818182}+...\]</span> cf. Blasius 2001:25. (n with hat
corresponds to expected frequency)</p>
<pre class="r"><code>chi2         &lt;- sum((N-Ew)^2/Ew)
chi2</code></pre>
<pre><code>## [1] 384.1155</code></pre>
<p>The larger the Chi-squared value (number of rows and columns
constant), the larger the weighted squared deviations between observed
and expected values. This means we are less confident that the
hypothesis of independence is true and the more likely we are going to
reject it.</p>
<p>What is the maximum value of Chi-square?</p>
<blockquote>
<p>The maximum Chi-square value is equal to the number of cases
multiplied by the minimum of rows and columns minus one.</p>
</blockquote>
<p>(cf. Blasius 2001:26)</p>
<pre class="r"><code>nrow(N)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>ncol(N)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>n*(ncol(N)-1)</code></pre>
<pre><code>## [1] 3850</code></pre>
<p>We can check the result of our calculation with the implemented
function: <code>chisq.test()</code> which will also provide the
p-value.</p>
<pre class="r"><code>x2_N.test &lt;- chisq.test(N, correct = F)</code></pre>
<pre><code>## Warning in chisq.test(N, correct = F): Chi-Quadrat-Approximation kann inkorrekt
## sein</code></pre>
<pre class="r"><code>x2_N.test</code></pre>
<pre><code>## 
##  Pearson&#39;s Chi-squared test
## 
## data:  N
## X-squared = 384.12, df = 25, p-value &lt; 2.2e-16</code></pre>
<p>Because of the problems emerging for Chi-squared test from the
dependence on the number of cases and from the impact of the table size,
coefficients like Cramer’s V have been proposed. The formula is the
following:</p>
<p><span class="math display">\[ V = \sqrt{\frac{\chi^2}{n * (min(I-1,
J-1)}} \]</span> cf. Blasius 2001:26.</p>
<p>Cramer’s V can take values between 0 (no correlation) and 1 (perfect
correlation).</p>
<pre class="r"><code>nrow(N)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>ncol(N)</code></pre>
<pre><code>## [1] 6</code></pre>
<pre class="r"><code>(min(dim(extendersdata))-1)</code></pre>
<pre><code>## [1] 5</code></pre>
<pre class="r"><code>chi2</code></pre>
<pre><code>## [1] 384.1155</code></pre>
<pre class="r"><code>CramersV&lt;-sqrt(x2_N.test$stat/(sum(extendersdata) * (min(dim(extendersdata))-1)))
CramersV</code></pre>
<pre><code>## X-squared 
## 0.3158643</code></pre>
<p>In correspondence analysis, a coefficient is determined analogously
to Cramer’s V.</p>
<div id="total-inertia" class="section level3">
<h3>3.1.1 <em>Total Inertia</em></h3>
<p>To determine the total inertia (how much variation is present in the
data), the Chi-squared value is divided by the total sum of the table or
grand total.</p>
<p><span class="math display">\[\lambda_G
=  \frac{\chi^2}{n}=  \frac{384.1155}{770}\]</span></p>
<pre class="r"><code>total.inertia = chi2/n
total.inertia</code></pre>
<pre><code>## [1] 0.4988513</code></pre>
<blockquote>
<p>Sum of squared Chi<sup>2</sup> distances of a set of profiles to
their centroid weighted by the masses of the profiles. (Hautz &amp;
Bleuel 2018:222)</p>
</blockquote>
<p>Alternatively, the total inertia weight is also obtained from the
squared deviations of expected and observed profile elements, weighted
by the corresponding average row and column profile elements.</p>
</div>
</div>
<div id="chi-squared-distance" class="section level2">
<h2>3.2 Chi-squared distance</h2>
<p>The concept of distance or (dis-)similary between variables in a
correspondence analysis map is based on the chi-squared distance: the
smaller Chi-squared distance between two profiles, the more similar they
are.</p>
<blockquote>
<p>Chi-squared distance: weighted Euclidean distance measure between
profiles, where each squared difference between profile elements is
divided by the corresponding element of the average profile.</p>
</blockquote>
<p>(cf. Greenacre 2007:263)</p>
<p>In the profile space, which is calculated later, the greater the
Chi-squared distance of a profile from the average profile, the greater
the distance of the corresponding point from the origin of the
coordinate system in the profile space. Also, the greater the
Chi-squared distance between two profiles, the greater the distance in
space. Chi-squared distance are defined only between two row profiles or
two column profiles (as well as those to the average profile). But not
between row profiles and column profiles.</p>
<p>Note: If you are interested, you may consider a discussion of
Breitung (2023) criticizing some undesirable features of chi-squared
distance when applied in correspondence analysis.</p>
<p>For the calculation we start by summing the squared deviations of
observed and expected values of the individual cells, and divide by the
respective expected values.</p>
<p>Chi-squared distance between row profiles (cf. Greenacre p.31)
a<sub>ij</sub> : the jth element of the row profile of row i;
c<sub>j</sub> : the mass of the jth column.</p>
<p><span class="math display">\[\sqrt
{\sum_j{\frac{(a_{ij}-a_{i&#39;j})^2}{c_j}}}\]</span></p>
<p>If you compare it to the formula for Eucledean distance you see the
difference in that the former uses weighting:</p>
<p><span class="math display">\[\sqrt
{\sum_j{(a_{ij}-a_{i&#39;j})^2}}\]</span></p>
<p>Chi-squared distance between column profiles b<sub>ij</sub> - the
i.th element of the column profile of column j; r<sub>i</sub>: the mass
of the i.th row</p>
<p><span class="math display">\[\sqrt
{\sum_i{\frac{(b_{ij}-b_{ij&#39;})^2}{r_i}}}\]</span></p>
<p>Chi-squared distance between row profile and average row profile</p>
<p><span class="math display">\[\sqrt
{\sum_j{\frac{(a_{ij}-c_j)^2}{c_j}}}\]</span></p>
<p>Chi-squared distance between column profile and average column
profile</p>
<p><span class="math display">\[\sqrt
{\sum_i{\frac{(b_{ij}-r_i)^2}{r_i}}}\]</span></p>
<p>Let’s illustrate the calculation of the chi-squared distance from the
first row of the row profile (‘<em>and that</em>’) to the average row or
to the centroid of the row profile (Z)</p>
<pre class="r"><code># Calculate the squared differences and divide by column profiles
diff1 &lt;- (row.profiles.av.mass[1,1] - col.profiles.av.mass[7,1])^2 / col.profiles.av.mass[7,1]
diff2 &lt;- (row.profiles.av.mass[1,2] - col.profiles.av.mass[7,2])^2 / col.profiles.av.mass[7,2]
diff3 &lt;- (row.profiles.av.mass[1,3] - col.profiles.av.mass[7,3])^2 / col.profiles.av.mass[7,3]
diff4 &lt;- (row.profiles.av.mass[1,4] - col.profiles.av.mass[7,4])^2 / col.profiles.av.mass[7,4]
diff5 &lt;- (row.profiles.av.mass[1,5] - col.profiles.av.mass[7,5])^2 / col.profiles.av.mass[7,5]
diff6 &lt;- (row.profiles.av.mass[1,6] - col.profiles.av.mass[7,6])^2 / col.profiles.av.mass[7,6]

# Sum the differences and take the square root
d2_andthat_av &lt;- sqrt(diff1 + diff2 + diff3 + diff4 + diff5 + diff6)


d2_andthat_av</code></pre>
<pre><code>## [1] 0.9340781</code></pre>
<p>Note we could also use a shorter alternative (inelegant) solution
with a loop:</p>
<p>For j, we loop from 1 to the last number of dimensions from our table
N (6) along the row profile and subtract in the first row for all
columns 1-6 from the cell value the column mass of the respective
column, square this and divide by the column mass of the respective
column. From the values summed in chidist, we take the root.
(cf. Greenacre 2007:218)</p>
<pre class="r"><code>chidist       &lt;- 0
for(j in 1:dim(N) [2]){
  chidist &lt;- chidist+(row.profiles.av.mass[1,j]-column.masses[j])^2/column.masses[j]
  }
sqrt(chidist)</code></pre>
<pre><code>## Reading_MC 
##  0.9340781</code></pre>
<p>Chi-squared distance between first (‘<em>and that</em>’) and second
row (‘<em>and all that</em>’) of the row profile.</p>
<pre class="r"><code># Calculate the squared differences and divide by column profiles
diff1 &lt;- (row.profiles.av.mass[1,1] - row.profiles.av.mass[2,1])^2 / col.profiles.av.mass[7,1]
diff2 &lt;- (row.profiles.av.mass[1,2] - row.profiles.av.mass[2,2])^2 / col.profiles.av.mass[7,2]
diff3 &lt;- (row.profiles.av.mass[1,3] - row.profiles.av.mass[2,3])^2 / col.profiles.av.mass[7,3]
diff4 &lt;- (row.profiles.av.mass[1,4] - row.profiles.av.mass[2,4])^2 / col.profiles.av.mass[7,4]
diff5 &lt;- (row.profiles.av.mass[1,5] - row.profiles.av.mass[2,5])^2 / col.profiles.av.mass[7,5]
diff6 &lt;- (row.profiles.av.mass[1,6] - row.profiles.av.mass[2,6])^2 / col.profiles.av.mass[7,6]

# Sum the differences and take the square root
d2_andthat_andallthat &lt;- sqrt(diff1 + diff2 + diff3 + diff4 + diff5 + diff6)

d2_andthat_andallthat</code></pre>
<pre><code>## [1] 0.8946881</code></pre>
<p>For the calculation of all Chi-squared distances we can use the
following function: <code>dist()</code> calculates as default a
Euclidean distance matrix between the rows of a matrix. The options set
for <code>sweep()</code> are 2 (move down the columns), the root of the
column masses is used as a vector, and the operation used is division
(cf. Greenacre 2007:219).</p>
<pre class="r"><code>dist.matrix.row &lt;- dist(sweep(row.profiles.av, 2, sqrt(column.masses), FUN=&quot;/&quot;)) 
dist.matrix.row</code></pre>
<pre><code>##                      and that and all that and stuff and things and everything
## and all that        0.8946881                                                 
## and stuff           1.4578076    1.5483608                                    
## and things          1.7194114    1.7024741 0.7460265                          
## and everything      0.8281350    1.1244819 0.6408689  1.0190857               
## or something        1.4017662    1.2617283 0.8305088  0.7225154      0.8184297
## average row profile 0.9340781    1.0534800 0.6130969  0.8552202      0.2438114
##                     or something
## and all that                    
## and stuff                       
## and things                      
## and everything                  
## or something                    
## average row profile    0.5971736</code></pre>
<pre class="r"><code>ca_validation$rowdist</code></pre>
<pre><code>## [1] 0.9340781 1.0534800 0.6130969 0.8552202 0.2438114 0.5971736</code></pre>
<p>In the above output you can compare the row chi-squared distances to
the centroid (average row profile) to the retrieved solution from the ca
package: <code>$rowdist</code>. Note that distances are only defined
between rows (and average row).</p>
<p>Now, let’s analogously move on to the Chi-squared distance between
column profiles: we calculate it for the sake of illustration for the
1st column (<em>Reading_MC</em>) and average column profile or centroid
of the column profile:</p>
<pre class="r"><code># Calculate the squared differences and divide by row profiles
diff1 &lt;- (col.profiles.av.mass[1,1] - row.profiles.av.mass[1,7])^2 / row.profiles.av.mass[1,7]
diff2 &lt;- (col.profiles.av.mass[2,1] - row.profiles.av.mass[2,7])^2 / row.profiles.av.mass[2,7]
diff3 &lt;- (col.profiles.av.mass[3,1] - row.profiles.av.mass[3,7])^2 / row.profiles.av.mass[3,7]
diff4 &lt;- (col.profiles.av.mass[4,1] - row.profiles.av.mass[4,7])^2 / row.profiles.av.mass[4,7]
diff5 &lt;- (col.profiles.av.mass[5,1] - row.profiles.av.mass[5,7])^2 / row.profiles.av.mass[5,7]
diff6 &lt;- (col.profiles.av.mass[6,1] - row.profiles.av.mass[6,7])^2 / row.profiles.av.mass[6,7]

# Sum the differences and take the square root
d2_ReadMC_av &lt;- sqrt(diff1 + diff2 + diff3 + diff4 + diff5 + diff6)


d2_ReadMC_av</code></pre>
<pre><code>## [1] 0.694421</code></pre>
<p>In order to calculate the distance matrix for columns by using
<code>dist()</code> and <code>sweep()</code>, we transpose the matrix of
the column profiles. Below you can verify the correct result and compare
it to the output of the $coldist variable from the ca object.</p>
<pre class="r"><code>col.profiles.av.t &lt;- t(col.profiles.av)
dist.matrix.col  &lt;- dist(sweep(col.profiles.av.t, 2, sqrt(row.masses), FUN=&quot;/&quot;)) 
dist.matrix.col</code></pre>
<pre><code>##                        Reading_MC Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## Reading_WC              1.3602863                                             
## Milton_Keynes_MC        0.5536544  1.3840590                                  
## Milton_Keynes_WC        1.3036111  0.4743091        1.3026568                 
## Hull_MC                 0.8517939  1.3650940        0.5849334        1.2550407
## Hull_WC                 1.4516556  0.7143889        1.2722161        0.4429410
## average column profile  0.6944210  0.8407669        0.5931724        0.7311693
##                          Hull_MC   Hull_WC
## Reading_WC                                
## Milton_Keynes_MC                          
## Milton_Keynes_WC                          
## Hull_MC                                   
## Hull_WC                1.1855142          
## average column profile 0.6243938 0.7798374</code></pre>
<pre class="r"><code>ca_validation$coldist</code></pre>
<pre><code>## [1] 0.6944210 0.8407669 0.5931724 0.7311693 0.6243938 0.7798374</code></pre>
</div>
</div>
<div id="residuals-standardized-residuals" class="section level1">
<h1>4. Residuals, standardized Residuals</h1>
<blockquote>
<p>Residuals, standardized residuals: Residuals are the differences
between observed and expected frequencies. The standardized residual in
row ij is obtained by dividing the residual by the square root of the
expected frequency of the cell. Correspondence analysis uses
standardized residuals converted to proportion values. (cf. Hautz &amp;
Bleuel 2018: 221)</p>
</blockquote>
<div id="residuals" class="section level2">
<h2>4.1 Residuals</h2>
<p>The residuals are calculated by subtracting the expected proportions
from the observed proportions. Normally, residuals are calculated in
statistics to determine the magnitude of error in a model.</p>
<p>In correspondence analysis, this is different; the focus is on
examining the residuals. They quantify the difference between the
observed data and what we would expect if there were no relationship
between row and column categories.</p>
<pre class="r"><code>R = P - E
R</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"-0.046682409","2":"0.031404959","3":"-0.0322077922","4":"0.030129870","5":"-0.029374262","6":"0.046729634","_rn_":"and that"},{"1":"-0.003071344","2":"0.013046045","3":"-0.0043970315","4":"0.000890538","5":"-0.005451172","6":"-0.001017035","_rn_":"and all that"},{"1":"-0.002273571","2":"-0.022668241","3":"0.0169573284","4":"-0.019035250","5":"0.040485748","6":"-0.013466015","_rn_":"and stuff"},{"1":"0.017615112","2":"-0.014876033","3":"0.0251948052","4":"-0.012467532","5":"-0.003966942","6":"-0.011499410","_rn_":"and things"},{"1":"-0.012062742","2":"-0.003659976","3":"-0.0047124304","4":"0.002894249","5":"0.006840951","6":"0.010699949","_rn_":"and everything"},{"1":"0.046474954","2":"-0.003246753","3":"-0.0008348794","4":"-0.002411874","5":"-0.008534323","6":"-0.031447124","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>The examples in the categories ‘<em>and that</em>’ and
‘<em>Reading_WC</em>’ show a high residual value of 0.031. The observed
proportion was about 6.3% which is 3% higher than the expected value of
3.2% assuming that there is no relationship between categories.</p>
<pre class="r"><code>P[1,2]</code></pre>
<pre><code>## [1] 0.06363636</code></pre>
<pre class="r"><code>E[1,2]</code></pre>
<pre><code>## [1] 0.0322314</code></pre>
<pre class="r"><code>R[1,2]</code></pre>
<pre><code>## [1] 0.03140496</code></pre>
<p>This suggests that in the example sentences of ‘<em>and that</em>’
and ‘<em>Reading_WC</em>’ it is more likely that the extender is used
than in the average sentence.</p>
</div>
<div id="calculation-of-the-standardized-residual-z"
class="section level2">
<h2>4.2 Calculation of the standardized residual Z</h2>
<p>The standardized residual Z provides a weighting of the SVD (Singular
Value Decomposition). Cells with a higher expected proportion are given
a greater weight in the data. The expected values are related to the
data set size. The weighting means that smaller cells in the table, for
which the sampling error will be larger, are weighted lower. This makes
the correspondence analysis relatively robust in dealing with outliers
caused by sampling error when the table is analyzed as a contingency
table.</p>
<p>Formula for the calculation of an element of the table of
standardized residuals: Deviation of observed from expected proportions
divided by the root of the expected proportions.</p>
<p><span class="math display">\[a_{ij} = \frac{(p_{ij} -
r_ic_j)}{\sqrt{r_ic_j}}\]</span> (cf. Blasius 2001:89)</p>
<pre class="r"><code>Z &lt;- R/sqrt(E)
Z</code></pre>
<div data-pagedtable="false">
<script data-pagedtable-source type="application/json">
{"columns":[{"label":[""],"name":["_rn_"],"type":[""],"align":["left"]},{"label":["Reading_MC"],"name":[1],"type":["dbl"],"align":["right"]},{"label":["Reading_WC"],"name":[2],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_MC"],"name":[3],"type":["dbl"],"align":["right"]},{"label":["Milton_Keynes_WC"],"name":[4],"type":["dbl"],"align":["right"]},{"label":["Hull_MC"],"name":[5],"type":["dbl"],"align":["right"]},{"label":["Hull_WC"],"name":[6],"type":["dbl"],"align":["right"]}],"data":[{"1":"-0.20495803","2":"0.17492771","3":"-0.153726227","4":"0.18332047","5":"-0.14271922","6":"0.23667127","_rn_":"and that"},{"1":"-0.03378134","2":"0.18204382","3":"-0.052575485","4":"0.01357384","5":"-0.06635018","6":"-0.01290404","_rn_":"and all that"},{"1":"-0.01026814","2":"-0.12988221","3":"0.083256071","4":"-0.11913620","5":"0.20234344","6":"-0.07015582","_rn_":"and stuff"},{"1":"0.11383954","2":"-0.12196734","3":"0.177008478","4":"-0.11165811","5":"-0.02837053","6":"-0.08572841","_rn_":"and things"},{"1":"-0.06082105","2":"-0.02341180","3":"-0.025830221","4":"0.02022300","5":"0.03817053","6":"0.06223448","_rn_":"and everything"},{"1":"0.21430108","2":"-0.01899343","3":"-0.004185087","4":"-0.01541211","5":"-0.04354901","6":"-0.16727376","_rn_":"or something"}],"options":{"columns":{"min":{},"max":[10]},"rows":{"min":[10],"max":[10]},"pages":{}}}
  </script>
</div>
<p>If the elements of the standardized residuals are squared, multiplied
by the total frequency, and then summed, the result is Chi<sup>2</sup>
(determined earlier):</p>
<pre class="r"><code>chi2.aus.res &lt;- sum(((Z)^2)*n)
chi2.aus.res</code></pre>
<pre><code>## [1] 384.1155</code></pre>
<pre class="r"><code>chi2</code></pre>
<pre><code>## [1] 384.1155</code></pre>
</div>
</div>
<div id="singular-value-decomposition" class="section level1">
<h1>5. Singular Value Decomposition</h1>
<p>Correspondence analysis seeks a low-dimensional subspace which should
be as close as possible to all points- the points are then projected
into the optimal subspace that captures as much of the variation in the
data as possible.</p>
<p>With respect to this objective, it is necessary to define what
proximity of points to the subspace means. Intuitively, one would want
to find distances of all profiles to an imaginary line for which the sum
of the distances is smallest (but this involves complicated
mathematics).</p>
<p>Instead, the problem can be simplified by defining a criterion for
the sum of squared distances, which is mathematically equivalent to a
least-squares method for finding an optimal subspace.</p>
<p>In correspondence analysis, the weighted sum of squared distances is
now taken as the criterion. (cf. Greenacre p. 47)</p>
<p>We assume i profile points in a multidimensional space and a
low-dimensional subspace S as candidates for the optimal subspace. For
the i.th profile point with mass m<sub>i</sub> we calculate the distance
between the point and S denoted by d<sub>i</sub>(S). The proximity of
the profile to the subspace is
m<sub>i</sub>[d<sub>i</sub>(S)]<sup>2</sup>, or the squared distance
weighted by the mass. The closeness of all profiles is obtained by
summation.</p>
<p><span class="math display">\[closeness\:to\:S = \sum_i
{m_i[d_i(S)]^2} \]</span></p>
<p>The optimal subspace must satisfy this criterion.</p>
<p>The computation of the solution of this problem can be achieved by
the singular value decomposition, a procedure that is crucial for
various methods of dimension reduction. In correspondence analysis, it
is applied to the matrix of standardized residuals.</p>
<p><strong>Singular value decomposition</strong></p>
<blockquote>
<p>a matrix decomposition similar to that of eigenvalues and
eigenvectors, but applicable to rectangular matrices; the squares of the
singular values are eigenvalues of particular square matrices, and the
left and right singular vectors are also eigenvectors</p>
</blockquote>
<p>A singular value decomposition is a generalization of the eigenvalue
decomposition (for square matrices) and can be applied to any
rectangular matrices.</p>
<p>The matrix is broken down into components, ordered from important to
unimportant. The algebraic notion of <em>rank</em> of a matrix is
geometrically equivalent to the notion of dimensions.</p>
<p>The dimensions of the optimal subspace are formed with a singular
value decomposition- for this purpose a first dimension is constructed,
which explains a maximum portion of the variation of the data. Then, a
second dimension is constructed such that it is orthogonal to the first
and again captures a maximum fraction of the remaining variation.<br />
In this way, the SVD successively partitions the total inertia or
<em>total inertia</em> λ<sub>G</sub> among the dimensions.</p>
<p>The singular value decomposition also provides the coordinates of the
row and column points in space in further steps of calculation.</p>
<div id="singular-value-decomposition-svd" class="section level2">
<h2>5.1 Singular Value Decomposition (SVD)</h2>
<p>The decomposition of a matrix A is defined as the product of three
matrices</p>
<p><span class="math display">\[A = U\:\Gamma\:V^T\]</span></p>
<p>Gamma is the diagonal matrix with singular values in descending order
<span class="math display">\[\gamma_1 \geq \gamma_2 \geq...\geq \gamma_k
\geq...\ge 0\]</span></p>
<p>In a diagonal matrix, all values except the diagonal are zeros. (For
the calculation in R a representation as a vector is sufficient.) The
last value is in principle 0 and in the present case, this can be
ignored, as well as the last columns in u and v, which are multiplied by
0.</p>
<p>The columns of the matrix U are called left singular vectors and
those of V are called right singular vectors. The left singular vectors
correspond to the rows, and the right singular vectors correspond to the
columns. The matrix V<sup>T</sup> was transposed.</p>
<p>Calculation is done with the <code>svd()</code> function, the
resulting object is named SVD.</p>
<pre class="r"><code>SVD = svd(Z)
rownames(SVD$u) = rownames(P)
rownames(SVD$v) = colnames(P)
SVD</code></pre>
<pre><code>## $d
## [1] 6.060062e-01 3.008137e-01 1.607557e-01 1.234302e-01 6.444914e-03
## [6] 5.716227e-17
## 
## $u
##                       [,1]       [,2]         [,3]        [,4]        [,5]
## and that       -0.74581697  0.0343327  0.258408633  0.08625193  0.36331840
## and all that   -0.22141071 -0.3374432 -0.424984372 -0.76097241 -0.19938988
## and stuff       0.36438129  0.5858549 -0.388772596 -0.12410007  0.36616763
## and things      0.41148888 -0.1013907  0.742380973 -0.39967833 -0.02082385
## and everything -0.08832644  0.2774550 -0.001780185  0.22830478 -0.82696443
## or something    0.29126613 -0.6741410 -0.224357864  0.43152628  0.09930197
##                     [,6]
## and that       0.4861724
## and all that   0.1940679
## and stuff      0.4726274
## and things     0.3302891
## and everything 0.4233448
## or something   0.4629100
## 
## $v
##                        [,1]       [,2]        [,3]       [,4]        [,5]
## Reading_MC        0.4475758 -0.5802251  0.01198114  0.3434696 -0.35414598
## Reading_WC       -0.4484272 -0.3751191 -0.42245171 -0.5842779 -0.04459817
## Milton_Keynes_MC  0.3804068  0.1294721  0.51410021 -0.5025702  0.36869699
## Milton_Keynes_WC -0.3883809 -0.1355026  0.05255666  0.5092823  0.67407932
## Hull_MC           0.2757946  0.5945829 -0.61401726  0.1161066  0.02626387
## Hull_WC          -0.4764213  0.3660214  0.42108500  0.1233774 -0.53064247
##                        [,6]
## Reading_MC       -0.4684875
## Reading_WC       -0.3692745
## Milton_Keynes_MC -0.4309458
## Milton_Keynes_WC -0.3380617
## Hull_MC          -0.4233448
## Hull_WC          -0.4061220</code></pre>
<p>Each singular value and the corresponding vectors (e.g. the columns
of u and v) correspond to one dimension. A property of U and V is that
the columns of U are orthogonal to each other and that the columns of V
are orthogonal to each other.</p>
</div>
<div id="eigenvalues" class="section level2">
<h2>5.2 Eigenvalues</h2>
<p>The squared singular values are called <em>eigenvalues</em>.</p>
<pre class="r"><code>eigenvalues = SVD$d^2
eigenvalues</code></pre>
<pre><code>## [1] 3.672435e-01 9.048886e-02 2.584241e-02 1.523503e-02 4.153691e-05
## [6] 3.267525e-33</code></pre>
<p>The inertia amount which is covered by a principal axis, the
so-called <em>principal inertia</em>, with reference to the first
principal axis, is also called <em>first principal inertia</em>. It is
also often called an eigenvalue because of the way it can be calculated,
as an eigenvalue of a square symmetric matrix.</p>
<p>The eigenvalue corresponds to the fraction of the total inertia
accounted for by dimension k and is notated as λ<sub>k</sub>. The sum of
the eigenvalues of all dimensions is equal to the total inertia
λ<sub>G</sub>. The fraction of the total inertia accounted for by 1 or
100 percent dimension λ<sub>k</sub> is called the eigenvalue fraction of
the kth dimension (calculated by λ<sub>k</sub>/λ<sub>G</sub>).</p>
<p>[Note: <em>K</em> is the dimensionality of the matrix in space or
rank, we also speak of factors and assign properties to the dimensions.
<em>k</em> is the number of factors, k is also used as an index. In
terms of inertia weights, we speak of a weight<sub>k</sub> as being on
the kth axis, and in terms of coordinates <sub>k</sub> we speak of a
coordinate on the kth factor].</p>
<p>The sum of the eigenvalues again gives the total inertia: (we had
already determined this in 3.1.1).</p>
<pre class="r"><code>inertia.sum = sum(eigenvalues)
inertia.sum</code></pre>
<pre><code>## [1] 0.4988513</code></pre>
<pre class="r"><code>total.inertia</code></pre>
<pre><code>## [1] 0.4988513</code></pre>
<p>The eigenvalue components of the first dimensions are determined as
follows: we divide each eigenvalue by the total inertia and express them
as proportions.</p>
<pre class="r"><code>prop.inertias = eigenvalues/total.inertia
prop.inertias</code></pre>
<pre><code>## [1] 7.361782e-01 1.813944e-01 5.180383e-02 3.054022e-02 8.326511e-05
## [6] 6.550099e-33</code></pre>
<pre class="r"><code>perc.inertias&lt;-round(prop.inertias*100, 3)
perc.inertias</code></pre>
<pre><code>## [1] 73.618 18.139  5.180  3.054  0.008  0.000</code></pre>
<p>Above, we have calculated that the first dimension of the
correspondence analysis explains 73.6% of the variation in the data and
the second explains 18.1%. The third dimension explains 5.1% and the
fourth 3%.</p>
<div id="scree-plot" class="section level3">
<h3>5.2.1 Scree-Plot</h3>
<p>In correspondence analysis, we usually inspect a bar chart (or
similar representation) with the inertia values as percentages to check
for the number of dimensions to be considered for the analysis. A rule
of thumb is to look for a bow in the graph and choose the dimensions
before the bow. The idea is to analyse the dimensions which can account
for most variation in the data.</p>
<p>To create the scree-plot for the inertia values, first, the axes are
counted over the length of the vector to name them. In the second step,
a bar chart of the rounded inertia values in percent is created. The
bars are named using the previously defined names.</p>
<p>For <code>ylim</code>, the rounded value of the largest singular
value increased by 20% is chosen as the axis maximum. With
<code>space=</code> the distance between the columns is determined and
<code>las=1</code> labels the Y-axis horizontally. <code>text()</code>
gets as X-coordinate a vector containing the numbers from 1 to the
number of CA-axes or percent values, decreased by 0.5. As the
Y-coordinate the percent values are chosen. The numbers above the bars
give the percentage values.</p>
<pre class="r"><code>nam &lt;- paste(&quot;Axis&quot;, 1:length(perc.inertias))  
barplot(perc.inertias, names.arg = nam, col = 8,  ylim=c(0,round(max(perc.inertias)+max(perc.inertias)/5,1)),space=0, las=1)
 text((1:length(perc.inertias))-0.5, perc.inertias, perc.inertias, pos=3) 
 title(main=&quot;Principal Inertias %&quot;, font=2) </code></pre>
<p><img src="MathCA22complete_files/figure-html/unnamed-chunk-60-1.png" width="672" /></p>
</div>
</div>
<div id="coordinates" class="section level2">
<h2>5.3 Coordinates</h2>
<div id="principal-coordinates" class="section level3">
<h3>5.3.1 Principal Coordinates</h3>
<p>The principal coordinates indicate the coordinate positions of the
profiles. Since the coordinates refer to the profiles on the principal
axes, they are also called principal coordinates.</p>
<blockquote>
<p>Coordinates of a set of points projected onto a principal axis, such
that their weighted sum of squares along an axis equals the principal
inertia on that axis. (cf. Greenacre 2007:265)</p>
</blockquote>
<p>For the localization of the i-th row on the k-th axis/factor we
calculate the product of the corresponding value of the matrix U of the
left singular vectors for one row on one axis and the singular value of
the k-th axis divided by the square root of the mass of the i-th
row.</p>
<p><span class="math display">\[f_{ik} = u_{ik}\:\gamma_k\:/
\sqrt{r_i}\]</span> (cf. Blasius 2001:92)</p>
<p>To illustrate the procedure, we calculate the values for the position
of the row ‘<em>and stuff</em>’ on the first axis and on the second
axis. Therefor we multiply the corresponding values from the matrix U of
the left singular vectors and the value of the axis divided by the
square root of the mass of the 3rd row.</p>
<pre class="r"><code># position on the first axis
SVD$u[3,1]*SVD$d[1]/sqrt(row.profiles.av.mass[3,7])</code></pre>
<pre><code>## and stuff 
## 0.4672123</code></pre>
<pre class="r"><code># position on the second axis
SVD$u[3,2]*SVD$d[2]/sqrt(row.profiles.av.mass[3,7])</code></pre>
<pre><code>## and stuff 
## 0.3728797</code></pre>
<p>The complete matrix F of principal coordinates of the rows is
calculated by using <code>sweep</code> again:</p>
<pre class="r"><code>pro &lt;- sweep(SVD$u, 2, SVD$d, &quot;*&quot;)
principal.coordinates.rows &lt;- sweep(pro, 1, (sqrt(row.masses)), &quot;/&quot;)
principal.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]          [,3]        [,4]          [,5]
## and that       -0.9296489  0.02124297  0.0854443178  0.02189778  0.0048163070
## and all that   -0.6913883 -0.52305167 -0.3520349827 -0.48399054 -0.0066216555
## and stuff       0.4672123  0.37287971 -0.1322340448 -0.03240968  0.0049931911
## and things      0.7549894 -0.09234246  0.3613258648 -0.14936125 -0.0004063346
## and everything -0.1264368  0.19714958 -0.0006759855  0.06656446 -0.0125895368
## or something    0.3813032 -0.43807823 -0.0779132260  0.11506209  0.0013825420
##                        [,6]
## and that       5.716227e-17
## and all that   5.716227e-17
## and stuff      5.716227e-17
## and things     5.716227e-17
## and everything 5.716227e-17
## or something   5.716227e-17</code></pre>
<p>We continue with the calculation of the principal coordinates of the
columns. For the localization of the j-th column on the k-th axis/factor
calculate the product of the corresponding value of the matrix V of the
right singular vectors for a column on an axis and the singular value of
the k-th axis divided by the root of the mass of the j-th column.</p>
<p><span class="math display">\[g_{jk} = v_{jk}\:\gamma_k /
\sqrt{c_j}\]</span> Calculation of the matrix G of principal coordinates
of the columns:</p>
<pre class="r"><code>pros &lt;- sweep(SVD$v, 2, SVD$d, &quot;*&quot;)
principal.coordinates.columns &lt;- sweep(pros, 1, (sqrt(column.masses)), &quot;/&quot;)
principal.coordinates.columns</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
</div>
<div id="standard-coordinates" class="section level3">
<h3>5.3.2 Standard coordinates</h3>
<blockquote>
<p>Coordinates of a set of points such that their weighted sum of
squares along an axis equals 1. (cf. Greenacre 2007:266)</p>
</blockquote>
<p>The standard coordinates stand for the coordinate positions of the
vertices (in geometry corner of a polygon with at least three corners).
They are standardized (mean = 0, standard deviation = 1). As a reminder:
the vertices define the boundaries of the profile space and correspond
to extreme (weighted) profiles, the labels are identical with the
variable values, but not their profiles. In six-dimensional space
e.g. 1,0,0,0,0,0; 0,1,0,0,0,0; 0,0,1,0,0,0; 0,0,0,1,0,0; 0,0,0,0,1,0;
0,0,0,0,0,1 i.e. there would be e.g. an extender whose examples would
all occur with one social-geographical group.</p>
<p><span class="math display">\[x_{ik} = u_{ik}\:/
\sqrt{r_i}\]</span></p>
<p>To calculate them, we divide each cell of the left singular vectors
by the square root of the row masses. We thus obtain the standard
coordinates of the rows:</p>
<pre class="r"><code>standard.coordinates.rows = sweep(SVD$u, 1, sqrt(row.masses), &quot;/&quot;)
standard.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]         [,3]       [,4]        [,5] [,6]
## and that       -1.5340585  0.07061836  0.531516423  0.1774102  0.74730358    1
## and all that   -1.1408932 -1.73878965 -2.189874992 -3.9211664 -1.02742346    1
## and stuff       0.7709695  1.23957042 -0.822577420 -0.2625749  0.77474911    1
## and things      1.2458445 -0.30697562  2.247670017 -1.2100862 -0.06304732    1
## and everything -0.2086395  0.65538773 -0.004205047  0.5392881 -1.95340659    1
## or something    0.6292068 -1.45631096 -0.484668381  0.9322033  0.21451677    1</code></pre>
<p><span class="math display">\[y_{jk} = v_{jk}\: / \sqrt{c_j} \]</span>
The same calculation is applied to the right singular vectors, where
column masses are used.</p>
<pre class="r"><code>standard.coordinates.columns = sweep(SVD$v, 1, sqrt(column.masses), &quot;/&quot;)
standard.coordinates.columns</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
</div>
<div id="reciprocal-calculation-of-the-coordinates"
class="section level3">
<h3>5.3.3 Reciprocal calculation of the coordinates</h3>
<p>The square root of principal inertia serves as a scaling factor to
get from vertex points positions’ to profile point positions
(cf. Greenacre 2007 p. 60).</p>
<p>To get from vertices to profiles, multiply by the root of principal
inertia. Alternatively, we could multiply by the singular value (since
the squared singular values are the eigenvalues).</p>
<p><span class="math display">\[profile\:coordinate =
vertex\:coordinate\:x \sqrt {principal\:inertia}\]</span></p>
<p>In the code below, we use the column vertex point coordinate to
calculate the column profile coordinates.</p>
<pre class="r"><code>principal.coordinates.columns.2 &lt;- sweep(standard.coordinates.columns, 2, (sqrt(eigenvalues)), &quot;*&quot;)
principal.coordinates.columns.2</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
<pre class="r"><code>principal.coordinates.columns.3 &lt;- sweep(standard.coordinates.columns, 2, SVD$d, &quot;*&quot;)
principal.coordinates.columns.3</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
<pre class="r"><code>principal.coordinates.columns</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
<p>To go back from profile to vertex points multiply the profile
coordinate value by the inverse of the square root of the principal
inertia. (Or in simpler terms: divide the profile coordinate by the
square root of the principal inertia.)</p>
<p><span class="math display">\[vertex\:coordinate =
principal\:coordinate\:x\:1/\sqrt{principal\:inertia} \]</span></p>
<pre class="r"><code>standard.coordinates.columns.2 &lt;- sweep(principal.coordinates.columns, 2, (1/(sqrt(eigenvalues))), &quot;*&quot;)
standard.coordinates.columns.2</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
<pre class="r"><code>standard.coordinates.columns</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
<p>Alternatively, the standard coordinates can be calculated from the
principal coordinates by means of division by the singular values: here
for the rows:</p>
<p><span class="math display">\[x_{ik} = f_{ik} / \gamma_k\]</span></p>
<pre class="r"><code>standard.coordinates.rows.3 &lt;- sweep(principal.coordinates.rows, 2, SVD$d, &quot;/&quot;)
standard.coordinates.rows.3</code></pre>
<pre><code>##                      [,1]        [,2]         [,3]       [,4]        [,5] [,6]
## and that       -1.5340585  0.07061836  0.531516423  0.1774102  0.74730358    1
## and all that   -1.1408932 -1.73878965 -2.189874992 -3.9211664 -1.02742346    1
## and stuff       0.7709695  1.23957042 -0.822577420 -0.2625749  0.77474911    1
## and things      1.2458445 -0.30697562  2.247670017 -1.2100862 -0.06304732    1
## and everything -0.2086395  0.65538773 -0.004205047  0.5392881 -1.95340659    1
## or something    0.6292068 -1.45631096 -0.484668381  0.9322033  0.21451677    1</code></pre>
<pre class="r"><code>standard.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]         [,3]       [,4]        [,5] [,6]
## and that       -1.5340585  0.07061836  0.531516423  0.1774102  0.74730358    1
## and all that   -1.1408932 -1.73878965 -2.189874992 -3.9211664 -1.02742346    1
## and stuff       0.7709695  1.23957042 -0.822577420 -0.2625749  0.77474911    1
## and things      1.2458445 -0.30697562  2.247670017 -1.2100862 -0.06304732    1
## and everything -0.2086395  0.65538773 -0.004205047  0.5392881 -1.95340659    1
## or something    0.6292068 -1.45631096 -0.484668381  0.9322033  0.21451677    1</code></pre>
<p>For the columns:</p>
<p><span class="math display">\[y_{jk} = g_{jk}/ \gamma_k\]</span></p>
<pre class="r"><code>standard.coordinates.columns.3 &lt;- sweep(principal.coordinates.columns, 2, SVD$d, &quot;/&quot;)
standard.coordinates.columns.3</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
<pre class="r"><code>standard.coordinates.columns</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
</div>
</div>
</div>
<div id="results-numerical-values-of-the-analysis"
class="section level1">
<h1>6. Results: Numerical values of the analysis</h1>
<p>After we have calculated the coordinates, which corresponds to the
information in columns k=1 and k=2 in the summary object, we will now go
for the calculation of values indicating inertia weights related to
axes, quality, correlation and contribution.</p>
<pre class="r"><code>summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
<div id="further-inertia-weights" class="section level2">
<h2>6.1 Further inertia weights</h2>
<p>To obtain absolute inertia weights of the rows related to the axes
with marginal sums, we multiply the row mass with the squared principal
coordinates of the rows.</p>
<pre class="r"><code>abs.in.rows.ax &lt;- sweep(principal.coordinates.rows^2, 1, row.masses, &#39;*&#39;)
abs.in.rows.ax_total &lt;- rbind(abs.in.rows.ax, (colSums(abs.in.rows.ax)))
rownames(abs.in.rows.ax_total) [7] &lt;- &quot;total&quot;
abs.in.rows.ax_total &lt;- cbind(abs.in.rows.ax_total, (rowSums(abs.in.rows.ax_total)))
colnames(abs.in.rows.ax_total) &lt;- c(&quot;[,1]&quot;,&quot;[,2]&quot;,&quot;[,3]&quot;,&quot;[,4]&quot;,&quot;[,5]&quot;,&quot;[,6]&quot;,&quot;total&quot;)

abs.in.rows.ax</code></pre>
<pre><code>##                       [,1]         [,2]         [,3]         [,4]         [,5]
## and that       0.204276598 0.0001066623 1.725627e-03 0.0001133394 5.482883e-06
## and all that   0.018003269 0.0103037774 4.667442e-03 0.0088222838 1.651355e-06
## and stuff      0.048760284 0.0310581247 3.905928e-03 0.0002346320 5.569216e-06
## and things     0.062182806 0.0009302323 1.424251e-02 0.0024336853 1.801176e-08
## and everything 0.002865072 0.0069659455 8.189608e-08 0.0007940964 2.840585e-05
## or something   0.031155453 0.0411241141 1.300815e-03 0.0028369894 4.095905e-07
##                        [,6]
## and that       7.723242e-34
## and all that   1.230626e-34
## and stuff      7.298888e-34
## and things     3.564573e-34
## and everything 5.856085e-34
## or something   7.001840e-34</code></pre>
<pre class="r"><code>abs.in.rows.ax_total</code></pre>
<pre><code>##                       [,1]         [,2]         [,3]         [,4]         [,5]
## and that       0.204276598 0.0001066623 1.725627e-03 0.0001133394 5.482883e-06
## and all that   0.018003269 0.0103037774 4.667442e-03 0.0088222838 1.651355e-06
## and stuff      0.048760284 0.0310581247 3.905928e-03 0.0002346320 5.569216e-06
## and things     0.062182806 0.0009302323 1.424251e-02 0.0024336853 1.801176e-08
## and everything 0.002865072 0.0069659455 8.189608e-08 0.0007940964 2.840585e-05
## or something   0.031155453 0.0411241141 1.300815e-03 0.0028369894 4.095905e-07
## total          0.367243481 0.0904888563 2.584241e-02 0.0152350263 4.153691e-05
##                        [,6]      total
## and that       7.723242e-34 0.20622771
## and all that   1.230626e-34 0.04179842
## and stuff      7.298888e-34 0.08396454
## and things     3.564573e-34 0.07978926
## and everything 5.856085e-34 0.01065360
## or something   7.001840e-34 0.07641778
## total          3.267525e-33 0.49885131</code></pre>
<p>The inertia weights of the axes are to be reconstructed from the
column sums of the absolute inertia weights. The column sum of the first
axis thus corresponds to the first eigenvalue.</p>
<pre class="r"><code>abs.in.rows.ax_total[7,1]</code></pre>
<pre><code>## [1] 0.3672435</code></pre>
<pre class="r"><code>eigenvalues[1]</code></pre>
<pre><code>## [1] 0.3672435</code></pre>
<p>Display for next step in calculation:</p>
<pre class="r"><code>principal.coordinates.columns</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
<pre class="r"><code>column.masses</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##        0.2194805        0.1363636        0.1857143        0.1142857 
##          Hull_MC          Hull_WC 
##        0.1792208        0.1649351</code></pre>
<p>Absolute inertia weights of the columns on the axes can be obtained
by multiplication of the column mass with the squared principal
coordinates of the columns.</p>
<pre class="r"><code>abs.in.cols.ax &lt;- sweep(principal.coordinates.columns^2, 1, column.masses, &#39;*&#39;)
abs.in.cols.ax_total &lt;- rbind(abs.in.cols.ax, (colSums(abs.in.cols.ax)))
rownames(abs.in.cols.ax_total) [7] &lt;- &quot;total&quot;
abs.in.cols.ax_total &lt;- cbind(abs.in.cols.ax_total, (rowSums(abs.in.cols.ax_total)))
colnames(abs.in.cols.ax_total) &lt;- c(&quot;[,1]&quot;,&quot;[,2]&quot;,&quot;[,3]&quot;,&quot;[,4]&quot;,&quot;[,5]&quot;,&quot;[,6]&quot;,&quot;total&quot;)

abs.in.cols.ax_total</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]         [,4]         [,5]
## Reading_MC       0.07356770 0.030464083 3.709619e-06 0.0017972966 5.209533e-06
## Reading_WC       0.07384786 0.012733081 4.611977e-03 0.0052009433 8.261677e-08
## Milton_Keynes_MC 0.05314357 0.001516867 6.830124e-03 0.0038480144 5.646423e-06
## Milton_Keynes_WC 0.05539491 0.001661463 7.138197e-05 0.0039514851 1.887366e-05
## Hull_MC          0.02793352 0.031990419 9.743033e-03 0.0002053795 2.865178e-08
## Hull_WC          0.08335592 0.012122944 4.582184e-03 0.0002319074 1.169602e-05
## total            0.36724348 0.090488856 2.584241e-02 0.0152350263 4.153691e-05
##                          [,6]      total
## Reading_MC       7.171582e-34 0.10583800
## Reading_WC       4.455717e-34 0.09639394
## Milton_Keynes_MC 6.068262e-34 0.06534422
## Milton_Keynes_WC 3.734315e-34 0.06109811
## Hull_MC          5.856085e-34 0.06987238
## Hull_WC          5.389295e-34 0.10030465
## total            3.267525e-33 0.49885131</code></pre>
<p>Since the absolute inertia weights of variable expression are
difficult to interpret, the relative inertia weights of variable
expression are reported.</p>
<div
id="contribution-of-the-rows-related-to-the-axes-ctr-value-of-the-summary"
class="section level3">
<h3>6.1.1 Contribution of the rows related to the axes
(<code>ctr</code>-value of the summary)</h3>
<p>Relative inertia weights of the rows related to the columns can be
obtained by dividing the absolute inertia weights by the column sums of
absolute inertia weights.</p>
<pre class="r"><code>rel.in.rows.ax &lt;- sweep(abs.in.rows.ax, 2, colSums(abs.in.rows.ax), &#39;/&#39;)
rel.in.rows.ax</code></pre>
<pre><code>##                       [,1]        [,2]         [,3]        [,4]         [,5]
## and that       0.556242953 0.001178734 6.677502e-02 0.007439395 0.1320002597
## and all that   0.049022705 0.113867915 1.806117e-01 0.579079001 0.0397563250
## and stuff      0.132773723 0.343225961 1.511441e-01 0.015400828 0.1340787330
## and things     0.169323102 0.010280076 5.511295e-01 0.159742770 0.0004336326
## and everything 0.007801559 0.076981253 3.169058e-06 0.052123071 0.6838701689
## or something   0.084835958 0.454466061 5.033645e-02 0.186214934 0.0098608809
##                      [,6]
## and that       0.23636364
## and all that   0.03766234
## and stuff      0.22337662
## and things     0.10909091
## and everything 0.17922078
## or something   0.21428571</code></pre>
<p>The value of relative inertia weights indicates that in the row
representation the first row ‘<em>and that</em>’ helps in explaining the
geometrical alignment of the first axis by 55.6%. (Explanation of how
much of the variation of the individual axes can be explained with the
help of the variable values) The relative inertia weight related to the
axes is listed in the ca summary as <code>ctr</code> for
contribution.</p>
<p>Variation on the first axis is highly determined by ‘<em>and
that</em>’, ‘<em>and stuff</em>’, ‘<em>and things</em>’ , and variation
on the second is highly determined by ‘<em>and stuff</em>’, and ‘<em>or
something</em>’.</p>
<p>We continue by calculating relative inertia weights of the columns
with respect to the axes.</p>
<pre class="r"><code>rel.in.cols.ax &lt;- sweep(abs.in.cols.ax, 2, colSums(abs.in.cols.ax), &#39;/&#39;)
rel.in.cols.ax</code></pre>
<pre><code>##                        [,1]       [,2]         [,3]       [,4]         [,5]
## Reading_MC       0.20032406 0.33666116 0.0001435477 0.11797135 0.1254193740
## Reading_WC       0.20108691 0.14071435 0.1784654445 0.34138066 0.0019889964
## Milton_Keynes_MC 0.14470937 0.01676303 0.2642990310 0.25257681 0.1359374695
## Milton_Keynes_WC 0.15083974 0.01836096 0.0027622026 0.25936845 0.4543829339
## Hull_MC          0.07606267 0.35352882 0.3770171939 0.01348074 0.0006897909
## Hull_WC          0.22697725 0.13397168 0.1773125802 0.01522199 0.2815814353
##                       [,6]
## Reading_MC       0.2194805
## Reading_WC       0.1363636
## Milton_Keynes_MC 0.1857143
## Milton_Keynes_WC 0.1142857
## Hull_MC          0.1792208
## Hull_WC          0.1649351</code></pre>
<p>From the point of view of the categories of the columns,
‘<em>Reading_MC</em>’, ‘<em>Reading_WC</em>’ and ‘<em>Hull_WC</em>’
determine the first axis and ‘<em>Reading_MC</em>’ and
‘<em>Hull_MC</em>’ determine the second.</p>
</div>
<div id="inertia-of-the-rows-and-columns-inr--value-of-the-summary"
class="section level3">
<h3>6.1.2 Inertia of the rows and columns: <code>inr</code>- value of
the summary</h3>
<p>In this step, we come back to the absolute inertia weights from table
<code>abs.in.rows.ax_total</code>: From the sums of the rows, it is
possible to indicate what proportion of the geometric alignment of all
axes each variable value has. This information can be absolute and
relative:</p>
<p>The absolute values can already be found in the table in the row
totals:</p>
<pre class="r"><code>abs.in.rows.ax_total[1:6,7]</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.20622771     0.04179842     0.08396454     0.07978926     0.01065360 
##   or something 
##     0.07641778</code></pre>
<p>To obtain the relative inertia weight, the absolute values of the row
totals are divided by the total sum or the total inertia weight:</p>
<pre class="r"><code># total sum
abs.in.rows.ax_total[7,7]</code></pre>
<pre><code>## [1] 0.4988513</code></pre>
<pre class="r"><code># total inertia weight
total.inertia</code></pre>
<pre><code>## [1] 0.4988513</code></pre>
<pre class="r"><code>abs.in.rows &lt;- abs.in.rows.ax_total[1:6,7]
# calculate relative inertia weight
rel.in.rows &lt;- abs.in.rows/abs.in.rows.ax_total[7,7]</code></pre>
<pre class="r"><code>abs.in.rows</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.20622771     0.04179842     0.08396454     0.07978926     0.01065360 
##   or something 
##     0.07641778</code></pre>
<pre class="r"><code>rel.in.rows</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.41340517     0.08378934     0.16831576     0.15994597     0.02135627 
##   or something 
##     0.15318749</code></pre>
<p>From the table with the relative values it follows that by means of
the first row ‘<em>and that</em>’ 41.3% of the geometric alignment of
the whole model can be explained.</p>
<p>The relative inertia weights for a row or column are listed as
<code>inr</code> in the summary of the correspondence analysis. Thus,
they show how high the proportion of a category is for explaining the
total variation.</p>
<p>You can verify the calculation by looking at the ca object.</p>
<pre class="r"><code>ca_validation$rowinertia</code></pre>
<pre><code>## [1] 0.20622771 0.04179842 0.08396454 0.07978926 0.01065360 0.07641778</code></pre>
<pre class="r"><code>abs.in.rows</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.20622771     0.04179842     0.08396454     0.07978926     0.01065360 
##   or something 
##     0.07641778</code></pre>
<p>We determine analogously the relative inertia weight of the
columns</p>
<pre class="r"><code>abs.in.cols &lt;- abs.in.cols.ax_total[1:6,7]
rel.in.cols &lt;- abs.in.cols/abs.in.cols.ax_total[7,7]</code></pre>
<p>Validation by means of <code>$colinertia</code></p>
<pre class="r"><code>abs.in.cols</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##       0.10583800       0.09639394       0.06534422       0.06109811 
##          Hull_MC          Hull_WC 
##       0.06987238       0.10030465</code></pre>
<pre class="r"><code>ca_validation$colinertia</code></pre>
<pre><code>## [1] 0.10583800 0.09639394 0.06534422 0.06109811 0.06987238 0.10030465</code></pre>
<pre class="r"><code>rel.in.cols</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##        0.2121634        0.1932318        0.1309894        0.1224776 
##          Hull_MC          Hull_WC 
##        0.1400665        0.2010712</code></pre>
</div>
</div>
<div
id="values-of-correlations-with-the-axes-cor-and-quality-qlt-value-of-the-summary"
class="section level2">
<h2>6.2 Values of correlations with the axes (<code>cor</code>) and
quality (<code>qlt</code> value of the summary)</h2>
<p>If we relate the inertia weights of the rows on the axes to the sum
of the inertia weights of the rows (divide by them), we can indicate how
much the variable expressions are determined by the individual axes. For
example, 99% of the variation of ‘<em>and that</em>’ is explained by the
first axis. The value for the correlation between a principal axis and a
particular row or column is listed in the ca summary as
<code>cor</code>.</p>
<pre class="r"><code>sqrt.fl &lt;- abs.in.rows.ax/abs.in.rows.ax_total[1:6,7]
sqrt.fl</code></pre>
<pre><code>##                     [,1]         [,2]         [,3]         [,4]         [,5]
## and that       0.9905390 0.0005172065 8.367583e-03 0.0005495836 2.658655e-05
## and all that   0.4307165 0.2465111508 1.116655e-01 0.2110673842 3.950759e-05
## and stuff      0.5807247 0.3698957352 4.651879e-02 0.0027944181 6.632820e-05
## and things     0.7793381 0.0116586164 1.785017e-01 0.0305014165 2.257416e-07
## and everything 0.2689299 0.6538582814 7.687174e-06 0.0745378328 2.666315e-03
## or something   0.4076990 0.5381484992 1.702241e-02 0.0371247292 5.359885e-06
##                        [,6]
## and that       3.745007e-33
## and all that   2.944194e-33
## and stuff      8.692822e-33
## and things     4.467485e-33
## and everything 5.496812e-32
## or something   9.162580e-33</code></pre>
<p>Hence, in correspondence analysis it is also possible to calculate
the quality of the individual points. The farther a point is from the
origin, the better the point is explained by the correspondence
analysis.</p>
<p>Alternatively, we can square the principal coordinates and express
them as row proportions, and we get the measures of quality from each
dimension for each point. These are also called squared correlations (or
<em>squared cosines</em>).</p>
<pre class="r"><code>sqrt.cor.row = prop.table(principal.coordinates.rows ^2, 1)
sqrt.cor.row</code></pre>
<pre><code>##                     [,1]         [,2]         [,3]         [,4]         [,5]
## and that       0.9905390 0.0005172065 8.367583e-03 0.0005495836 2.658655e-05
## and all that   0.4307165 0.2465111508 1.116655e-01 0.2110673842 3.950759e-05
## and stuff      0.5807247 0.3698957352 4.651879e-02 0.0027944181 6.632820e-05
## and things     0.7793381 0.0116586164 1.785017e-01 0.0305014165 2.257416e-07
## and everything 0.2689299 0.6538582814 7.687174e-06 0.0745378328 2.666315e-03
## or something   0.4076990 0.5381484992 1.702241e-02 0.0371247292 5.359885e-06
##                        [,6]
## and that       3.745007e-33
## and all that   2.944194e-33
## and stuff      8.692822e-33
## and things     4.467485e-33
## and everything 5.496812e-32
## or something   9.162580e-33</code></pre>
<pre class="r"><code>sqrt.cor.col = prop.table(principal.coordinates.columns ^2, 1)
sqrt.cor.col</code></pre>
<pre><code>##                       [,1]       [,2]         [,3]        [,4]         [,5]
## Reading_MC       0.6950972 0.28783691 3.504997e-05 0.016981581 4.922177e-05
## Reading_WC       0.7661048 0.13209420 4.784509e-02 0.053955086 8.570743e-07
## Milton_Keynes_MC 0.8132865 0.02321349 1.045253e-01 0.058888363 8.641043e-05
## Milton_Keynes_WC 0.9066550 0.02719336 1.168317e-03 0.064674421 3.089075e-04
## Hull_MC          0.3997791 0.45784069 1.394404e-01 0.002939351 4.100588e-07
## Hull_WC          0.8310275 0.12086124 4.568267e-02 0.002312030 1.166050e-04
##                          [,6]
## Reading_MC       6.775999e-33
## Reading_WC       4.622403e-33
## Milton_Keynes_MC 9.286607e-33
## Milton_Keynes_WC 6.111997e-33
## Hull_MC          8.381115e-33
## Hull_WC          5.372927e-33</code></pre>
<pre class="r"><code>sum.sqrt.cor.row &lt;- apply(sqrt.cor.row, 1 ,sum )
sum.sqrt.cor.row</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##              1              1              1              1              1 
##   or something 
##              1</code></pre>
<pre class="r"><code>sum.sqrt.cor.col &lt;-  apply(sqrt.cor.col, 1 ,sum )
sum.sqrt.cor.col</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##                1                1                1                1 
##          Hull_MC          Hull_WC 
##                1                1</code></pre>
<p>The quality of the map for a given category is usually defined as the
sum of the scores it receives for two dimensions.</p>
<p>In the ca summary the values are listed under <code>qlt</code>. They
represent the quality of visualization or mapping quality, If the
quality is low (below 50%), the categories must be interpreted with
caution. In the example they add up to 100%.</p>
</div>
</div>
<div id="validation-by-ca-package" class="section level1">
<h1>7.0 Validation by <code>ca</code> package</h1>
<p>In this section we are now directly cross-checking our calculations
to make sure we did them correctly.</p>
<div id="validation-of-row-and-column-masses" class="section level2">
<h2>7.1 Validation of row and column masses</h2>
<pre class="r"><code>ca_validation$rowmass</code></pre>
<pre><code>## [1] 0.23636364 0.03766234 0.22337662 0.10909091 0.17922078 0.21428571</code></pre>
<pre class="r"><code>row.masses</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##     0.23636364     0.03766234     0.22337662     0.10909091     0.17922078 
##   or something 
##     0.21428571</code></pre>
<pre class="r"><code>ca_validation$colmass</code></pre>
<pre><code>## [1] 0.2194805 0.1363636 0.1857143 0.1142857 0.1792208 0.1649351</code></pre>
<pre class="r"><code>column.masses</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##        0.2194805        0.1363636        0.1857143        0.1142857 
##          Hull_MC          Hull_WC 
##        0.1792208        0.1649351</code></pre>
</div>
<div id="validation-of-chi-squared-distances" class="section level2">
<h2>7.2 Validation of chi-squared distances</h2>
<p>We cross-check the row and column distances against the average row
and column profile.</p>
<pre class="r"><code>ca_validation$rowdist</code></pre>
<pre><code>## [1] 0.9340781 1.0534800 0.6130969 0.8552202 0.2438114 0.5971736</code></pre>
<pre class="r"><code>dist.matrix.row</code></pre>
<pre><code>##                      and that and all that and stuff and things and everything
## and all that        0.8946881                                                 
## and stuff           1.4578076    1.5483608                                    
## and things          1.7194114    1.7024741 0.7460265                          
## and everything      0.8281350    1.1244819 0.6408689  1.0190857               
## or something        1.4017662    1.2617283 0.8305088  0.7225154      0.8184297
## average row profile 0.9340781    1.0534800 0.6130969  0.8552202      0.2438114
##                     or something
## and all that                    
## and stuff                       
## and things                      
## and everything                  
## or something                    
## average row profile    0.5971736</code></pre>
<pre class="r"><code>ca_validation$coldist</code></pre>
<pre><code>## [1] 0.6944210 0.8407669 0.5931724 0.7311693 0.6243938 0.7798374</code></pre>
<pre class="r"><code>dist.matrix.col</code></pre>
<pre><code>##                        Reading_MC Reading_WC Milton_Keynes_MC Milton_Keynes_WC
## Reading_WC              1.3602863                                             
## Milton_Keynes_MC        0.5536544  1.3840590                                  
## Milton_Keynes_WC        1.3036111  0.4743091        1.3026568                 
## Hull_MC                 0.8517939  1.3650940        0.5849334        1.2550407
## Hull_WC                 1.4516556  0.7143889        1.2722161        0.4429410
## average column profile  0.6944210  0.8407669        0.5931724        0.7311693
##                          Hull_MC   Hull_WC
## Reading_WC                                
## Milton_Keynes_MC                          
## Milton_Keynes_WC                          
## Hull_MC                                   
## Hull_WC                1.1855142          
## average column profile 0.6243938 0.7798374</code></pre>
</div>
<div id="validation-of-standard-coordinates-of-row-and-columns"
class="section level2">
<h2>7.3 Validation of standard coordinates of row and columns</h2>
<p>We cross-check the variables <em>rowcoord</em> and <em>colcoord</em>
of the ca object against the values we calculated.</p>
<pre class="r"><code>ca_validation$rowcoord</code></pre>
<pre><code>##                      Dim1        Dim2         Dim3       Dim4        Dim5
## and that       -1.5340585  0.07061836  0.531516423  0.1774102  0.74730358
## and all that   -1.1408932 -1.73878965 -2.189874992 -3.9211664 -1.02742346
## and stuff       0.7709695  1.23957042 -0.822577420 -0.2625749  0.77474911
## and things      1.2458445 -0.30697562  2.247670017 -1.2100862 -0.06304732
## and everything -0.2086395  0.65538773 -0.004205047  0.5392881 -1.95340659
## or something    0.6292068 -1.45631096 -0.484668381  0.9322033  0.21451677</code></pre>
<pre class="r"><code>standard.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]         [,3]       [,4]        [,5] [,6]
## and that       -1.5340585  0.07061836  0.531516423  0.1774102  0.74730358    1
## and all that   -1.1408932 -1.73878965 -2.189874992 -3.9211664 -1.02742346    1
## and stuff       0.7709695  1.23957042 -0.822577420 -0.2625749  0.77474911    1
## and things      1.2458445 -0.30697562  2.247670017 -1.2100862 -0.06304732    1
## and everything -0.2086395  0.65538773 -0.004205047  0.5392881 -1.95340659    1
## or something    0.6292068 -1.45631096 -0.484668381  0.9322033  0.21451677    1</code></pre>
<pre class="r"><code>ca_validation$colcoord</code></pre>
<pre><code>##                        Dim1       Dim2        Dim3       Dim4        Dim5
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860</code></pre>
<pre class="r"><code>standard.coordinates.columns</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
<p>We could also compare against the printed ca object but I prefer the
above method for readability.</p>
</div>
<div id="validation-of-principal-coordinates" class="section level2">
<h2>7.4 Validation of principal coordinates</h2>
<p>The principal coordinates resulting from the ca-package appear when
calling the summary of the ca object in the columns for individual
dimensions (k=1, k=2). Note when printing the ca object itself it will
show the standard coordinates instead.</p>
<pre class="r"><code>summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
<pre class="r"><code>round(principal.coordinates.rows*1000)</code></pre>
<pre><code>##                [,1] [,2] [,3] [,4] [,5] [,6]
## and that       -930   21   85   22    5    0
## and all that   -691 -523 -352 -484   -7    0
## and stuff       467  373 -132  -32    5    0
## and things      755  -92  361 -149    0    0
## and everything -126  197   -1   67  -13    0
## or something    381 -438  -78  115    1    0</code></pre>
<pre class="r"><code>round(principal.coordinates.columns*1000)</code></pre>
<pre><code>##                  [,1] [,2] [,3] [,4] [,5] [,6]
## Reading_MC        579 -373    4   90   -5    0
## Reading_WC       -736 -306 -184 -195   -1    0
## Milton_Keynes_MC  535   90  192 -144    6    0
## Milton_Keynes_WC -696 -121   25  186   13    0
## Hull_MC           395  422 -233   34    0    0
## Hull_WC          -711  271  167   37   -8    0</code></pre>
</div>
<div id="validation-of-inertia-values-inertia-weights"
class="section level2">
<h2>7.5 Validation of inertia-values (inertia weights)</h2>
<p>First, let’s compare the <code>inr</code> values of relative inertia
weights.</p>
<pre class="r"><code>summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
<pre class="r"><code>print(&quot;inr rows&quot;)</code></pre>
<pre><code>## [1] &quot;inr rows&quot;</code></pre>
<pre class="r"><code>round(rel.in.rows*1000)</code></pre>
<pre><code>##       and that   and all that      and stuff     and things and everything 
##            413             84            168            160             21 
##   or something 
##            153</code></pre>
<pre class="r"><code>print(&quot;inr cols&quot;)</code></pre>
<pre><code>## [1] &quot;inr cols&quot;</code></pre>
<pre class="r"><code>round(rel.in.cols*1000)</code></pre>
<pre><code>##       Reading_MC       Reading_WC Milton_Keynes_MC Milton_Keynes_WC 
##              212              193              131              122 
##          Hull_MC          Hull_WC 
##              140              201</code></pre>
<p>Second, <code>ctr</code> are the relative inertia weights related to
axes that we now compare.</p>
<pre class="r"><code>summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
<pre class="r"><code>print(&quot;ctr rows&quot;)</code></pre>
<pre><code>## [1] &quot;ctr rows&quot;</code></pre>
<pre class="r"><code>round(rel.in.rows.ax*1000)</code></pre>
<pre><code>##                [,1] [,2] [,3] [,4] [,5] [,6]
## and that        556    1   67    7  132  236
## and all that     49  114  181  579   40   38
## and stuff       133  343  151   15  134  223
## and things      169   10  551  160    0  109
## and everything    8   77    0   52  684  179
## or something     85  454   50  186   10  214</code></pre>
<pre class="r"><code>print(&quot;ctr cols&quot;)</code></pre>
<pre><code>## [1] &quot;ctr cols&quot;</code></pre>
<pre class="r"><code>round(rel.in.cols.ax*1000)</code></pre>
<pre><code>##                  [,1] [,2] [,3] [,4] [,5] [,6]
## Reading_MC        200  337    0  118  125  219
## Reading_WC        201  141  178  341    2  136
## Milton_Keynes_MC  145   17  264  253  136  186
## Milton_Keynes_WC  151   18    3  259  454  114
## Hull_MC            76  354  377   13    1  179
## Hull_WC           227  134  177   15  282  165</code></pre>
</div>
<div id="validation-of-cor-and-qlt-values" class="section level2">
<h2>7.6 Validation of <code>cor</code> and <code>qlt</code> values</h2>
<p>The <code>cor</code> value appears in the column after the coordinate
value in the dimensions.</p>
<pre class="r"><code>summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
<pre class="r"><code>print(&quot;cor rows&quot;)</code></pre>
<pre><code>## [1] &quot;cor rows&quot;</code></pre>
<pre class="r"><code>round(sqrt.cor.row*1000)</code></pre>
<pre><code>##                [,1] [,2] [,3] [,4] [,5] [,6]
## and that        991    1    8    1    0    0
## and all that    431  247  112  211    0    0
## and stuff       581  370   47    3    0    0
## and things      779   12  179   31    0    0
## and everything  269  654    0   75    3    0
## or something    408  538   17   37    0    0</code></pre>
<pre class="r"><code>print(&quot;cor cols&quot;)</code></pre>
<pre><code>## [1] &quot;cor cols&quot;</code></pre>
<pre class="r"><code>round(sqrt.cor.col*1000)</code></pre>
<pre><code>##                  [,1] [,2] [,3] [,4] [,5] [,6]
## Reading_MC        695  288    0   17    0    0
## Reading_WC        766  132   48   54    0    0
## Milton_Keynes_MC  813   23  105   59    0    0
## Milton_Keynes_WC  907   27    1   65    0    0
## Hull_MC           400  458  139    3    0    0
## Hull_WC           831  121   46    2    0    0</code></pre>
<p>The <code>qlt</code> values are in the column after the masses of the
summary. We are to compare them now.</p>
<pre class="r"><code>summary(ca_validation)</code></pre>
<pre><code>## 
## Principal inertias (eigenvalues):
## 
##  dim    value      %   cum%   scree plot               
##  1      0.367243  73.6  73.6  ******************       
##  2      0.090489  18.1  91.8  *****                    
##  3      0.025842   5.2  96.9  *                        
##  4      0.015235   3.1 100.0  *                        
##  5      4.2e-050   0.0 100.0                           
##         -------- -----                                 
##  Total: 0.498851 100.0                                 
## 
## 
## Rows:
##       name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 | andtht |  236  991  413 | -930 991 556 |   21   1   1 |
## 2 |   andl |   38  677   84 | -691 431  49 | -523 247 114 |
## 3 |   ands |  223  951  168 |  467 581 133 |  373 370 343 |
## 4 | andthn |  109  791  160 |  755 779 169 |  -92  12  10 |
## 5 |   andv |  179  923   21 | -126 269   8 |  197 654  77 |
## 6 |   orsm |  214  946  153 |  381 408  85 | -438 538 454 |
## 
## Columns:
##      name   mass  qlt  inr    k=1 cor ctr    k=2 cor ctr  
## 1 |  R_MC |  219  983  212 |  579 695 200 | -373 288 337 |
## 2 |  R_WC |  136  898  193 | -736 766 201 | -306 132 141 |
## 3 | M_K_M |  186  836  131 |  535 813 145 |   90  23  17 |
## 4 | M_K_W |  114  934  122 | -696 907 151 | -121  27  18 |
## 5 |  H_MC |  179  858  140 |  395 400  76 |  422 458 354 |
## 6 |  H_WC |  165  952  201 | -711 831 227 |  271 121 134 |</code></pre>
<pre class="r"><code>(&quot;qlt rows&quot;)</code></pre>
<pre><code>## [1] &quot;qlt rows&quot;</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.row[1],sqrt.cor.row[7])*1000)</code></pre>
<pre><code>## [1] 991</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.row[2],sqrt.cor.row[8])*1000)</code></pre>
<pre><code>## [1] 677</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.row[3],sqrt.cor.row[9])*1000)</code></pre>
<pre><code>## [1] 951</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.row[4],sqrt.cor.row[10])*1000)</code></pre>
<pre><code>## [1] 791</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.row[5],sqrt.cor.row[11])*1000)</code></pre>
<pre><code>## [1] 923</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.row[6],sqrt.cor.row[12])*1000)</code></pre>
<pre><code>## [1] 946</code></pre>
<pre class="r"><code>print(&quot;qlt cols&quot;)</code></pre>
<pre><code>## [1] &quot;qlt cols&quot;</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.col[1],sqrt.cor.col[7])*1000)</code></pre>
<pre><code>## [1] 983</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.col[2],sqrt.cor.col[8])*1000)</code></pre>
<pre><code>## [1] 898</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.col[3],sqrt.cor.col[9])*1000)</code></pre>
<pre><code>## [1] 836</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.col[4],sqrt.cor.col[10])*1000)</code></pre>
<pre><code>## [1] 934</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.col[5],sqrt.cor.col[11])*1000)</code></pre>
<pre><code>## [1] 858</code></pre>
<pre class="r"><code>round(sum(sqrt.cor.col[6],sqrt.cor.col[12])*1000)</code></pre>
<pre><code>## [1] 952</code></pre>
<p>In sum, we have made sure now that our calculations were done in the
correct way.</p>
</div>
</div>
<div id="different-visualisations" class="section level1">
<h1>8. Different Visualisations</h1>
<div id="method-symmetric-map" class="section level2">
<h2>8.1 Method: Symmetric map:</h2>
<p>(Default:) The row and column points are scaled so that their inertia
(weighted variance) is equal to the principal inertia (eigenvalue or
singular value) along the principal axes, i.e. rows and columns are
given in principal coordinates.</p>
<pre class="r"><code>plot(ca_validation, dim = c(1,2), map = &quot;symmetric&quot;, what = c(&quot;all&quot;, &quot;all&quot;), 
               mass = c(FALSE, FALSE), contrib = c(&quot;none&quot;, &quot;none&quot;), 
               col = c(&quot;blue&quot;, &quot;red&quot;), 
               pch = c(16, 21, 17, 24), 
               labels = c(2, 2), 
               arrows = c(FALSE, FALSE), 
               lines = c(FALSE, FALSE), 
               lwd=1,
               xlab = &quot;_auto_&quot;, ylab = &quot;_auto_&quot;, 
               xlim = c(-2.0, 2.0),
               ylim = c(-1.0, 1.0),
               col.lab = c(&quot;blue&quot;, &quot;red&quot;)) </code></pre>
<p><img src="MathCA22complete_files/figure-html/unnamed-chunk-98-1.png" width="672" /></p>
<pre class="r"><code>principal.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]          [,3]        [,4]          [,5]
## and that       -0.9296489  0.02124297  0.0854443178  0.02189778  0.0048163070
## and all that   -0.6913883 -0.52305167 -0.3520349827 -0.48399054 -0.0066216555
## and stuff       0.4672123  0.37287971 -0.1322340448 -0.03240968  0.0049931911
## and things      0.7549894 -0.09234246  0.3613258648 -0.14936125 -0.0004063346
## and everything -0.1264368  0.19714958 -0.0006759855  0.06656446 -0.0125895368
## or something    0.3813032 -0.43807823 -0.0779132260  0.11506209  0.0013825420
##                        [,6]
## and that       5.716227e-17
## and all that   5.716227e-17
## and stuff      5.716227e-17
## and things     5.716227e-17
## and everything 5.716227e-17
## or something   5.716227e-17</code></pre>
<pre class="r"><code>principal.coordinates.columns</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
</div>
<div id="method-rowprincipal" class="section level2">
<h2>8.2 Method: “rowprincipal”</h2>
<p>Asymmetric representation: Common representation of rows and columns,
the two sets of points are scaled differently (normalized), with rows in
principal coordinates and columns in standard coordinates (biplots).</p>
<pre class="r"><code>plot(ca_validation, dim = c(1,2), map = &quot;rowprincipal&quot;, what = c(&quot;all&quot;, &quot;all&quot;), 
               mass = c(FALSE, FALSE), contrib = c(&quot;none&quot;, &quot;none&quot;), 
               col = c(&quot;blue&quot;, &quot;red&quot;), 
               pch = c(16, 21, 17, 24), 
               labels = c(2, 2), 
               arrows = c(FALSE, FALSE), 
               lines = c(FALSE, FALSE), 
               lwd=1,
               xlab = &quot;_auto_&quot;, ylab = &quot;_auto_&quot;,
               col.lab = c(&quot;blue&quot;, &quot;red&quot;)) </code></pre>
<p><img src="MathCA22complete_files/figure-html/unnamed-chunk-100-1.png" width="672" /></p>
<pre class="r"><code>principal.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]          [,3]        [,4]          [,5]
## and that       -0.9296489  0.02124297  0.0854443178  0.02189778  0.0048163070
## and all that   -0.6913883 -0.52305167 -0.3520349827 -0.48399054 -0.0066216555
## and stuff       0.4672123  0.37287971 -0.1322340448 -0.03240968  0.0049931911
## and things      0.7549894 -0.09234246  0.3613258648 -0.14936125 -0.0004063346
## and everything -0.1264368  0.19714958 -0.0006759855  0.06656446 -0.0125895368
## or something    0.3813032 -0.43807823 -0.0779132260  0.11506209  0.0013825420
##                        [,6]
## and that       5.716227e-17
## and all that   5.716227e-17
## and stuff      5.716227e-17
## and things     5.716227e-17
## and everything 5.716227e-17
## or something   5.716227e-17</code></pre>
<pre class="r"><code>standard.coordinates.columns</code></pre>
<pre><code>##                        [,1]       [,2]        [,3]       [,4]        [,5] [,6]
## Reading_MC        0.9553633 -1.2385071  0.02557409  0.7331457 -0.75593478   -1
## Reading_WC       -1.2143465 -1.0158274 -1.14400463 -1.5822320 -0.12077240   -1
## Milton_Keynes_MC  0.8827255  0.3004371  1.19295793 -1.1662028  0.85555303   -1
## Milton_Keynes_WC -1.1488462 -0.4008222  0.15546470  1.5064773  1.99395353   -1
## Hull_MC           0.6514658  1.4044886 -1.45039535  0.2742602  0.06203897   -1
## Hull_WC          -1.1730990  0.9012598  1.03684366  0.3037940 -1.30660860   -1</code></pre>
</div>
<div id="method-colprincipal" class="section level2">
<h2>8.3 Method: “colprincipal”</h2>
<p>asymmetric: with columns in principal coordinates and rows in
standard coordinates (biplot)</p>
<pre class="r"><code>plot(ca_validation, dim = c(1,2), map = &quot;colprincipal&quot;, what = c(&quot;all&quot;, &quot;all&quot;), 
               mass = c(FALSE, FALSE), contrib = c(&quot;none&quot;, &quot;none&quot;), 
               col = c(&quot;blue&quot;, &quot;red&quot;), 
               pch = c(16, 21, 17, 24), 
               labels = c(2, 2), 
               arrows = c(FALSE, FALSE), 
               lines = c(FALSE, FALSE), 
               lwd=1,
               xlab = &quot;_auto_&quot;, ylab = &quot;_auto_&quot;,
               col.lab = c(&quot;blue&quot;, &quot;red&quot;)) </code></pre>
<p><img src="MathCA22complete_files/figure-html/unnamed-chunk-102-1.png" width="672" /></p>
<pre class="r"><code>principal.coordinates.columns</code></pre>
<pre><code>##                        [,1]        [,2]         [,3]        [,4]          [,5]
## Reading_MC        0.5789561 -0.37255986  0.004111182  0.09049235 -0.0048719343
## Reading_WC       -0.7359015 -0.30557475 -0.183905315 -0.19529529 -0.0007783677
## Milton_Keynes_MC  0.5349371  0.09037559  0.191774839 -0.14394470  0.0055139654
## Milton_Keynes_WC -0.6962079 -0.12057279  0.024991843  0.18594487  0.0128508583
## Hull_MC           0.3947923  0.42248936 -0.233159382  0.03385200  0.0003998358
## Hull_WC          -0.7109052  0.27111126  0.166678574  0.03749737 -0.0084209795
##                           [,6]
## Reading_MC       -5.716227e-17
## Reading_WC       -5.716227e-17
## Milton_Keynes_MC -5.716227e-17
## Milton_Keynes_WC -5.716227e-17
## Hull_MC          -5.716227e-17
## Hull_WC          -5.716227e-17</code></pre>
<pre class="r"><code>standard.coordinates.rows</code></pre>
<pre><code>##                      [,1]        [,2]         [,3]       [,4]        [,5] [,6]
## and that       -1.5340585  0.07061836  0.531516423  0.1774102  0.74730358    1
## and all that   -1.1408932 -1.73878965 -2.189874992 -3.9211664 -1.02742346    1
## and stuff       0.7709695  1.23957042 -0.822577420 -0.2625749  0.77474911    1
## and things      1.2458445 -0.30697562  2.247670017 -1.2100862 -0.06304732    1
## and everything -0.2086395  0.65538773 -0.004205047  0.5392881 -1.95340659    1
## or something    0.6292068 -1.45631096 -0.484668381  0.9322033  0.21451677    1</code></pre>
<p>There are more visualization methods in the ca package, ‘symbiplot’,
‘rowgreen’ and ‘colgreen’, that are not discussed here.</p>
</div>
</div>
<div id="references" class="section level1">
<h1>References</h1>
<p>Blasius, J. (2001). <em>Korrespondenzanaylse</em>. De Gruyter.</p>
<p>Breitung, J. (2023). Dr. Strangelove or: How I Learned to Stop
Worrying and Love the Correspondence Analysis. URL <a
href="https://wisostat.uni-koeln.de/fileadmin/sites/statistik/Celibrate_Joerg.pdf"
class="uri">https://wisostat.uni-koeln.de/fileadmin/sites/statistik/Celibrate_Joerg.pdf</a></p>
<p>Cheshire, J. (2007). Discourse Variation, Grammaticalisation and
Stuff Like That. <em>Journal of Sociolinguistics 11 (2)</em>, 155–193.
<a href="doi:1.1111/j.1467-9841.2007.00317x"
class="uri">doi:1.1111/j.1467-9841.2007.00317x</a>. <a
href="http://dx.doi" class="uri">http://dx.doi</a>.
org/10.1111/j.1467-9841.2007.00317.x.</p>
<p>Desagulier, G. (2017). *Corpus Linguistics and Statistics with R.
Introduction to Quantitative Methods in Linguistics. Springer. <a
href="doi:10.1007/978-3-319-64572-8"
class="uri">doi:10.1007/978-3-319-64572-8</a>. Additional materials:</p>
<p>Greenacre, M. (2007). <em>Correspondence Analysis in Practice</em>.
Chapman &amp; Hall.</p>
<p>Hautz, P. &amp; Bleuel, F. (2018). Die Korrespondenzanalyse zur
Auswertung und Visualisierung inhaltsanalytischer Daten. In: Petersen,
Thomas &amp; Schwender, Clemens (Eds), <em>Die Entschlüsselung der
Bilder: Methoden zur Erforschung visueller Kommunikation.</em>
(pp. 197-222). Halem.</p>
<p>Wasserstein, R. L. &amp; Lazar, N. A. (2016) The ASA’s Statement on
p-Values: Context, Process, and Purpose, <em>The American Statistician,
70:2</em>, 129-133.</p>
</div>

<div id="rmd-source-code">LS0tDQp0aXRsZTogIk1hdGggb2YgQ29ycmVzcG9uZGVuY2UgQW5hbHlzaXMiDQphdXRob3I6ICJEci4gQ2xhdWRpYSBSb2NoIE0uQS4iDQpkYXRlOiAiMjAyMi0xMS0wOCINCm91dHB1dDoNCiAgaHRtbF9kb2N1bWVudDoNCiAgICBjb2RlX2Rvd25sb2FkOiB5ZXMNCiAgICBkZl9wcmludDogcGFnZWQNCiAgICBmaWdfY2FwdGlvbjogeWVzDQogICAgc2VsZl9jb250YWluZWQ6IEZhbHNlDQogICAgcGFuZG9jX2FyZ3M6IA0KICAgICAgLSAtLW1hdGhqYXg9aHR0cHM6Ly9jZG5qcy5jbG91ZGZsYXJlLmNvbS9hamF4L2xpYnMvbWF0aGpheC8zLjIuMi9lczUvbGF0ZXN0Lm1pbi5qcz9jb25maWc9VGVYLU1NTC1BTV9IVE1Mb3JNTUwuanMgIyBpbmNsdWRlIG1hdGhqYXgNCiAgICB0b2M6IHllcyAgICAjIGluZGV4DQogICAgdG9jX2RlcHRoOiA0DQplZGl0b3Jfb3B0aW9uczoNCiAgY2h1bmtfb3V0cHV0X3R5cGU6IGlubGluZQ0KLS0tDQoNCg0KDQpgYGB7ciBzZXR1cCwgaW5jbHVkZT1GQUxTRX0NCmtuaXRyOjpvcHRzX2NodW5rJHNldChlY2hvID0gVFJVRSkNCmBgYA0KDQojIE1hdGggb2YgQ29ycmVzcG9uZGVuY2UgQW5hbHlzaXMgLSBDYXNlIFN0dWR5ICJQcmFnbWF0aWMgRXh0ZW5kZXJzIHVzZWQgYnkgRW5nbGlzaCBUZWVuYWdlcnMiDQoNCiMgU291cmNlcyAmIFByZXBhcmF0aW9uDQoNClRoaXMgbm90ZWJvb2sgaGFzIGJlZW4gY3JlYXRlZCBmb3IgdGhlIFtFeHBsb3JhdG9yeSBEYXRhIEFuYWx5c2lzXShodHRwczovL3Z2ei5ydWhyLXVuaS1ib2NodW0uZGUvY2FtcHVzL2FsbC9ldmVudC5hc3A/b2JqZ2d1aWQ9TkVXJmZyb209dnZ6JmdndWlkPTB4RTJBQzJBQkRFNUMzNDc0QTkyMDA3RkVFNkQzRkVDQkEmbW9kZT1vd24mdGd1aWQ9MHhCRUM0RUJEM0UwOEU0NTFCQjZERUJENjlGMjMwMTUyRiZsYW5nPWVuKSBBZHZhbmNlZCBDb3Vyc2UgYXQgTGluZ3Vpc3RpYyBEYXRhIFNjaWVuY2UgTGFiLCBSdWhyIFVuaXZlcnNpdHkgQm9jaHVtLg0KDQpUaGUgcHJpbWFyeSBhaW0gb2YgdGhpcyBub3RlYm9vayBpcyB0byBmb2xsb3cgYWxvbmcgdGhlIG1hdGhlbWF0aWNhbCBmb3VuZGF0aW9ucyBvZiBjb3JyZXNwb25kZW5jZSBhbmFseXNpcy4gV2UgIm1hbnVhbGx5IiBjYWxjdWxhdGUgYWxsIGNvb3JkaW5hdGVzIGFuZCBzdW1tYXJ5IHN0YXRpc3RpY3MgYW5kIGNvbXBhcmUgdGhlIHZhbHVlcyB0byB0aGUgb3V0cHV0IG9mIHByZS1jb21waWxlZCBgY2FgLXBhY2thZ2VzLg0KDQpUaGUgc2Vjb25kYXJ5IGFpbSBpcyB0byBleHBsb3JlIGEgY2FzZSBzdHVkeSB0aGF0IGRlYWxzIHdpdGggYSBsaW5ndWlzdGljIHBoZW5vbWVub24gLSB0aGUgbG9jYWwgZGlhbGVjdCBpbiBkaWZmZXJlbnQgc29jaWFsIGNsYXNzZXMgb2YgRW5nbGlzaCB0ZWVuYWdlcnMgZnJvbSB0aHJlZSBsb2NhbCBjaXRpZXMuDQoNCioqU291cmNlczoqKg0KDQpUaGUgbm90ZWJvb2sgaXMgYmFzZWQgb24gdGhlIGZvbGxvd2luZyBzb3VyY2VzOg0KDQotIERlc2FndWxpZXIgKDIwMTcpLCBjaGFwdGVyIDEwLCBzZWUgYWxzbyBbYWRkaXRpb25hbCBtYXRlcmlhbHNdKGh0dHA6Ly9leHRyYXMuc3ByaW5nZXIuY29tLzIwMTcvOTc4LTMtMzE5LTY0NTcwLTQpLg0KDQotIFRoZSBwYXJ0IG9uIHRoZSBtYXRoZW1hdGljYWwgZm91bmRhdGlvbiBvZiBDQSByZWxpZXMgb24gYSBbc2NyaXB0IGJ5IFRpbSBCb2NrXSg8aHR0cHM6Ly93d3cuZGlzcGxheXIuY29tL21hdGgtY29ycmVzcG9uZGVuY2UtYW5hbHlzaXMvPikuDQoNCg0KDQoqKlJlcXVpcmVkIFIgcGFja2FnZXM6KiogYGNhYCwgYGRhdGEudGFibGVgDQpgYGB7cn0NCmxpYnJhcnkoImNhIik7IGxpYnJhcnkoImRhdGEudGFibGUiKQ0KYGBgDQoNCg0KDQojIDAuIENhc2UgU3R1ZHkgLSBQcmFnbWF0aWMgRXh0ZW5kZXJzIHVzZWQgYnkgRW5nbGlzaCBUZWVuYWdlcnMNCg0KDQpXZSB1c2UgdGhlIGBleHRlbmRlcnNgIGRhdGFzZXQgZm9sbG93aW5nIGEgY2FzZSBzdHVkeSBhcyBwcmVzZW50ZWQgaW4gY2guIDEwIG9mIERlc2FndWxpZXIgKDIwMTcpLiBUaGUgb3JpZ2luYWwgZGF0YXNldCB3YXMgcmVjb3JkZWQgYnkgQ2hlc2hpcmUgKDIwMDcpIGFuZCBjb250YWlucyBmcmVxdWVuY2llcyBmb3IgcHJhZ21hdGljIGV4dGVuZGVycyAoKmFuZCB0aGF0KiwgKmFuZCBhbGwgdGhhdCosICphbmQgc3R1ZmYqLCAqYW5kIHRoaW5ncyosICphbmQgZXZlcnl0aGluZyosICpvciBzb21ldGhpbmcqKS4NCg0KPiBHZW5lcmFsIGV4dGVuZGVycyBhcmUgY2xhdXNlLWZpbmFsIHByYWdtYXRpYyBwYXJ0aWNsZXMgYXBwZW5kZWQgdG8gYSB3b3JkLCBhIHBocmFzZSwgb3IgYSBjbGF1c2UgKENoZXNoaXJlIDIwMDcsIHAuIDE1NikuIA0KDQo+IFRoZWlyIGJhc2ljIHBhdHRlcm4gaXMgYSBjb25qdW5jdGlvbiAoKmFuZCogb3IgKmJ1dCopIGZvbGxvd2VkIGJ5IGEgbm91biBwaHJhc2UuIChEZXNhZ3VsaWVyIDIwMTc6MjU3KQ0KDQpUaGUgZm9sbG93aW5nIGV4YW1wbGVzIChhZnRlciBEZXNhZ3VsaWVyIDIwMTc6MjU3KSBpbGx1c3RyYXRlIHRoZWlyIHVzYWdlOg0KDQoqICpTdGV2ZSB3b3JrcyBpbiB0aGUgZW5naW5lZXJpbmcgb2ZmaWNlIGFuZCBoYXMgdGFrZW4gb3ZlciBzb21lIG9mIHRoZSBlciB5b3Uga25vdyBwdXJjaGFzaW5nIGZ1bmN0aW9uIGFzIHdlbGwsIGxpa2UgZW5xdWlyaWVzICoqYW5kIHN0dWZmKiouKiAoQk5D4oCTSlAyKQ0KKiAqQW5kIEkgZG9u4oCZdCB0aGluayB3ZSBkbyBpdCBzbyBtdWNoIHdpdGggdGhlIGVybSAocGF1c2UpIGNhcmVlcnMgc2VydmljZSB0cmFpbmluZywgYnV0IHdpdGggdGhlIGNhcmVlcnMgdGVhY2hlcnMgb2Z0ZW4gd2XigJl2ZSBnb3QgdGhlbSBkb2luZyBhY3Rpb24gcGxhbnMgKiphbmQgdGhpbmdzKiouKiAoQk5D4oCTRzRYKQ0KKiAqSSBrbmV3IGV4YWN0bHkgd2hlcmUgdG8gc3RvcCBpdCBzbyB0aGF0IEkgY291bGQgZ2V0IG9mZiBhbmQgZ28gZG93biB0aGUgbGFkZGVyLCBzbmVhayBhIGN1cCBvZiB0ZWEgKipvciBzb21ldGhpbmcqKi4qIChCTkPigJNGWFYpDQoNCkZvbGxvd2luZyBEZXNhZ3VsaWVyICgyMDE3KSwgd2UgYWltIHRvIGV4cGxvcmUgdGhlIHVzZSBvZiBleHRlbmRlcnMgaW4gdGhlIGxhbmd1YWdlIG9mIEVuZ2xpc2ggdGVlbmFnZXJzIGZyb20gZGlmZmVyZW50IHNvY2lhbCBjbGFzc2VzICh3b3JraW5nIGNsYXNzIChXQykgb3IgbWlkZGxlIGNsYXNzKE1DKSkgZnJvbSB0aHJlZSBFbmdsaXNoIHRvd25zIChSZWFkaW5nLCBNaWx0b24tS2V5bmVzLCBIdWxsKSBhcHBseWluZyBjb3JyZXNwb25kZW5jZSBhbmFseXNpcy4gVGhlIHRvd25zIGFyZSBsb2NhdGVkIGluIHRocmVlIGRpc3RpbmN0IHJlZ2lvbmFsIGxvY2F0aW9ucyBpbiBFbmdsYW5kLiANCkNoZXNoaXJlICgyMDA3OjE2NCkgYXJndWVzIHRoYXQNCg0KPuKAnHRoZXJlIFtpc10gYSByb2J1c3Qgc29jaWFsY2xhc3MgZGlzdGluY3Rpb24gaW4gdGhlIHVzZSBvZiBjZXJ0YWluIGZvcm1zICguIC4gLiAp4oCdIA0KDQpUaGUgdmFyaWFibGVzIGZvciBjb3JyZXNwb25kZW5jZSBhbmFseXNpcyBhcmUgaGVuY2UgKipwcmFnbWF0aWMgZXh0ZW5kZXIqKiB2cy4gdGhlIGNvbmZsYXRlZCB2YXJpYWJsZSAqKlJlZ2lvbl9zb2NpYWwgY2xhc3MqKiBvZiB0aGUgdGVlbmFnZXJzLg0KDQpCZWZvcmUgd2UgdGFrZSBhIGxvb2sgYXQgdGhlIGRhdGEgYW5kIGV4cGxvcmUgaXQgYnkgYXBwbHlpbmcgY29ycmVzcG9uZGVuY2UgYW5hbHlzaXMsIGxldCB1cyBmb3JtdWxhdGUgYSBmZXcgcmVzZWFyY2ggcXVlc3Rpb25zOiANCg0KIyMgMC4xIFJlc2VhcmNoIHF1ZXN0aW9ucw0KDQoqIEFyZSB0aGVyZSBnZW9ncmFwaGljL3NvY2lhbCBkaWZmZXJlbmNlcyBhY3Jvc3MgdGhlIGRhdGENCnNldD8gQW5kLCBpZiBzbywgd2hhdCBhcmUgdGhlc2UgZGlmZmVyZW5jZXM/DQoNCiogV2hpY2ggbGluZ3Vpc3RpYyBmb3JtcyBoYXZlIHRoZSBzYW1lIHJlZ2lvbmFsIGFuZCBzb2NpYWwgcHJvZmlsZXM/DQoNCiogV2hhdCBhcmUgdGhlIGxpbmd1aXN0aWMgcHJvZmlsZXMgb2YgZWFjaCByZWdpb24vc29jaWFsIGNsYXNzIHdpdGggcmVzcGVjdCB0byBnZW5lcmFsIGV4dGVuZGVycz8NCg0KIyMgMC4yIERhdGFzZXQNCg0KYGBge3J9DQojIHJlYWQgcmRzIGZpbGUgd2hpY2ggc3RvcmVzIHRoZSBkYXRhc2V0IGFzIGEgc2luZ2xlIFIgb2JqZWN0DQpleHRlbmRlcnNkYXRhIDwtIHJlYWRSRFMoImRmX2V4dGVuZGVycy5yZHMiKQ0KZXh0ZW5kZXJzZGF0YQ0KYGBgDQoNCmBgYHtyfQ0KY2xhc3MoZXh0ZW5kZXJzZGF0YSkNCmBgYA0KDQoNClRoZSBkYXRhc2V0J3MgZm9ybWF0IGlzIGEgKipjb250aW5nZW5jeSB0YWJsZSoqLiANCg0KPiBBIGNvbnRpbmdlbmN5IHRhYmxlIG9yIGNyb3NzdGFiIGluZGljYXRlcywgZm9yIHR3byBvciBtb3JlIGNhdGVnb3JpY2FsIHZhcmlhYmxlcywgaG93IGZyZXF1ZW50bHkgdGhlIGNvbWJpbmF0aW9ucyBvZiBjaGFyYWN0ZXJpc3RpYyB2YWx1ZXMgb2NjdXIuDQoNClRoZSBmcmVxdWVuY2llcyBpbiB0aGUgcm93cyBhcmUgcmVmZXJyZWQgdG8gYXMgbn5pan4gd2hlcmUgaSBudW1iZXJzIHRoZSByb3dzIDEgdG8gSSAoST02KSBhbmQgaiBudW1iZXJzIHRoZSBjb2x1bW5zIDEgdG8gSiAoSj02KS4gSW4gdGhlIGRhdGEgbWF0cml4IEl4SiBlLmcuIHdlIGdyYXNwIHRoYXQgbn40Mn4gPSAwLg0KDQpgYGB7cn0NCk4gPSBleHRlbmRlcnNkYXRhDQpJIDwtIG5yb3coTikNCkogPC0gbmNvbChOKQ0KSQ0KSg0KTls0LDJdDQpgYGANClRoZSB2YWx1ZXMgb2YgYSB2YXJpYWJsZSAoZS5nLiAnKmFuZCB0aGF0KicpIGFyZSByZWZlcnJlZCB0byBhcyBwb2ludHMgKGluIGNhc2Ugb2YgJyphbmQgdGhhdConIGl0IGlzIGFjdHVhbGx5IGEgcm93IHBvaW50LikgUm93IHBvaW50cyBhbmQgY29sdW1uIHBvaW50cyBjYW4gYmUgZGVwaWN0ZWQgaW4gYSBqb2ludCBzcGFjZSBpbiBhIG1hcC4NCg0KIyMgMC4zIFBlcmZvcm1pbmcgc3RhdGlzdGljYWwgdGVzdHMNCg0KVGhlIGJhY2tncm91bmQgb2YgcGVyZm9ybWluZyBzdGF0aXN0aWNhbCB0ZXN0cyBpcyB0aGF0IHdlIHdhbnQgdG8gY2hlY2sgd2hldGhlciB0aGUgcm93cyBhbmQgY29sdW1ucyBhcmUgbm90IGluZGVwZW5kZW50ICh0aGlzIG1lYW5zIGJhc2ljYWxseSB3aGV0aGVyIHRoZSByZXNlYXJjaCBxdWVzdGlvbiBpcyByZWFzb25hYmxlIGF0IGFsbCksIGFsdGhvdWdoIHRoZW9yZXRpY2FsbHkgaW4gZXhwbG9yYXRvcnkgYW5hbHlzZXMsIHdlIHdvdWxkIG5vdCBtYWtlIGFzc3VtcHRpb25zIHJlZ2FyZGluZyBncm91cGluZ3MgdG8gYmUgZm91bmQuDQoNCg0KIyMjIDAuMy4xIENoaV4yLXRlc3QNCg0KVGhlIM+HIDIgdGVzdCBjaGVja3MgdGhlIHNpZ25pZmljYW5jZSBvZiB0aGUgb3ZlcmFsbCBkZXZpYXRpb24gb2YgdGhlDQpkYXRhIGluIHRoZSBjb250aW5nZW5jeSB0YWJsZSBmcm9tIHRoZSBpbmRlcGVuZGVuY2UgbW9kZWwuIEl0IGNvbXB1dGVzIHRoZSBjb250cmlidXRpb24gb2YgZWFjaCBjZWxsIHRvIM+HIDIgYW5kIHN1bXMgdXAgYWxsIGNvbnRyaWJ1dGlvbnMuIA0KDQpgYGB7cn0NCmNoaXNxIDwtIGNoaXNxLnRlc3QoZXh0ZW5kZXJzZGF0YSkNCmNoaXNxDQpgYGANCltFdmVudHVhbGx5LCBjb25zaWRlciBhIHRvb2wgZm9yIGNvbnZlcnRpbmcgc2NpZW50aWZpYyBub3RhdGlvbiBlLmcuIGh0dHBzOi8vY2FsY3VsYXRvci5uYW1lL3NjaWVudGlmaWMtbm90YXRpb24vc2NpZW50aWZpYy1ub3RhdGlvbi10by1kZWNpbWFsLnBocF0NCg0KDQpIZXJlLCDPhyAyIGhhcyBhIGhpZ2ggdmFsdWUgYW5kIGl0IGlzIGFzc29jaWF0ZWQgd2l0aCB2ZXJ5IHNtYWxsIHAtdmFsdWUgKDAuMDAwMDAwMDAwMDAwMDAwMjIpLiBUaGlzIGltcGxpZXMgdGhhdCB0aGUgcm93IGFuZCBjb2x1bW4gdmFyaWFibGVzIGFyZSBub3QgaW5kZXBlbmRlbnQgYW5kIHRoYXQgdGhlcmUgaXMgYSByZWxhdGlvbnNoaXAuIEhvd2V2ZXIsIHRoZSBtYWduaXR1ZGUgb2YgdGhlIM+HIDIgdmFsdWUgc2hvdWxkIG5vdCBiZSBpbnRlcnByZXRlZCBhcyBxdWFudGlmeWluZyB0aGUgZWZmZWN0IG9mIHRoZSBjb3JyZWxhdGlvbiwgYmVjYXVzZSBpdCBkZXBlbmRzIG9uIHRoZSBzYW1wbGUgc2l6ZS4gDQoNCkhvdyBkbyB3ZSBrbm93IGlmIHRoZSBkZXRlcm1pbmVkIENoaS1zcXVhcmUgdmFsdWUgaXMgYSBsYXJnZSB2YWx1ZT8NCg0KV2UgY2FuIHVzZSBzdGF0aXN0aWNzIHRhYmxlcyB3aXRoIHRoZSBDaGktc3F1YXJlZCBkaXN0cmlidXRpb24gdG8gY29tcGFyZSBvdXIgdmFsdWVzLCBsaWtlIGUuZy4gPGh0dHBzOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0VuZ2luZWVyaW5nX1RhYmxlcy9DaGktU3F1YXJlZF9EaXN0aWJ1dGlvbj4uDQpXZSBoYXZlIHRvIGNoZWNrIHRoZSBjZWxsIGZvciB0aGUgY29ycmVzcG9uZGluZyBkZWdyZWVzIG9mIGZyZWVkb20gKHNlZSBkZj0yNSB2YWx1ZSBpbiBvdXRwdXQpIGFuZCB0aGUgYXNzdW1lZCBzaWduaWZpY2FuY2UgbGV2ZWwgKGUuZy4gMC4wNS4pLiBJZiB0aGUgY2FsY3VsYXRlZCBjaGktc3F1YXJlIHZhbHVlIGlzIHNtYWxsZXIgdGhhbiB0aGUgY3JpdGljYWwgdmFsdWUsIHRoZSBudWxsIGh5cG90aGVzaXMgY2FuIGJlIHJldGFpbmVkLg0KDQoNCkZvciBhbiBJeEogdGFibGUgKDZ4Nj0zNiksIHRoZSBudW1iZXIgb2YgZGVncmVlcyBvZiBmcmVlZG9tIGlzIGdpdmVuIGJ5IChJLTEpeChKLTEpIG9yICg1eDU9MjUpKS4gRGVncmVlcyBvZiBmcmVlZG9tIHJlZmVycyB0byB0aGUgbnVtYmVyIG9mIHZhbHVlcyB0aGF0IGNhbiBiZSB2YXJpZWQgd2l0aG91dCBjaGFuZ2luZyB0aGUgcmVsZXZhbnQgc3RhdGlzdGljYWwgcGFyYW1ldGVyLiANCkZvciBleGFtcGxlLCBpZiB5b3UgdGFrZSB0aGUgYXJpdGhtZXRpYyBtZWFuIG9mIHRocmVlIHZhbHVlcywgdGhlbiB5b3UgY2FuIGZyZWVseSB2YXJ5IHR3byBhbmQgZ2V0IHRoZSBzYW1lIHJlc3VsdCwgdGhlIGxhc3QgdmFsdWUgY2Fubm90IGJlIGZyZWVseSB2YXJpZWQsIGJlY2F1c2UgaXQgaXMgYWxyZWFkeSBkZXRlcm1pbmVkLg0KDQokJDErMiszLzMgPSAyJCQNCiQkMis0KzAvMyA9IDIkJA0KYnV0IG5vdCAkJDIrNCsxJCQNCg0KDQpBcyB0aGUgbW9zdCBpbXBvcnRhbnQgc2lnbmlmaWNhbmNlIGxldmVscyAgXGFscGhhIHdlIGRpc3Rpbmd1aXNoOiANCjAsMDUgICg8ID0gNSUgc2lnbmlmaWNhbnQpLCAoOTUlKQ0KMCwwMSAoPCA9IDElIHZlcnkgc2lnbmlmaWNhbnQpLCAoOTklKQ0KMCwwMDEoPCA9IDAsMSUgaGlnaGx5IHNpZ25pZmljYW50KSAoOTksOSUpLg0KDQpUaGUgdGVzdCBzdGF0aXN0aWMgaXMgdXN1YWxseSBhc3NvY2lhdGVkIHdpdGggYSBQLXZhbHVlIHdoaWNoIGluZGljYXRlcyB0aGUgc21hbGwgcHJvYmFiaWxpdHkgKDAuMDAxIGNvcnJlc3BvbmRzIHRvIDEgaW4gMTAwMCkgb2YgeWV0IHJlY29uY2lsaW5nIHRoZSBvYnNlcnZlZCBmcmVxdWVuY2llcyB3aXRoIHRoZSBpbmRlcGVuZGVuY2UgaHlwb3RoZXNpcy4gDQpUaGUgUC12YWx1ZSBpbmRpY2F0ZXMgaG93IGluY29tcGF0aWJsZSBkYXRhIGFyZSB3aXRoIGEgcGFydGljdWxhciBzdGF0aXN0aWNhbCBtb2RlbDogdGhlIHNtYWxsZXIgdGhlIHZhbHVlLCB0aGUgZ3JlYXRlciB0aGUgaW5jb21wYXRpYmlsaXR5IHdpdGggdGhlIG51bGwgaHlwb3RoZXNpcy4gUC12YWx1ZXMgZG8gbm90IG1lYXN1cmUgdGhlIHByb2JhYmlsaXR5IHRoYXQgYSBoeXBvdGhlc2lzIHVuZGVyIGludmVzdGlnYXRpb24gaXMgdHJ1ZSAoc2VlIFdhc3NlcnN0ZWluICYgTGF6YXIgMjAxNikuDQoNCg0KSW4gZ2VuZXJhbCB0aGUgdGVzdCBpbXBvc2VzIGNvbmRpdGlvbnMgdGhhdCBhbGwgb2JzZXJ2YXRpb25zIGFyZSBpbmRlcGVuZGVudCBhbmQgdGhhdCA4MCslIG9mIHRoZSBleHBlY3RlZCBmcmVxdWVuY2llcyBhcmUgbGFyZ2VyIHRoYW4gNS4NCg0KDQpgYGB7cn0NCmNoaXNxJGV4cA0KYGBgDQoNCkluIG91ciBjYXNlLCB0aGUgZGF0YXNldCBkb2VzIG5vdCBtZWV0IHRoZSBzZWNvbmQgYXNzdW1wdGlvbiAgKG9ubHkgNjclIG9mIHRoZSBzYW1wbGUgc2l6ZSBpcyBncmVhdGVyIDUpIGJ1dCBHcmVlbmFjcmUgKDIwMDcpIGFyZ3VlcyB0aGF0IA0KaXQgY2FuIGJlIGFwcGxpZWQgLiBHaXZlbiB2ZXJ5IHNtYWxsIHAtdmFsdWUsIHRoZSBzaWduaWZpY2FuY2Ugb2YgdGhlIGRldmlhdGlvbiBvZiB0aGUgdGFibGUgZnJvbSBpbmRlcGVuZGVuY2UgaXMgbm90IGRlbmlhYmxlLiANCg0KDQpMYXRlciBvbiwgaW4gc2VjdGlvbiAzLjEsIHdlIHdpbGwgc2VlIGhvdyB0byBjYWxjdWxhdGUgdGhlIGNoaS1zcXVhcmUgdmFsdWUgbWFudWFsbHksIHdpdGggc29tZSBtb3JlIGluIGRlcHRoIGRpc2N1c3Npb24uICANCg0KDQojIyMgMC4zLjIgUGVhcnNvbidzIHJlc2lkdWFscw0KDQpQZWFyc29uJ3MgciBpcyBhIGNvcnJlbGF0aW9uIG1lYXN1cmUgZm9yIHRoZSBhc3NvY2lhdGlvbiBiZXR3ZWVuIHR3byByYW5kb20gdmFyaWFibGVzICh4IGFuZCB5KS4NCg0KSWYgdGhlIFBlYXJzb24gcmVzaWR1YWwgaW4gYSBjZWxsIGlzIHBvc2l0aXZlL25lZ2F0aXZlLCB0aGVuIHRoZSBvYnNlcnZlZCBmcmVxdWVuY3kgaW4gdGhhdCBjZWxsIGlzIGdyZWF0ZXIvbGVzcyB0aGFuIHRoZSBleHBlY3RlZCBmcmVxdWVuY3kgaW4gdGhhdCBjZWxsLiBTZWNvbmQsIHRoZSBtb3JlIHRoZSBQZWFyc29uIHJlc2lkdWFsIGRldmlhdGVzIGZyb20gMCwgdGhlIHN0cm9uZ2VyIHRoYXQgZWZmZWN0LCBvciwgaW4gb3RoZXIgd29yZHMsIHRoZSBjbG9zZXIgdGhlIGNvZWZmaWNpZW50IGlzIHRvIDAsIHRoZSB3ZWFrZXIgdGhlIGNvcnJlbGF0aW9uLg0KDQpgYGB7cn0NCmNoaXNxJHJlcw0KYGBgDQoNClVwb24gaW5zcGVjdGlvbiBvZiB0aGUgdmFsdWVzIHdlIG9ic2VydmUgYSBzdHJvbmcgZWZmZWN0IGZvcjoNCg0KKiAnKmFuZCB0aGF0KicgLSAnKlJlYWRpbmdfTUMqJyAoLTUuNjkpLCAtICcqTWlsdG9uX0tleW5lc19NQyonICgtNC4yNyksLSAnKk1pbHRvbl9LZXluZXNfV0MqJyAoNS4wOSksIC0gJypIdWxsX1dDKicgKDYuNTcpDQoqICcqb3Igc29tZXRoaW5nKicgLSAnKlJlYWRpbmdfTUMqJyAoNS45NSksIC0gJypIdWxsX1dDKicgKC00LjY0KQ0KKiAnKmFuZCBhbGwgdGhhdConIC0gJypSZWFkaW5nX1dDKicgKDUuMDUpDQoqICcqYW5kIHRoaW5ncyonIC0gJypNaWx0b25fS2V5bmVzX01DKicgKDQuOTEpDQoqICcqYW5kIHN0dWZmKicgLSAnKkh1bGxfTUMqJyAoNS42MSkNCi4uLg0KDQojIyMgMC4zLjMgQ3JhbWVyJ3MgVjogaW50ZW5zaXR5IG9mIHRoZSByZWxhdGlvbnNoaXAgDQoNClRoZSBpbnRlbnNpdHkgb2YgdGhlIHJlbGF0aW9uc2hpcCBpcyBtZWFzdXJlZCB3aXRoIENyYW3DqXLigJlzIFYsIGFuZCBpdCBpcyBub24gbmVnbGlnaWJsZSBmb3IgdGhlIGRhdGFzZXQuIFRoZSBwZXJmZWN0IHNjb3JlIG9mIDEgaXMgdW5yZWFsaXN0aWMgaGVyZSwgYXMgdGhlIGFzc29jaWF0aW9uIGJldHdlZW4gdGhlIHVzZSBvZiBleHRlbmRlcnMgYW5kIHRoZSBzb2Npby1nZW9ncmFwaGljIGJhY2tncm91bmQgaXMgbm90IGV4Y2x1c2l2ZSAoY2YuIERlc2FndWxpZXIgMjAxNzoyNjkpLg0KYGBge3J9DQpWZGlmIDwtIHNxcnQoY2hpc3Ekc3RhdC8oc3VtKGV4dGVuZGVyc2RhdGEpICogKG1pbihkaW0oZXh0ZW5kZXJzZGF0YSkpLTEpKSkNCnJvdW5kKFZkaWYsIDMpDQoNCmBgYA0KDQpTZWUgYWxzbyBzZWN0aW9uIDMuMSBmb3IgdGhlIGZvcm11bGEgaG93IHRvIGNhbGN1bGF0ZSBpdC4NCg0KIyMgMC40IEEgZmlyc3QgbG9vayBhdCBjYSBhbmFseXNpcyBhbmQgaW50ZXJwcmV0YXRpb24NCg0KQmVmb3JlIHdlIHByb2NlZWQgd2l0aCBjb21wbGV4IG1hdGhlbWF0aWNhbCBvcGVyYXRpb25zLCBsZXQgdXMgaGF2ZSBhIGZpcnN0IGxvb2sgYXQgd2hhdCBhIENBIGFuYWx5c2lzIG9mIHRoZSBkYXRhc2V0IGxvb2tzIGFuZCB3aGF0IGluaXRpYWwgb2JzZXJ2YXRpb25zIGNhbiBiZSBtYWRlLiANCg0KV2l0aG91dCB0aGUgaGVscCBvZiBhIENBIGdyYXBoLCBDaGVzaGlyZSAoMjAwNywgcC4gMTY0KSBpbnRlcnByZXRzIHRoZSB0YWJsZSBvZiBmcmVxdWVuY2llcyBhcyBmb2xsb3dzOg0KDQo+T2YgdGhlIGFkanVuY3RpdmVzLCAqYW5kIHRoYXQqIHdhcyBwcmVmZXJyZWQgYnkgdGhlIHdvcmtpbmctY2xhc3Mgc3BlYWtlcnMgaW4gYWxsIHRocmVlIHRvd25zLCBhcyB3YXMgdGhlIGxlc3MgZnJlcXVlbnQgKmFuZCBhbGwgdGhhdCouIFRoZSBtaWRkbGUtY2xhc3Mgc3BlYWtlcnMsIG9uIHRoZSBvdGhlciBoYW5kLCBwcmVmZXJyZWQgKmFuZCBzdHVmZiogYW5kICphbmQgdGhpbmdzKiBhZ2FpbiBpbiBhbGwgdGhyZWUgdG93bnMsIHRob3VnaCBpbiBIdWxsIHRoZSBtaWRkbGUtY2xhc3MgYWRvbGVzY2VudHMgdXNlZCAqYW5kIHN0dWZmKiBmYXIgbW9yZSBvZnRlbiB0aGFuICphbmQgdGhpbmdzKiAodGhlIHJlbGF0aXZlbHkgaGlnaCBmcmVxdWVuY3kNCm9mICphbmQgc3R1ZmYqIGZvciB0aGUgd29ya2luZy1jbGFzcyBncm91cCBpbiBIdWxsIHdhcyBkdWUgdG8ganVzdCB0aHJlZSBzcGVha2Vycywgb25lIG9mIHdob20gd2FzIHJlc3BvbnNpYmxlIGZvciAxMCBvZiB0aGUgMTggdG9rZW5zKS4NCg0KS2VlcGluZyBpbiBtaW5kIHRob3NlIG9ic2VydmF0aW9ucywgd2Ugd2lsbCBub3cgcGxvdCB0aGUgbG93LWRpbWVuc2lvbmFsIG1hcCByZXN1bHRpbmcgZnJvbSB0aGUgQ0EgYW5hbHlzaXMgYW5kIGluc3BlY3QgaXQuDQoNCg0KYGBge3J9DQpsaWJyYXJ5KGNhKQ0KIyBwZXJmb3JtaW5nIGNhIHdpdGggY2EgcGFja2FnZQ0KY2FfZXh0IDwtIGNhKGV4dGVuZGVyc2RhdGEsIGdyYXBoPUYpDQpwYXIobWZyb3c9YygxLDIpKSAjIHNldCB0aGUgcGxvdHRpbmcgYXJlYSBpbnRvIGEgMSoyIGFycmF5DQojIHBsb3R0aW5nIGZpcnN0IHR3byBkaW1lbnNpb25zDQpwbG90KGNhX2V4dCwgZGltPWMoMToyKSkNCiMgYW5kIHNlY29uZCBhbmQgdGhpcmQgZGltZW5zaW9uDQpwbG90KGNhX2V4dCwgZGltPWMoMzoyKSkNCg0KYGBgDQoNCg0KV2hlbiB3ZSBpbnRlcnByZXQgdGhlIG1hcCBvZiB0aGUgZmlyc3QgYW5kIHNlY29uZCBkaW1lbnNpb24sIHdlIGZpbmQgDQoNCiogYSBjbGVhciBkaXZpZGUgYmV0d2VlbiB0aGUgdXNlIG9mIGV4dGVuZGVycyBieSBtaWRkbGUtY2xhc3MgIGFuZCB3b3JraW5nLWNsYXNzIGluZm9ybWFudHMgb24gdGhlIGZpcnN0IGF4aXMNCiAgICAtIGV4dGVuZGVycyBmYXZvcmVkIGJ5IG1pZGRsZS1jbGFzcyB0ZWVuYWdlcnMgYXJlICpvciBzb21ldGhpbmcqLCAqYW5kIHRoaW5ncyosIGFuZCAqYW5kIHN0dWZmKg0KICAgIC0gZXh0ZW5kZXJzIGZhdm9yZWQgYnkgd29ya2luZy1jbGFzcyB0ZWVuYWdlcnMgYXJlICphbmQgYWxsIHRoYXQqLCBhbmQgKmFuZCB0aGF0Kg0KICAgIC0gKmFuZCBldmVyeXRoaW5nKiBpbiB0aGUgbWlkZGxlIGlzIHdlbGwgcHJvamVjdGVkIGFsb25nIHRoZSB2ZXJ0aWNhbCBheGlzLCBhbmQgc2VlbXMgdG8gYmUgaW5kaWZmZXJlbnQgdG8gc29jaW8tZ2VvZ3JhcGhpYyBncm91cHMNCg0KKiB0aGF0IHRoZSB2ZXJ0aWNhbCBheGlzIHNob3dzIGEgZGlmZmVyZW5jZSBiZXR3ZWVuIEh1bGwgYW5kIFJlYWRpbmcgcmVwcmVzZW50aW5nIHRoZSBnZW9ncmFwaGljYWwgZGlzc2ltaWxhcml0eSB3aXRoIE1pbHRvbiBLZXluZXMgc29tZXdoZXJlIGluIGJldHdlZW47IE5vdGU6IEh1bGwgaXMgaW4gWW9ya3NoaXJlIChub3J0aGVybiBFbmdsYW5kKSwgd2hlcmVhcyBSZWFkaW5nIGFuZCBNaWx0b24gS2V5bmVzIGFyZSBtdWNoIGZ1cnRoZXIgc291dGguDQoNCldoZW4gaW5zcGVjdGluZyB0aGUgc2Vjb25kIGFuZCB0aGlyZCBkaW1lbnNpb25hbCB2aWV3IHpvb21pbmcgaW4gYSBsaXR0bGUgYml0LCB3ZSBvYnNlcnZlIHRoYXQNCg0KKiAqYW5kIGFsbCB0aGF0KiAoRnJlcS4gUjoxOCwgTTo2LCBIOjUpIGFuZCAqb3Igc29tZXRoaW5nKiAoRnJlcS4gUjo5MiwgTTo0NywgSDoyNikgZ3JvdXAgd2l0aCBSZWFkaW5nDQoqICphbmQgc3R1ZmYqIChGcmVxLiBSOjQyLCBNOjUwLCBIOjgwKSBhbmQgKmFuZCBldmVyeXRoaW5nKiAoRnJlcTogUjogMzcsIE06IDQwLCBIOjYxKSBncm91cCB3aXRoIEh1bGwNCiogKmFuZCB0aGluZ3MqIChGcmVxLiBSOjMyLCBNOjM1LCBIOjE3KSBhbmQgKmFuZCB0aGF0KiAoRnJlcS4gUjogNTMsIE06NTMsIEg6NzYpIHdoaWNoIGFyZSB2ZXJ5IGRpc3NpbWlsYXIgaW4gdGhlIGZpcnN0IGRpbWVuc2lvbiAoYmVjYXVzZSBvZiBiZWluZyBkaWZmZXJlbnRseSBhc3NvY2lhdGVkIHdpdGggbWlkZGxlIGFuZCB3b3JraW5nIGNsYXNzKSBhcmUgbm90IHNlcGFyYXRlZCBieSB0aGUgdGhpcmQgZGltZW5zaW9uLiBUaGV5IGFwcGVhciBjbG9zZSB0byBNaWx0b24gS2V5bmVzIGJ1dCBhcmUgcmVsYXRpdmVseSBmcmVxdWVudGx5IHVzZWQgaW4gYWxsIHRvd25zLg0KDQoNCkluIHN1bSwgd2UgZmluZCB0aGF0IHRoZSBkaW1lbnNpb24tcmVkdWN0aW9uIHRlY2huaXF1ZSB0byByZXByZXNlbnQgdGhlIChkaXMtKXNpbWlsYXJpdHkgYmV0d2VlbiB2YXJpYWJsZXMgaW4gYSBtYXAsIHlpZWxkcyBpbnNpZ2h0cyB3aGljaCBhcmUgaW4gbGluZSB3aXRoIHRoZSBpbnRlcnByZXRhdGlvbiBvZiByYXcgZnJlcXVlbmNpZXMuIEZvciB0aGUgbW9tZW50LCB3ZSBoYXZlIHNraXBwZWQgYSBsb29rIGF0IHRoZSBudW1lcmljYWwgcmVzdWx0cyBvZiBjb3JyZXNwb25kZW5jZSBhbmFseXNpcyB3aGljaCBhcmUgZXF1YWxseSBpbXBvcnRhbnQgaW4gaW50ZXJwcmV0YXRpb24sIGFuZCB3ZSB3aWxsIHR1cm4gdG8gdGhvc2Ugd2hlbiBjb25zaWRlcmluZyB0aGUgbWF0aGVtYXRpY2FsIGZvdW5kYXRpb24uIA0KDQojIyAwLjUgVmFsaWRhdGlvbiBvZiBjYWxjdWxhdGlvbnMgd2l0aCB0aGUgYGBjYWBgIHBhY2thZ2UNCg0KVGhlcmUgYXJlIGRpZmZlcmVudCBSIHBhY2thZ2VzIGZvciBwZXJmb3JtaW5nIGNvcnJlc3BvbmRlbmNlIGFuYWx5c2lzOiB0aHJvdWdob3V0IHRoaXMgbm90ZWJvb2sgd2UgdXNlIEdyZWVuYWNyZSAmIE5lbmFkaWMncyAoMjAyMCkgYGBjYWBgIHBhY2thZ2UgYW5kIGFwcGx5IHRoZSBgYGNhKClgYCBjb21tYW5kIGZvciBzaW1wbGUgY29ycmVzcG9uZGVuY2UgYW5hbHlzaXMuDQpJbiB0aGUgb3V0cHV0IGJlbG93LCB5b3Ugd2lsbCBzZWUgdGhlIGV4aXN0aW5nIHZhcmlhYmxlcyBvZiBhIGNhLWFuYWx5c2lzIG9iamVjdC4gV2Ugd2lsbCBsb2FkIHRoZSBzaW5nbGUgcHJlZGVmaW5lZCB2YXJpYWJsZXMgZHVyaW5nIG91ciBjYWxjdWxhdGlvbnMgdG8gY2hlY2sgd2hldGhlciBvdXIgbWFudWFsbHkgb2J0YWluZWQgcmVzdWx0cyBhcmUgY29ycmVjdC4NCg0KYGBge3J9DQpsaWJyYXJ5KGNhKQ0KY2FfdmFsaWRhdGlvbiA8LSBjYShOKQ0Kc3RyKGNhX3ZhbGlkYXRpb24pDQpgYGANCg0KV2UgY2FuIGFsc28gcHJpbnQgYSBjb25kZW5zZWQgc3VtbWFyeSBvZiB0aGUgYW5hbHlzaXMnIHJlc3VsdHMgd2l0aCBgYHN1bW1hcnlgYCB3aGVyZSB2YXJpYWJsZXMgYXJlIGFiYnJldmlhdGVkIGluIHRoZSBvdXRwdXQuIFdlIHdpbGwgZXhwbGFpbiB0aGUgdmFsdWVzJyBzaWduaWZpY2FuY2UgaW4gc2hvcnQuIA0KDQpgYGB7cn0NCiMgcHJpbnQgc3VtbWFyeQ0Kc3VtbWFyeShjYV92YWxpZGF0aW9uKQ0KYGBgDQoNCg0KIyAxLjAgT2JzZXJ2ZWQgcHJvcG9ydGlvbnMsIHByb2ZpbGVzIGFuZCBtYXNzZXMNCg0KQmVmb3JlIHdlIHN0YXJ0IHdpdGggdGhlIG1hdGhlbWF0aWNhbCBjYWxjdWxhdGlvbnMgdG8gb2J0YWluIG9ic2VydmVkIHByb3BvcnRpb25zLCB3ZSBuZWVkIHRvIHRyYW5zZm9ybSB0aGUgcmF3IGZyZXF1ZW5jaWVzIGluIHRoZSBjb250aW5nZW5jeSB0YWJsZSwgZS5nLiBieSBhZGRpbmcgdGhlIG1hcmdpbiB0b3RhbHMuDQoNCiMjIDEuMSBSb3cgYW5kIENvbHVtbiBUb3RhbHMgDQoNCldlIGNyZWF0ZSB0aGUgcm93IHN1bXMgKGByb3dTdW1zYCkgYW5kIGNvbHVtbiBzdW1zIChgY29sU3Vtc2ApIG9mIE4sIGJpbmQgdGhlbSB0byB0aGUgbWFyZ2lucyBvZiB0aGUgb3JpZ2luYWwgdGFibGUgYW5kIG5hbWUgdGhlIGFkZGl0aW9uYWwgcm93IGFuZCBjb2x1bW4uDQpgYGB7cn0NCg0KTl90b3RhbCA9IHJiaW5kKE4sIGNvbFN1bXMoTikpDQpOX3RvdGFsID0gY2JpbmQoTl90b3RhbCwgcm93U3VtcyhOX3RvdGFsKSkNCnJvd25hbWVzKE5fdG90YWwpWzddIDwtICJjb2x1bW50b3RhbCINCmNvbG5hbWVzKE5fdG90YWwpWzddIDwtICJyb3d0b3RhbCINCk5fdG90YWwNCmBgYA0KDQoNCg0KIyMgMS4yIENhbGN1bGF0aW5nIG9ic2VydmVkIHByb3BvcnRpb25zIFAgaW4gYSBjb3JyZXNwb25kZW5jZSBtYXRyaXggDQoNCkluIHRoaXMgc3RlcCwgd2UgdHJhbnNmb3JtIHRoZSBmcmVxdWVuY2llcyBvZiB0aGUgY29udGluZ2VuY3kgdGFibGUgaW50byBwcm9wb3J0aW9ucy4NCg0KVGhlcmVmb3JlLCB3ZSBmaXJzdCBuZWVkIHRoZSB0b3RhbCBmcmVxdWVuY3kgbiBvZiBhbGwgb2JzZXJ2ZWQgaW5zdGFuY2VzIGluIHRhYmxlIGBOYCB3aGljaCBjYW4gYmUgb2J0YWluZWQgYnkgYXBwbHlpbmcgdGhlIGZ1bmN0aW9uIGBzdW0oKWAgdG8gdGhlIHRhYmxlLg0KYGBge3J9DQpuIDwtIHN1bShOKQ0Kbg0KYGBgDQoNCk5leHQsIHdlIGNyZWF0ZSB0aGUgdGFibGUgd2l0aCB0aGUgb2JzZXJ2ZWQgcHJvcG9ydGlvbnMgYFBgIHRocm91Z2ggdGhlIGZvbGxvd2luZyBmb3JtdWxhLiBUbyBjYWxjdWxhdGUgdGhlICpjb3JyZXNwb25kZW5jZSBtYXRyaXgqIG9mIHJlbGF0aXZlIGZyZXF1ZW5jaWVzIHB+aWp+LCBmcmVxdWVuY2llcyBhcmUgZGl2aWRlZCBieSB0aGUgdG90YWwgZnJlcXVlbmN5IG4uDQoNCg0KYGBge3J9DQpQIDwtIE4vbg0KDQpQDQpgYGANCg0KIyMgMS4zIFByb2ZpbGVzIGFuZCBNYXNzZXMNCg0KSW4gdGhpcyBzZWN0aW9uIHdlIHdpbGwgdW5kZXJzdGFuZCB0aGUgaW1wb3J0YW50IGNvbmNlcHRzIG9mIHByb2ZpbGVzIGFuZCBtYXNzZXMuDQoNCiMjIyAxLjMuMSBSb3cgYW5kIGNvbHVtbiBwcm9maWxlcw0KDQo+IEEgcm93LCBvciBhIGNvbHVtbiBvZiBhIGNvbnRpbmdlbmN5IHRhYmxlIGluIHdoaWNoIGVsZW1lbnRzIGhhdmUgYmVlbiBkaXZpZGVkIGJ5IHRoZSByb3cgc3VtcyBvciBjb2x1bW4gc3VtcyByZXNwZWN0aXZlbHkuIFByb2ZpbGVzIGFyZSB2aXN1YWxpemVkIGFzIHBvaW50cyBpbiBzcGFjZSBieSBjb3JyZXNwb25kZW5jZSBhbmFseXNpcy4oY2YuIEhhdXR6ICYgQmxldWVsIDIwMTg6MjIxKSANCg0KRm9yIHRoZSBuZXh0IHN0ZXAsIHdlIG5vdGUgdGhhdCBwcm9maWxlcyBhcmUgb2J0YWluZWQgYnkgY3JlYXRpbmcgcmVsYXRpdmUgZnJlcXVlbmNpZXMgZnJvbSB0aGUgbWFyZ2luYWwgc3VtcyBpbnN0ZWFkIG9mIGRpdmlkaW5nIHRoZW0gYnkgdGhlIHRvdGFsIGZyZXF1ZW5jeSBuLg0KIA0KDQojIyMjIFJvdyBwcm9maWxlcw0KDQpDb25zaWRlcmluZyB0aGUgcm93IHN1bXMsIHdlIG9idGFpbiByZWxhdGl2ZSBmcmVxdWVuY2llcyBmb3IgdGhlIHJvd3MsIHRoYXQgbWFrZSB0aGUgcHJvZmlsZSBmb3IgZWFjaCByb3cgcG9pbnQuDQoNClRoZSByb3cgcHJvZmlsZSBmb3IgdGhlIHJvdyBwb2ludCAnKmFuZCB0aGF0KicgYWNyb3NzIHRoZSBzb2NpYWwtZ2VvZ3JhcGhpY2FsIGdyb3VwcyBvZiB0ZWVuYWdlcnMgaXMgZGV0ZXJtaW5lZCBpbiB0aGUgZm9sbG93aW5nIHdheToNCldlIGRpdmlkZSB0aGUgY291bnQgaW4gZWFjaCBjZWxsIGluIHRoZSByb3cgYnkgdGhlIHJvdyBzdW0gaW4gYE5fdG90YWxgIG9mIHRoZSByZXNwZWN0aXZlIHJvdy4NCg0KVGhlIGNhbGN1bGF0aW9ucyBpbnNpZGUgdGhlIGZpcnN0IHJvdyBhcmUgdGhlIGZvbGxvd2luZzoNCiQkNCA6IDE4MiwgNDk6MTgyLCA5OjE4MiwgNDQ6MTgyLCAxMDoxODIsIDY2OjE4MiQkDQpgYGB7cn0NCg0KTlsxLDFdL05fdG90YWxbMSw3XQ0KTlsxLDJdL05fdG90YWxbMSw3XQ0KTlsxLDNdL05fdG90YWxbMSw3XQ0KTlsxLDRdL05fdG90YWxbMSw3XQ0KTlsxLDVdL05fdG90YWxbMSw3XQ0KTlsxLDZdL05fdG90YWxbMSw3XQ0KDQpgYGANClRoZSBwZXJjZW50YWdlcyBhcmUgdXNlZCB0byBub3JtYWxpemUgdGhlIHJvdyB0b3RhbHMgdG8gdGhlIHZhbHVlIDEsIHNvIHRoYXQgdGhlIHJvd3MgY2FuIG5vdyBiZSBjb21wYXJlZCB3aXRoIGVhY2ggb3RoZXIgcmVnYXJkbGVzcyBvZiB0aGUgZnJlcXVlbmN5IG9mIHRoZWlyIGFic29sdXRlIG1lbnRpb25zLiANCg0KVGhlIGZpcnN0IHZhbHVlIG9mIHRoZSByb3cgcHJvZmlsZSBpbmRpY2F0ZXMgdGhhdCB0aGUgZXh0ZW5kZXIgJyphbmQgdGhhdConIGlzIGluIDIlIHVzZWQgYnkgJypSZWFkaW5nX01DKicgdGVlbmFnZXJzLg0KDQoNCioqTWF0cml4IG9mIHJvdyBwcm9maWxlcyBvciBwcm9maWxlcyBvZiBleHRlbmRlcnMqKg0KDQpUbyBvYnRhaW4gdGhlIHJvdyBwcm9maWxlcyBmb3IgdGhlIGNvbXBsZXRlIHRhYmxlIHdlIHVzZSB0aGUgYHN3ZWVwKClgIGZ1bmN0aW9uIHdoaWNoIGlzIHNpbWlsYXIgdG8gYGFwcGx5KClgLg0KDQpgc3dlZXAoeCwgTUFSR0lOLCBTVEFUUywgRlVOKWAgYXBwbGllcyBhbiBvcGVyYXRpb24gdG8gYSBkYXRhIG1hdHJpeCBvdmVyIHRoZSByb3dzIG9yIG92ZXIgdGhlIGNvbHVtbnMuIFRoZSBwYXJhbWV0ZXIgYE1BUkdJTiA9MWAgc3dlZXBzIG92ZXIgdGhlIHJvd3MsIHdoaWxlIGBNQVJHSU4gPTJgIHN3ZWVwcyBvdmVyIHRoZSBjb2x1bW5zLiAgU1RBVFMgaXMgdGhlIHZhbHVlIHVzZWQgaW4gdGhlIG9wZXJhdGlvbiAoZS5nLiAyKSwgRlVOIGlzIHRoZSB0eXBlIG9mIG9wZXJhdGlvbiAoZS5nLiArLCAtKS4NCg0KYGBge3J9DQojIHN3ZWVwIGZ1bmN0aW9uIGRpdmlkZXMgZWFjaCBlbGVtZW50IG9mIHRoZSBtYXRyaXggTiBieSB0aGUgc3VtIG9mIGl0cyByZXNwZWN0aXZlIHJvdw0KIyAxOiBUaGUgbWFyZ2luIG92ZXIgd2hpY2ggdGhlIG9wZXJhdGlvbiBpcyBhcHBsaWVkLiAxIGluZGljYXRlcyByb3dzLCBhbmQgMiB3b3VsZCBpbmRpY2F0ZSBjb2x1bW5zDQojICIvIiBpbmRpY2F0ZXMgZGl2aXNpb24gb3BlcmF0aW9uDQpyb3cucHJvZmlsZXMgPSBzd2VlcChOLCAxLCAocm93U3VtcyhOKSksICIvIikNCnJvdy5wcm9maWxlcw0KYGBgDQoNCg0KTm90ZTogYGFwcGx5KClgIChyZXR1cm5zIGEgdmVjdG9yLCBhcnJheSBvciBhIGxpc3Qgb2YgdmFsdWVzIGJ5IGFwcGx5aW5nIGEgZnVuY3Rpb24gdG8gdGhlIG1hcmdpbnMgb2YgYW4gYXJyYXkgKGRhdGEgb2JqZWN0IHdpdGggcG9zc2libHkgbW9yZSB0aGFuIHR3byBkaW1lbnNpb25zKSBvciBvZiBhIG1hdHJpeCk7IA0KDQoNClRoZSAqKmF2ZXJhZ2Ugcm93Kiogb2YgdGhlIG1hdHJpeCBvZiByb3cgcHJvZmlsZXMgY2FuIGJlIGRldGVybWluZWQgYnkgdGhlIGNvbHVtbiB0b3RhbHMgb2YgdGhlIHRhYmxlIG9mIG1hcmdpbiB0b3RhbHMgYE5fVG90YWxgIGRpdmlkZWQgYnkgdGhlIHRvdGFsIGZyZXF1ZW5jeSBuLg0KDQpgYGB7cn0NCiMgY2FsY3VsYXRpbiBhdmVyYWdlcw0Kcm93LmF2ZXJhZ2VzIDwtICBjKE5fdG90YWxbNywxXS9uLCBOX3RvdGFsWzcsMl0vbiwgTl90b3RhbFs3LDNdL24sIE5fdG90YWxbNyw0XS9uLCBOX3RvdGFsWzcsNV0vbiwgTl90b3RhbFs3LDZdL24pDQojIGFwcGVuZGluZyB0aGUgYXZlcmFnZXMgdG8gYSBuZXcgcm93DQpyb3cucHJvZmlsZXMuYXYgPC0gcmJpbmQocm93LnByb2ZpbGVzLCByb3cuYXZlcmFnZXMpDQojIGFuZCBuYW1pbmcgdGhlIHJvdw0Kcm93bmFtZXMocm93LnByb2ZpbGVzLmF2KSBbN10gPC0gImF2ZXJhZ2Ugcm93IHByb2ZpbGUiDQpyb3cucHJvZmlsZXMuYXYNCiAgICAgICAgICAgICAgICAgICAgICAgICANCmBgYA0KDQpUaGUgYXZlcmFnZSByb3cgcHJvZmlsZSB0ZWxscyB1cyB0aGF0IGlycmVzcGVjdGl2ZSBvZiB0aGUgY2hvc2VuIGV4dGVuZGVyIDIxJSBvZiB0aGUgdXNhZ2VzIGFyZSBhdHRyaWJ1dGVkIHRvICcqUmVhZGluZ19NQyonLCAxMyUgdG8gJypSZWFkaW5nX1dDKicsIDE4JSB0byAnKk1pbHRvbl9LZXluZXNfTUMqJywgMTElIHRvICcqTWlsdG9uX0tleW5lc19XQyonLCAxNyUgdG8gJypIdWxsX01DKicgYW5kIDE2JSB0byAnKkh1bGxfV0MqJyB0ZWVuYWdlcnMuIEluIHRoaXMgd2F5LCB3ZSBjYW4gY29tcGFyZSB0aGUgcHJvZmlsZXMgb2YgZXh0ZW5kZXJzIHRvIGVhY2ggb3RoZXIgb3IgdG8gdGhlIGF2ZXJhZ2Ugcm93LiANClRoZSB1c2Ugb2YgdGhlIGV4dGVuZGVyICcqYW5kIHRoYXQqJyBlLmcuIGxpZXMgYmVsb3cgdGhlIGF2ZXJhZ2Ugcm93IHByb2ZpbGUgaW4gY2FzZSBvZiAnKlJlYWRpbmdfTUMqJywgJypNaWx0b25fS2V5bmVzX01DKicgYW5kICcqSHVsbF9NQyonLCBhbmQgYWJvdmUgdGhlIGF2ZXJhZ2Ugcm93IHByb2ZpbGUgaW4gY2FzZSBvZiAnKlJlYWRpbmdfV0MqJywgJypNaWx0b25fS2V5bmVzX1dDKicgYW5kICcqSHVsbF9XQyonLg0KDQoNCg0KIyMjIyBDb2x1bW4gcHJvZmlsZXMNCg0KDQpDb25zaWRlcmluZyB0aGUgY29sdW1uIHN1bXMsIHdlIG9idGFpbiByZWxhdGl2ZSBmcmVxdWVuY2llcyBmb3IgdGhlIGNvbHVtbnMsDQp0aGF0IG1ha2UgdGhlIHByb2ZpbGUgZm9yIGVhY2ggY29sdW1uIHBvaW50IC4NCkZvciBleGFtcGxlIGZvciB0aGUgZmlyc3QgY29sdW1uOg0KYGBge3J9DQpOX3RvdGFsWzEsMV0vTl90b3RhbFs3LDFdDQpOX3RvdGFsWzIsMV0vTl90b3RhbFs3LDFdDQpOX3RvdGFsWzMsMV0vTl90b3RhbFs3LDFdDQpOX3RvdGFsWzQsMV0vTl90b3RhbFs3LDFdDQpOX3RvdGFsWzUsMV0vTl90b3RhbFs3LDFdDQpOX3RvdGFsWzYsMV0vTl90b3RhbFs3LDFdDQpgYGANCg0KKipNYXRyaXggb2YgY29sdW1uIHByb2ZpbGVzKiosIG9yIHByb2ZpbGVzIG9mIHNvY2lhbC1nZW9ncmFwaGljYWwgZ3JvdXBzIG9mIHRlZW5hZ2Vycw0KYGBge3J9DQojIHN3ZWVwIG9wZXJhdGlvbiBvbiBjb2x1bW5zDQpjb2wucHJvZmlsZXMgPSBzd2VlcChOLCAyLCAoY29sU3VtcyhOKSksICIvIikNCmNvbC5wcm9maWxlcw0KYGBgDQoNCkZyb20gdGhlIGNvbHVtbiBwcm9maWxlIHdlIGdyYXNwIHRoYXQgaW4gdGhlIGdyb3VwIG9mICcqUmVhZGluZ19NQyonIHRlZW5hZ2VycywgdGhlIGV4dGVuZGVyICcqYW5kIHRoYXQqJyB3YXMgdXNlZCBpbiAyJSwgJyphbmQgYWxsIHRoYXQqJyBpbiAyJSwgJyphbmQgc3R1ZmYqJyBpbiAyMSUsICcqYW5kIHRoaW5ncyonIGluIDE4JSwgJyphbmQgZXZlcnl0aGluZyonIGluIDEyJSBhbmQgJypvciBzb21ldGhpbmcqJyBpbiA0MiUgb2YgY2FzZXMuIA0KDQpXZSBhZ2FpbiBhZGQgdGhlIGF2ZXJhZ2UgY29sdW1uIHByb2ZpbGUgdG8gdGhlIHRhYmxlIGluIHRoZSBsYXN0IGNvbHVtbi4NCmBgYHtyfQ0KIyBjYWxjdWxhdGUgYXZlcmFnZXMNCmNvbC5hdmVyYWdlcyA8LSAgYyhOX3RvdGFsWzEsN10vbiwgTl90b3RhbFsyLDddL24sIE5fdG90YWxbMyw3XS9uLCBOX3RvdGFsWzQsN10vbiwgTl90b3RhbFs1LDddL24sIE5fdG90YWxbNiw3XS9uKQ0KIyBhcHBlbmQgYXZlcmFnZXMgdG8gbmV3IGNvbHVtbg0KY29sLnByb2ZpbGVzLmF2IDwtIGNiaW5kKGNvbC5wcm9maWxlcywgY29sLmF2ZXJhZ2VzKQ0KIyBuYW1lIGNvbHVtbg0KY29sbmFtZXMoY29sLnByb2ZpbGVzLmF2KSBbN10gPC0gImF2ZXJhZ2UgY29sdW1uIHByb2ZpbGUiDQoNCmNvbC5wcm9maWxlcy5hdg0KYGBgDQpGcm9tIHRoZSBhdmVyYWdlIGNvbHVtbiBwcm9maWxlIHdlIGNhbiByZWFkIHRoYXQgaXJyZXNwZWN0aXZlIG9mIHRoZSBzb2NpYWwtZ2VvZ3JhcGhpY2FsIGdyb3VwcywgMjMlIG9mIHRoZSBpbnN0YW5jZXMgYXJlICcqYW5kIHRoYXQqJywgMyUgJyphbmQgYWxsIHRoYXQqJywgMjIlICcqYW5kIHN0dWZmKicsIDEwJSAnKmFuZCB0aGluZ3MqJywgMTclICcqYW5kIGV2ZXJ5dGhpbmcqJywgMjElICcqb3Igc29tZXRoaW5nKicuDQpXZSBjYW4gY29tcGFyZSB0aGUgcHJvZmlsZXMgb2Ygc29jaWFsLWdlb2dyYXBoaWNhbCBncm91cHMgdG8gZWFjaCBvdGhlciBvciB0byB0aGUgYXZlcmFnZSBjb2x1bW4uIA0KDQpUaGUgdXNlIGluIHRoZSBncm91cCBvZiAnKkh1bGxfV0MqJyBlLmcuIGlzIGFib3ZlIHRoZSBhdmVyYWdlIGNvbHVtbiBmb3IgJyphbmQgdGhhdConIGFuZCAnKmFuZCBldmVyeXRoaW5nKicsIGFuZCBiZWxvdyB0aGUgYXZlcmFnZSBjb2x1bW4gZm9yIGV4dGVuZGVycyAnKmFuZCBhbGwgdGhhdConLCAnKmFuZCBzdHVmZionLCAnKmFuZCB0aGluZ3MqJywgJypvciBzb21ldGhpbmcqJy4NCg0KT25lIGNhbiBhcmd1ZSBmcm9tIHRoZSBwb2ludCBvZiB2aWV3IG9mIHRoZSByb3cgb3IgY29sdW1uIHByb2ZpbGVzIGFuZCByZWFjaCB0aGUgc2FtZSBjb25jbHVzaW9ucyAoc3ltbWV0cmljIHZpZXcpLiBIb3dldmVyLCB0aGUgZGF0YSB0YWJsZXMgYXJlIHNvbWV0aW1lcyBjb25zaWRlcmVkIGFzeW1tZXRyaWNhbGx5IGFzIGEgc2V0IG9mIHJvd3Mgb3Igc2V0IG9mIGNvbHVtbnMsIGRlcGVuZGluZyBvbiB0aGUgaW50ZXJlc3QuDQoNCiANClRoZSBpbmZvcm1hdGlvbiBmcm9tIGJvdGggdGFibGVzIGNhbiBiZSB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgKmNvbnRpbmdlbmN5IHJhdGlvcyogKGNmLiBHcmVlbmFjcmUgMjAwNzoxMSk6IHRob3NlIGFyZSBmb3JtZWQgZnJvbSBhIHJvdyBwcm9maWxlIGVsZW1lbnQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGF2ZXJhZ2Ugcm93IHByb2ZpbGUgb3IgZnJvbSBhIGNvbHVtbiBwcm9maWxlIGVsZW1lbnQgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGF2ZXJhZ2UgY29sdW1uIHByb2ZpbGUuIExvb2sgYXQgdGhlIGNvZGUgYmVsb3cgZm9yIHRoZSBkaWZmZXJlbnQgd2F5cyB0byBvYnRhaW4gdGhlIGVxdWFsIHJhdGlvcy4gSW4gdGhlIGludGVycHJldGF0aW9uLCB0aGUgcmF0aW8gb2YgJyphbmQgdGhpbmdzKicgYW5kICcqUmVhZGluZ19NQyonIGUuZy4gc2F5cyB0aGF0IHRoZSBjb21iaW5hdGlvbiBvY2N1cnMgMS43IHRpbWVzIGFzIG11Y2ggY29tcGFyZWQgdG8gdGhlIGF2ZXJhZ2UuDQoNCg0KYGBge3J9DQpzd2VlcChyb3cucHJvZmlsZXMsIDIscm93LmF2ZXJhZ2VzLCAiLyIpDQpzd2VlcChjb2wucHJvZmlsZXMsIDEsY29sLmF2ZXJhZ2VzLCAiLyIpDQpgYGANCg0KVGhlIGNhbGN1bGF0ZWQgcHJvZmlsZXMgYXJlIHJlbGV2YW50IGZvciB0aGUgZ2VvbWV0cmljYWwgcmVwcmVzZW50YXRpb24gYXMgdGhlIGZvbGxvd2luZyBxdW90ZXMgYnkgR3JlZW5hY3JlICgyMDA3KSBhcmUgcG9pbnRpbmcgdG93YXJkczoNCg0KDQo+UHJvZmlsZXMgY29uc2lzdGluZyBvZiBtIGVsZW1lbnRzIGNhbiBiZSBwbG90dGVkIGFzIHBvaW50cyBpbiBhbiBtLWRpbWVuc2lvbmFsIHNwYWNlLiBCZWNhdXNlIHRoZWlyIG0gZWxlbWVudHMgYWRkIHVwIHRvIDEsIHRoZXNlIHByb2ZpbGUgcG9pbnRzIG9jY3VweSBhIHJlc3RyaWN0ZWQgcmVnaW9uIG9mIHRoaXMgc3BhY2UuIFRoaXMgcmVnaW9uIGlzIGFuICht4oCTMSktZGltZW5zaW9uYWwNCnN1YnNwYWNlIGtub3duIGFzIGEgc2ltcGxleC4gVGhpcyBzaW1wbGV4IGlzIGVuY2xvc2VkIHdpdGhpbiB0aGUgZWRnZXMNCmpvaW5pbmcgYWxsIHBhaXJzIG9mIHRoZSBtIHVuaXQgdmVjdG9ycyBvbiB0aGUgbSBwZXJwZW5kaWN1bGFyIGF4ZXMuIFRoZXNlDQp1bml0IHBvaW50cyBhcmUgYWxzbyBjYWxsZWQgdGhlIHZlcnRpY2VzIG9mIHRoZSBzaW1wbGV4IG9yIHByb2ZpbGUgc3BhY2UuIFRoZQ0KY29vcmRpbmF0ZSBzeXN0ZW0gd2l0aGluIHRoaXMgc2ltcGxleCBpcyBrbm93biBhcyB0aGUgYmFyeWNlbnRyaWMgY29vcmRpbmF0ZQ0Kc3lzdGVtLiAoR3JlZW5hY3JlIDIwMDc6MTYpDQoNCg0KPlNpbXBsZXg6IGEgdHJpYW5nbGUgaW4gdHdvIGRpbWVuc2lvbnMsIGEgdGV0cmFoZWRyb24gaW4gdGhyZWUgZGltZW5zaW9ucywNCmFuZCBnZW5lcmFsaXphdGlvbnMgb2YgdGhlc2UgZ2VvbWV0cmljIGZpZ3VyZXMgaW4gaGlnaGVyIGRpbWVuc2lvbnM7IGluIENBIEotZGltZW5zaW9uYWwgcHJvZmlsZXMgbGllIGluc2lkZSBhIHNpbXBsZXggZGVmaW5lZCBieSBKIHZlcnRpY2VzIGluIChKIOKIkiAxKS0NCmRpbWVuc2lvbmFsIHNwYWNlLiAoR3JlZW5hY3JlIDIwMDc6MjY1Zi4pDQoNCg0KIyMjIDEuMy4yIE1hc3NlcyBvZiByb3dzIGFuZCBjb2x1bW5zDQoNClRoZSBuZXh0IHN0ZXAgaXMgdG8gbG9vayBhdCB0aGUgY29uY2VwdCBvZiBtYXNzZXMgd2hpY2ggYXJlIHVzZWQgYXMgd2VpZ2h0cyBpbiBjb3JyZXNwb25kZW5jZSBhbmFseXNpcy4gDQoNCj4gIFJvdyBzdW1zIG9yIGNvbHVtbiBzdW1zIGRpdmlkZWQgYnkgdGhlIHRvdGFsIGZyZXF1ZW5jeSBvZiB0aGUgY29udGluZ2VuY3kgdGFibGUuICANCj4gKGNmLiBIYXV0eiAmIEJsZXVlbCAyMDE4OjIyMSkNCg0KVGhlIHN1bSBvZiByb3dzIGFuZCBjb2x1bW5zIG9mIHRoZSB0YWJsZSB3aXRoIHRoZSBwcm9wb3J0aW9ucyBpcyByZWZlcnJlZCB0byBhcyBtYXNzLiANCg0KV2UgY2FsY3VsYXRlIHRoZSBjb2x1bW4gbWFzc2VzIGBjb2x1bW4ubWFzc2VzYCBieSBhcHBseWluZ2Bjb2xTdW1zKClgdG8gdGhlIHRhYmxlIG9mIHByb3BvcnRpb25zLiAgDQpgYGB7cn0NClANCmNvbHVtbi5tYXNzZXMgPSBjb2xTdW1zKFApDQpjb2x1bW4ubWFzc2VzDQpgYGANCg0KSW4gdGhlIHNhbWUgd2F5LCB3ZSBjYWxjdWxhdGUgcm93IG1hc3NlcyBgcm93Lm1hc3Nlc2AgYnkgdXNpbmcgYHJvd1N1bXMoKWA6DQoNCmBgYHtyfQ0KDQpyb3cubWFzc2VzID0gcm93U3VtcyhQKQ0Kcm93Lm1hc3Nlcw0KYGBgDQoNCkluIHRoZSBuZXh0IHN0ZXAsIHdlIHdhbnQgdG8gYWRkIHRoZSBtYXNzZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJvZmlsZXMuIFRoZSByb3cgcHJvZmlsZSBhbHJlYWR5IGNvbnRhaW5zIHRoZSBhdmVyYWdlIHJvdyBwcm9maWxlIGluIHRoZSBsYXN0IHJvdywgYW5kIHdlIHdhbnQgdG8gYWRkIHRoZSByb3cgbWFzcyBhcyBhIG5ldyBsYXN0IGNvbHVtbi4NClRoZSBjb2x1bW4gcHJvZmlsZSwgb24gdGhlIG90aGVyIGhhbmQsIGNvbnRhaW5zIHRoZSBhdmVyYWdlIGNvbHVtbiBwcm9maWxlIGFzIGEgbGFzdCBjb2x1bW4gYW5kIHdlIHdhbnQgdG8gYWRkIHRoZSBjb2x1bW4gbWFzc2VzIGFzIHRoZSBsYXN0IHJvdyBpbiB0aGUgdGFibGUuDQoNCkluIG9yZGVyIHRvIGFycml2ZSBhdCB0aGUgc2FtZSBudW1iZXIgb2Ygcm93cyBhbmQgY29sdW1ucyB3ZSBoYXZlIHRvIGFkZCBOQSB2YWx1ZXMsIGJlY2F1c2Ugd2UgZG9uJ3QgY2FsY3VsYXRlIGEgbWFzcyB2YWx1ZSBmb3IgdGhlIGF2ZXJhZ2Ugcm93IHByb2ZpbGUgYW5kIGF2ZXJhZ2UgY29sdW1uIHByb2ZpbGUuDQoNCiANCmBgYHtyfQ0KDQpyb3cubWFzc2VzLm5hIDwtYyhyb3cubWFzc2VzWzA6Nl0sTkEpDQpyb3cubWFzc2VzLm5hDQpjb2x1bW4ubWFzc2VzLm5hIDwtIGMoY29sdW1uLm1hc3Nlc1swOjZdLCBOQSkNCmNvbHVtbi5tYXNzZXMubmENCmBgYA0KDQpSZW1lbWJlciwgYXMgdGhlIGxhc3Qgcm93IG9mIHRoZSByb3cgcHJvZmlsZSB3ZSBhZGRlZCB0aGUgY29sdW1uIHN1bXMgb2YgdGhlIGNvcnJlc3BvbmRlbmNlIG1hdHJpeCAoUCk7IHRoZSBjb2x1bW4gc3VtcyBtYWtlIHRoZSBhdmVyYWdlIHJvdyBwcm9maWxlIGFuZCBhcmUgYWN0dWFsbHkgaWRlbnRpY2FsIHRvIHRoZSBjb2x1bW4gbWFzc2VzLiANCg0KYGBge3J9DQpyb3cuYXZlcmFnZXMNCmFzLm51bWVyaWMoY29sdW1uLm1hc3Nlc1sxOjZdKQ0KYGBgDQpBbHNvLCB0aGUgdmFsdWVzIG9mIHRoZSBhdmVyYWdlIGNvbHVtbiBwcm9maWxlIGFyZSB0aGUgc2FtZSBhcyB0aGUgcm93IG1hc3NlczoNCmBgYHtyfQ0KY29sLmF2ZXJhZ2VzDQphcy5udW1lcmljKHJvdy5tYXNzZXNbMTo2XSkNCmBgYA0KDQoNClRoZSBhdmVyYWdlIHJvdyBwcm9maWxlIGlzIHRoZSAqKmNlbnRyb2lkKiogb2YgdGhlIHJvdyBwb2ludHMgaW4gdGhlIGNvcnJlc3BvbmRlbmNlIHNwYWNlLiBUaGlzIGRvZXMgbm90IG1lYW4gdGhlICJnZW9ncmFwaGljIiBjZW50ZXIsIGJ1dCBhIHdlaWdodGVkIGF2ZXJhZ2Ugc28gdGhhdCB0aGUgY2VudHJvaWQgaXMgY2xvc2VyIHRvIHBvaW50cyB3aXRoIGdyZWF0ZXIgd2VpZ2h0LiANCg0KPiBDZW50cm9pZDogdGhlIHdlaWdodGVkIGF2ZXJhZ2UgcG9pbnQgKEdyZWVuYWNyZSAyMDA3OjI2MykNCg0KRm9yIHRoZSBnZW9tZXRyaWNhbCByZXByZXNlbnRhdGlvbiB0aGlzIG1lYW5zOg0KDQo+IFRoZXJlIGlzIGFuIGVxdWl2YWxlbnQgd2F5IG9mIHRoaW5raW5nIGFib3V0IHRoZSBwb3NpdGlvbnMgb2YgdGhlIHByb2ZpbGUgcG9pbnRzIGluIHRoZSBwcm9maWxlIHNwYWNlIHdoaWNoIGlzIGJhc2VkIG9uIHRoZSBub3Rpb24gb2YgYSB3ZWlnaHRlZCBhdmVyYWdlLCBvciBjZW50cm9pZCwgb2YgYSBzZXQgb2YgcG9pbnRzLiBJbiB0aGUgY2FsY3VsYXRpb24gb2YgYW4gb3JkaW5hcnkgKHVud2VpZ2h0ZWQpIGF2ZXJhZ2UsIGVhY2ggcG9pbnQgcmVjZWl2ZXMgZXF1YWwgd2VpZ2h0LiBBIHdlaWdodGVkIGF2ZXJhZ2UsIG9uIHRoZSBvdGhlciBoYW5kLCBhbGxvd3MgZGlmZmVyZW50IHdlaWdodHMgdG8gYmUgYXNzb2NpYXRlZCB3aXRoIGVhY2ggcG9pbnQuIFdoZW4gcG9pbnRzIGFyZSB3ZWlnaHRlZCBkaWZmZXJlbnRseSwgdGhlbiB0aGUgY2VudHJvaWQgZG9lcyBub3QgbGllIGV4YWN0bHkgYXQgdGhlIOKAnGdlb2dyYXBoaWNhbOKAnSBjZW50cmUgb2YgdGhlIGNsb3VkIG9mIHBvaW50cywgYnV0IHRlbmRzIHRvIGxpZSBpbiBhIHBvc2l0aW9uIGNsb3NlciB0byB0aGUgcG9pbnRzIHdpdGggaGlnaGVyIHdlaWdodC4oY2YuIEdyZWVuYWNyZSAyMDA3OjE3KQ0KDQoNCldlIGFyZSBub3cgaW4gdGhlIHBvc2l0aW9uIHRvIGFkZCBtYXNzZXMgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcHJvZmlsZXM6DQpgYGB7cn0NCnJvdy5wcm9maWxlcy5hdi5tYXNzIDwtIGNiaW5kKHJvdy5wcm9maWxlcy5hdixyb3cubWFzc2VzLm5hKQ0KY29sbmFtZXMocm93LnByb2ZpbGVzLmF2Lm1hc3MpIFs3XSA8LSAicm93Lm1hc3NlcyIgDQpyb3cucHJvZmlsZXMuYXYubWFzcw0KYGBgDQoNCg0KVGhlIG1hc3NlcyBvZiB0aGUgcm93cyB0b2dldGhlciBmb3JtIHRoZSBhdmVyYWdlIGNvbHVtbiBwcm9maWxlLiBUaGlzIGlzIHRoZSBjZW50cm9pZCBvZiB0aGUgY29sdW1uIHBvaW50cyBpbiB0aGUgY29ycmVzcG9uZGVuY2Ugc3BhY2UuIA0KV2UgYWxzbyBhcHBlbmQgdGhlIGNvbHVtbiBtYXNzZXMgKHRoZSByb3cgc3VtcyBvZiB0aGUgY29ycmVzcG9uZGVuY2UgbWF0cml4IFApIHRvIHRoZSBjb2x1bW4gcHJvZmlsZS4NCmBgYHtyfQ0KY29sLnByb2ZpbGVzLmF2Lm1hc3MgPC0gcmJpbmQoY29sLnByb2ZpbGVzLmF2LCBjb2x1bW4ubWFzc2VzLm5hKQ0Kcm93bmFtZXMoY29sLnByb2ZpbGVzLmF2Lm1hc3MpWzddIDwtICJjb2wubWFzc2VzIg0KY29sLnByb2ZpbGVzLmF2Lm1hc3MNCmBgYA0KDQoNClZhbHVlcyBvZiB0aGUgcm93IHJlcHJlc2VudGF0aW9uIGNhbiBiZSBzZWVuIGFzIHdlaWdodGVkIHZhbHVlcyBvZiB0aGUgY29sdW1uIHJlcHJlc2VudGF0aW9uIGFuZCB0aGUgdmFsdWVzIG9mIHRoZSBjb2x1bW4gcmVwcmVzZW50YXRpb24gY2FuIGJlIHNlZW4gYXMgd2VpZ2h0ZWQgdmFsdWVzIG9mIHRoZSByb3cgcmVwcmVzZW50YXRpb24uIA0KRm9yIGlsbHVzdHJhdGlvbiwgY29uc2lkZXIgdGhhdCBhIGNlbGwgdmFsdWUgaXMgbXVsdGlwbGllZCBieSB0aGUgbWFzcyBhbmQgZGl2aWRlZCBieSB0aGUgYXZlcmFnZSByb3cgKHdpdGhpbiBhIHByb2ZpbGUpLg0KDQoNCkFzIGFuIGV4YW1wbGUgd2UgbGlrZSB0byBnbyBmcm9tIHJvdyBwcm9maWxlIFsxLDFdIHRvIGNvbHVtbiBwcm9maWxlIFsxLDFdLg0KVG8gZG8gc28gd2UgbXVsdGlwbHkgdGhlIGNlbGwgb2YgdGhlIHJvdyBwcm9maWxlIGJ5IHRoZSByb3cgbWFzcyBhbmQgZGl2aWRlIGJ5IHRoZSBhdmVyYWdlIHJvdy4gVGhpcyByZXN1bHRzIGluIHRoZSBjZWxsIG9mIHRoZSBjb2x1bW4gcHJvZmlsZS4NCihBbHRlcm5hdGl2ZTogY2VsbCBvZiB0aGUgcm93IHByb2ZpbGUgbXVsdGlwbGllZCBieSByb3cgbWFzcyBkaXZpZGVkIGJ5IGNvbHVtbiBtYXNzIG9mIHRoZSBjb2x1bW4gcHJvZmlsZSkNCiQkMC4wMjE5NzgwMiowLjIzNjM2MzYvMC4yMTk0ODA1ID0gMC4wMjM2Njg2NCQkDQoNCg0KDQpWaWV3IG9mIGJvdGggcHJvZmlsZXMNCmBgYHtyfQ0Kcm93LnByb2ZpbGVzLmF2Lm1hc3MNCmNvbC5wcm9maWxlcy5hdi5tYXNzDQpgYGANCg0KQ2FsY3VsYXRpb24gd2l0aCByZWxldmFudCBjb2x1bW5zIG9mIHRoZSBwcm9maWxlDQpgYGB7cn0NCnJvdy5wcm9maWxlcy5hdi5tYXNzWzEsMV0qcm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw3XS9yb3cucHJvZmlsZXMuYXYubWFzc1s3LDFdDQpyb3cucHJvZmlsZXMuYXYubWFzc1sxLDFdKnJvdy5wcm9maWxlcy5hdi5tYXNzWzEsN10vY29sLnByb2ZpbGVzLmF2Lm1hc3NbNywxXQ0KY29sLnByb2ZpbGVzLmF2Lm1hc3NbMSwxXQ0KYGBgDQoNClRvIHByYWN0aXNlIGEgbGl0dGxlIGJpdCBtb3JlLCBsZXQncyBhc3N1bWUgd2Ugd2FudCB0byBnbyBmcm9tIGNvbHVtbiBwcm9maWxlIFsxLDFdIHRvIHJvdyBwcm9maWxlIFsxLDFdOiBUaGVyZWZvcmUsIHRoZSBjZWxsIG9mIHRoZSBjb2x1bW4gcHJvZmlsZSBpcyBtdWx0aXBsaWVkIGJ5IHRoZSBjb2x1bW4gbWFzcyBhbmQgZGl2aWRlZCBieSB0aGUgYXZlcmFnZSBjb2x1bW4sIHNvIHdlIG9idGFpbiB0aGUgY2VsbCBvZiB0aGUgcm93IHByb2ZpbGUuDQooQWx0ZXJuYXRpdmVseSwgY2VsbCBvZiB0aGUgY29sdW1uIHByb2ZpbGUgbXVsdGlwbGllZCBieSBjb2x1bW4gbWFzcyBkaXZpZGVkIGJ5IHJvdyBtYXNzKQ0KDQokJDAuMDIzNjY4NjQqMC4yMTk0ODA1LzAuMjM2MzYzNiA9MC4wMjE5NzgwMiQkDQoNCg0KVGhlIGNvZGUgYmVsb3cgaWxsdXN0cmF0ZXMgdGhlIGNhbGN1bGF0aW9uLiANCmBgYHtyfQ0KY29sLnByb2ZpbGVzLmF2Lm1hc3NbMSwxXSpjb2wucHJvZmlsZXMuYXYubWFzc1s3LDFdL2NvbC5wcm9maWxlcy5hdi5tYXNzWzEsN10NCmNvbC5wcm9maWxlcy5hdi5tYXNzWzEsMV0qY29sLnByb2ZpbGVzLmF2Lm1hc3NbNywxXS9yb3cucHJvZmlsZXMuYXYubWFzc1sxLDddDQpyb3cucHJvZmlsZXMuYXYubWFzc1sxLDFdDQpgYGANCg0KDQpUaGUgc2FtZSBob2xkcyBmb3IgYXZlcmFnZSBwcm9maWxlcyBvZiByb3dzIGFuZCBjb2x1bW5zLCBidXQgZmlyc3QgbGV0J3MgdmlldyBib3RoIHByb2ZpbGVzIGFnYWluLg0KYGBge3J9DQpyb3cucHJvZmlsZXMuYXYubWFzcw0KY29sLnByb2ZpbGVzLmF2Lm1hc3MNCmBgYA0KDQpUbyBjYWxjdWxhdGUgdGhlIDFzdCB2YWx1ZSBvZiB0aGUgYXZlcmFnZSByb3cgcHJvZmlsZSwgd2UgbXVsdGlwbHkgdGhlIGNvbXBvbmVudHMgZnJvbSB0aGUgdGFibGUgb2YgdGhlIHJvdyBwcm9maWxlIGluIHRoZSAxc3QgY29sdW1uIGJ5IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBvZiB0aGUgYXZlcmFnZSBjb2x1bW4gcHJvZmlsZSBhbmQgc3VtIHRoZW0gdXA6DQoNCiQkKDAuMDIxOTc4MDIqMC4yMzYzNjM2NCkgKyAoMC4xMzc5MzEwMyowLjAzNzY2MjM0KSArICgwLjIwOTMwMjMzKjAuMjIzMzc2NjIpICsgKDAuMzgwOTUyMzgqIDAuMTA5MDkwOTEpICsgKDAuMTUyMTczOTEqMC4xNzkyMjA3OCkgKyAoMC40MzYzNjM2NCowLjIxNDI4NTcxKSA9IDAuMjE5NDgwNTIJJCQNCmBgYHtyfQ0Kc3VtKHJvdy5wcm9maWxlcy5hdi5tYXNzWzE6NiAsMV0qY29sLnByb2ZpbGVzLmF2Lm1hc3NbMTo2LDddKQ0Kcm93LnByb2ZpbGVzLmF2Lm1hc3NbNywxXQ0KYGBgDQoNCg0KVG8gcHJhY3Rpc2UsIGxldCdzIGNhbGN1bGF0ZSB0aGUgMXN0IHZhbHVlIG9mIHRoZSBhdmVyYWdlIGNvbHVtbiBwcm9maWxlLiBUaGVyZWZvcmUsIGNvbXBvbmVudHMgZnJvbSB0aGUgdGFibGUgb2YgdGhlIDFzdCByb3cgY29sdW1uIHByb2ZpbGUgYXJlIG11bHRpcGxpZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzIG9mIHRoZSBhdmVyYWdlIHJvdyBwcm9maWxlIGFuZCBzdW1tZWQgdXANCg0KJCQoMC4wMjM2Njg2NCowLjIxOTQ4MDUyKSArICgwLjQ2NjY2NjY3KjAuMTM2MzYzNjQpICsgKDAuMDYyOTM3MDYqMC4xODU3MTQyOSkgKyAoMC41MDAwMDAwMCowLjExNDI4NTcxKSArICgwLjA3MjQ2Mzc2OCowLjE3OTIyMDc4KSArICgwLjUxOTY4NTA0KjAuMTY0OTM1MDYpID0gMC4yMzYzNjM2JCQNCg0KDQpUaGUgY2FsY3VsYXRpb24gaW4gUiBsb29rcyB0aGUgZm9sbG93aW5nOg0KYGBge3J9DQpzdW0oY29sLnByb2ZpbGVzLmF2Lm1hc3NbMSwxOjZdKnJvdy5wcm9maWxlcy5hdi5tYXNzWzcsMTo2XSkNCmNvbC5wcm9maWxlcy5hdi5tYXNzWzEsN10NCmBgYA0KDQoNCkZvciB0aGUgdmFsaWRhdGlvbiBvZiBjYWxjdWxhdGVkIHJvdyBhbmQgY29sdW1uIG1hc3Nlcywgc2VlIFNlYy4gNy4xLg0KDQoNCiMgMi4gRXhwZWN0ZWQgUHJvcG9ydGlvbnMgYW5kIEZyZXF1ZW5jaWVzDQoNCiMjIDIuMSBFeHBlY3RlZCBwcm9wb3J0aW9ucyAoZXhwZWN0ZWQgcHJvcG9ydGlvbnMpIEUNCg0KUmVmZXJyaW5nIGJhY2sgdG8gVGFibGUgUCB3aXRoIHRoZSBwcm9wb3J0aW9ucywgZS5nLiAwLjUlIG9mIHRoZSBleGFtcGxlcyBjb3JyZXNwb25kIHRvIHRoZSBleHRlbmRlciAnKmFuZCB0aGF0KicgaW4gdGhlIHNvY2lhbC1nZW9ncmFwaGljYWwgZ3JvdXAgICcqUmVhZGluZ19NQyonLg0KDQoNCmBgYHtyfQ0KUA0KDQpgYGANCg0KDQpGb3IgYW4gZXN0aW1hdGlvbiBhYm91dCB3aGV0aGVyIHRoaXMgdmFsdWUgaXMgbGFyZ2Ugb3Igc21hbGwsIHdlIGNhbiBjYWxjdWxhdGUgdGhlIHZhbHVlIHdlIGV4cGVjdCBpZiB3ZSBhc3N1bWUgdGhhdCB0aGVyZSBpcyBubyByZWxhdGlvbnNoaXAgYmV0d2VlbiBleHRlbmRlciBhbmQgc29jaWFsLWdlb2dyYXBoaWNhbCBncm91cC4gDQoNCkZyb20gdGhlIHN1bXMgY2FsY3VsYXRlZCwgd2Uga25vdyB0aGF0IDIzJSBvZiB0aGUgZXh0ZW5kZXJzIGFyZSAnKmFuZCB0aGF0KicgKHJvdyBtYXNzKSBhbmQgdGhhdCAyMSUgYXJlIGluIHRoZSBzb2NpYWwtZ2VvZ3JhcGhpY2FsIGdyb3VwICcqUmVhZGluZyBNQyonIChjb2x1bW4gbWFzcykuIElmIHRoZXJlIGlzIG5vIHJlbGF0aW9uc2hpcCBiZXR3ZWVuIGV4dGVuZGVyIGFuZCBzb2NpYWwtZ2VvZ3JhcGhpY2FsIGdyb3VwLCB3ZSBleHBlY3QgdGhhdCAyMSUgb2YgMjMlIG9mIGV4YW1wbGVzICgNCjAuMDUxID0gNS4xJSkgYXJlIHRoZSBleHRlbmRlciAnKmFuZCB0aGF0KicgaW4gdGhlIHNvY2lhbC1nZW9ncmFwaGljYWwgZ3JvdXAgJypSZWFkaW5nIE1DKicuIA0KDQoNCmBgYHtyfQ0Kcm93Lm1hc3Nlcw0KY29sdW1uLm1hc3Nlcw0KYGBgDQoNClRoZSBleHBlY3RlZCBwcm9wb3J0aW9uIGlzIGNhbGN1bGF0ZWQgYnkgbXVsdGlwbHlpbmcgdGhlIGNvbHVtbiBhbmQgcm93IG1hc3NlczogDQokJDAuMjM2MzYzNjQqMC4yMTk0ODA1ID0gMC4wNTE4NzcyMSAkJA0KDQpgYGB7cn0NCmNvbHVtbi5tYXNzZXNbMV0gKiByb3cubWFzc2VzWzFdIA0KYGBgDQoNCg0KDQpgJW8lYCBpcyB1c2VkIHRvIGNyZWF0ZSBhIHRhYmxlIHNvIHRoYXQgZm9yIGVhY2ggY2VsbCB0aGUgY29ycmVzcG9uZGluZyByb3cgbWFzc2VzIGFuZCBjb2x1bW4gbWFzc2VzIGFyZSBtdWx0aXBsaWVkLiBUaGUgcmVzdWx0IGlzIHRhYmxlIGBFYA0KYGBge3J9DQpFID0gcm93Lm1hc3NlcyAlbyUgY29sdW1uLm1hc3Nlcw0KRQ0KYGBgDQoNCg0KDQojIyAyLjIgRXhwZWN0ZWQgRnJlcXVlbmNpZXMgDQoNCj4gRnJlcXVlbmNpZXMgdG8gYmUgZXhwZWN0ZWQgaWYgdGhlcmUgaXMgbm8gY29ycmVsYXRpb24gYmV0d2VlbiB0aGUgY2hhcmFjdGVyaXN0aWNzIHVuZGVyIGNvbnNpZGVyYXRpb24gKG51bGwgaHlwb3RoZXNpcyBvZiBpbmRlcGVuZGVuY2UsIGhvbW9nZW5laXR5IGFzc3VtcHRpb24pLg0KKGNmLiBIYXV0eiAmIEJsZXVlbCAyMDE4OiBTLiAyMjApDQoNCg0KUmVsYXRpdmUgdG8gdGhlIHRvdGFsIGZyZXF1ZW5jeSBvZiBuIGV4YW1wbGVzLCBlYWNoIG9mIHdoaWNoIGhhcyBhIHByb2JhYmlsaXR5IG9mIDAuMDUxODc3MjEgb2YgZXhoaWJpdGluZyB0aGUgY29tYmluYXRpb24gb2YgJyphbmQgdGhhdConIGFuZCAnKlJlYWRpbmdfTUMqJywgbiogdGhlIHByb2JhYmlsaXR5IG9mIGV4YW1wbGVzIGFyZSBleHBlY3RlZC4NCg0KV2Ugb2J0YWluIHRoZSBleHBlY3RlZCBmcmVxdWVuY2llcyBieSBtdWx0aXBseWluZyB0aGUgZXhwZWN0ZWQgcHJvcG9ydGlvbnMgYnkgdGhlIHRvdGFsIGZyZXF1ZW5jeS4NCg0KYGBge3J9DQpFdyA9IEUqbg0KRXcNCmBgYA0KDQpBbHRlcm5hdGl2ZWx5LCB3ZSBjYW4gYWxzbw0KY2FsY3VsYXRlIHRoZSBleHBlY3RlZCBmcmVxdWVuY3kgZm9yIGNlbGwgaWogYXMgd2UgcHJhY3Rpc2Ugbm93Lg0KDQoNCldlIG11bHRpcGx5IHJvdyBzdW0gaSBmcm9tIHRhYmxlIE4gd2l0aCB0aGUgY29sdW1uIHN1bSBqIGZyb20gdGFibGUgTg0KYW5kIGRpdmlkZSBieSBuLiANCg0KDQpgYGB7cn0NCnJvd1N1bXMoTikgJW8lIGNvbFN1bXMoTikvbg0KYGBgDQoNCg0KDQojIDMuIENoaS1zcXVhcmVkIHN0YXRpc3RpY3MgYW5kIGRpc3RhbmNlcyANCg0KIyMgMy4xIENoaS1zcXVhcmUgc3RhdGlzdGljDQoNCldlIGhhdmUgYXBwbGllZCB0aGUgc3RhdGlzdGljYWwgdGVzdCBiZWZvcmUgdXNpbmcgdGhlIGBjaGlzcSgpYGZ1bmN0aW9uLCBidXQgbm93LCB3ZSB3aWxsIHNlZSBob3cgdG8gY2FsY3VsYXRlIGl0IG91cnNlbHZlcy4NCg0KPiBjaGktc3F1YXJlIHN0YXRpc3RpYyDigJQgdGhlIHN0YXRpc3RpYyB1c2VkIGNvbW1vbmx5IGZvciB0ZXN0aW5nIHRoZSBpbmRlcGVkZW5jZSBtb2RlbCBmb3IgYSBjb250aW5nZW5jeSB0YWJsZTsgY2FsY3VsYXRlZCBhcyB0aGUgc3VtIG9mIHNxdWFyZWQgZGlmZmVyZW5jZXMgYmV0d2VlbiBvYnNlcnZlZCBmcmVxdWVuY2llcyBhbmQgZnJlcXVlbmNpZXMgZXhwZWN0ZWQgYWNjb3JkaW5nIHRvIHRoZSBtb2RlbCwgZWFjaCBzcXVhcmVkIGRpZmZlcmVuY2UgYmVpbmcgZGl2aWRlZCBieSB0aGUgY29ycmVzcG9uZGluZyBleHBlY3RlZA0KZnJlcXVlbmN5LiAoR3JlZW5hY3JlIDIwMDc6MjY0KQ0KDQpUbyBjYWxjdWxhdGUgdGhlIHZhbHVlLCB3ZSBzcXVhcmUgdGhlIGRpZmZlcmVuY2Ugb2YgdGhlIGFic29sdXRlIG9ic2VydmVkIGFuZCBleHBlY3RlZCBmcmVxdWVuY2llcywgZGl2aWRlIGJ5IHRoZSBleHBlY3RlZCBmcmVxdWVuY2llcyBhbmQgc3VtIGFsbCB2YWx1ZXMuDQoNCg0KJCRcY2hpXjIgPSBcc3VtIFxmcmFjIHsob2JzZXJ2ZWQgLSBleHBlY3RlZCleMn17ZXhwZWN0ZWR9JCQgDQoNCmNmLiBHcmVlbmFjcmUgKDIwMDc6MjcpDQoNCg0KDQpJbiB0aGUgZm9ybXVsYSBiZWxvdywgd2UgaGF2ZSB0byBpbnNlcnQgZnJlcXVlbmNpZXMgZnJvbSB0YWJsZSBOIGFuZCBleHBlY3RlZCBmcmVxdWVuY2llcyBmcm9tIHRhYmxlIEV3Lg0KDQokJCBcY2hpXjIgPSBcc3VtXntJfV97aT0xfSBcc3VtXntKfV97aj0xfVxmcmFjeyhuX3tpan0tIFxoYXR7bn1fe2lqfSleMn17XGhhdHtufV97aWp9fSA9IFxmcmFjIHsoNC0zOS45NDU0NTUpXjJ9ezM5Ljk0NTQ1NX0rIFxmcmFjeyg0OSAtIDI0LjgxODE4MileMn17MjQuODE4MTgyfSsuLi4kJA0KY2YuIEJsYXNpdXMgMjAwMToyNS4gKG4gd2l0aCBoYXQgY29ycmVzcG9uZHMgdG8gZXhwZWN0ZWQgZnJlcXVlbmN5KSANCg0KDQpgYGB7cn0NCmNoaTIgICAgICAgICA8LSBzdW0oKE4tRXcpXjIvRXcpDQpjaGkyDQpgYGANCg0KVGhlIGxhcmdlciB0aGUgQ2hpLXNxdWFyZWQgdmFsdWUgKG51bWJlciBvZiByb3dzIGFuZCBjb2x1bW5zIGNvbnN0YW50KSwgdGhlIGxhcmdlciB0aGUgd2VpZ2h0ZWQgc3F1YXJlZCBkZXZpYXRpb25zIGJldHdlZW4gb2JzZXJ2ZWQgYW5kIGV4cGVjdGVkIHZhbHVlcy4gVGhpcyBtZWFucyB3ZSBhcmUgbGVzcyBjb25maWRlbnQgdGhhdCB0aGUgaHlwb3RoZXNpcyBvZiBpbmRlcGVuZGVuY2UgaXMgdHJ1ZSBhbmQgdGhlIG1vcmUgbGlrZWx5IHdlIGFyZSBnb2luZyB0byByZWplY3QgaXQuDQoNCg0KV2hhdCBpcyB0aGUgbWF4aW11bSB2YWx1ZSBvZiBDaGktc3F1YXJlPw0KDQo+VGhlIG1heGltdW0gQ2hpLXNxdWFyZSB2YWx1ZSBpcyBlcXVhbCB0byB0aGUgbnVtYmVyIG9mIGNhc2VzIG11bHRpcGxpZWQgYnkgdGhlIG1pbmltdW0gb2Ygcm93cyBhbmQgY29sdW1ucyBtaW51cyBvbmUuDQoNCihjZi4gQmxhc2l1cyAyMDAxOjI2KQ0KDQpgYGB7cn0NCm5yb3coTikNCm5jb2woTikNCm4qKG5jb2woTiktMSkNCg0KYGBgDQpXZSBjYW4gY2hlY2sgdGhlIHJlc3VsdCBvZiBvdXIgY2FsY3VsYXRpb24gd2l0aCB0aGUgaW1wbGVtZW50ZWQgZnVuY3Rpb246IGBjaGlzcS50ZXN0KClgIHdoaWNoIHdpbGwgYWxzbyBwcm92aWRlIHRoZSBwLXZhbHVlLg0KDQpgYGB7cn0NCngyX04udGVzdCA8LSBjaGlzcS50ZXN0KE4sIGNvcnJlY3QgPSBGKQ0KeDJfTi50ZXN0DQoNCmBgYA0KQmVjYXVzZSBvZiB0aGUgcHJvYmxlbXMgZW1lcmdpbmcgZm9yIENoaS1zcXVhcmVkIHRlc3QgZnJvbSB0aGUgZGVwZW5kZW5jZSBvbiB0aGUgbnVtYmVyIG9mIGNhc2VzIGFuZCBmcm9tIHRoZSBpbXBhY3Qgb2YgdGhlIHRhYmxlIHNpemUsIGNvZWZmaWNpZW50cyBsaWtlIENyYW1lcidzIFYgaGF2ZSBiZWVuIHByb3Bvc2VkLiBUaGUgZm9ybXVsYSBpcyB0aGUgZm9sbG93aW5nOg0KDQokJCBWID0gXHNxcnR7XGZyYWN7XGNoaV4yfXtuICogKG1pbihJLTEsIEotMSl9fSAkJA0KY2YuIEJsYXNpdXMgMjAwMToyNi4NCg0KQ3JhbWVyJ3MgViBjYW4gdGFrZSB2YWx1ZXMgYmV0d2VlbiAwIChubyBjb3JyZWxhdGlvbikgYW5kIDEgKHBlcmZlY3QgIGNvcnJlbGF0aW9uKS4NCmBgYHtyfQ0KbnJvdyhOKQ0KbmNvbChOKQ0KKG1pbihkaW0oZXh0ZW5kZXJzZGF0YSkpLTEpDQoNCmNoaTINCkNyYW1lcnNWPC1zcXJ0KHgyX04udGVzdCRzdGF0LyhzdW0oZXh0ZW5kZXJzZGF0YSkgKiAobWluKGRpbShleHRlbmRlcnNkYXRhKSktMSkpKQ0KQ3JhbWVyc1YNCmBgYA0KSW4gY29ycmVzcG9uZGVuY2UgYW5hbHlzaXMsIGEgY29lZmZpY2llbnQgaXMgZGV0ZXJtaW5lZCBhbmFsb2dvdXNseSB0byBDcmFtZXIncyBWLiANCg0KDQoNCiMjIyAzLjEuMSAgKlRvdGFsIEluZXJ0aWEqDQoNClRvIGRldGVybWluZSB0aGUgdG90YWwgaW5lcnRpYSAoaG93IG11Y2ggdmFyaWF0aW9uIGlzIHByZXNlbnQgaW4gdGhlIGRhdGEpLCB0aGUgQ2hpLXNxdWFyZWQgdmFsdWUgaXMgZGl2aWRlZCBieSB0aGUgdG90YWwgc3VtIG9mIHRoZSB0YWJsZSBvciBncmFuZCB0b3RhbC4NCg0KDQokJFxsYW1iZGFfRyA9ICBcZnJhY3tcY2hpXjJ9e259PSAgXGZyYWN7Mzg0LjExNTV9ezc3MH0kJA0KDQpgYGB7cn0NCnRvdGFsLmluZXJ0aWEgPSBjaGkyL24NCnRvdGFsLmluZXJ0aWENCg0KYGBgDQoNCg0KPlN1bSBvZiBzcXVhcmVkIENoaV4yXiBkaXN0YW5jZXMgb2YgYSBzZXQgb2YgcHJvZmlsZXMgdG8gdGhlaXIgY2VudHJvaWQgd2VpZ2h0ZWQgYnkgdGhlIG1hc3NlcyBvZiB0aGUgcHJvZmlsZXMuDQooSGF1dHogJiBCbGV1ZWwgMjAxODoyMjIpDQoNCkFsdGVybmF0aXZlbHksIHRoZSB0b3RhbCBpbmVydGlhIHdlaWdodCBpcyBhbHNvIG9idGFpbmVkIGZyb20gdGhlIHNxdWFyZWQgZGV2aWF0aW9ucyBvZiBleHBlY3RlZCBhbmQgb2JzZXJ2ZWQgcHJvZmlsZSBlbGVtZW50cywgd2VpZ2h0ZWQgYnkgdGhlIGNvcnJlc3BvbmRpbmcgYXZlcmFnZSByb3cgYW5kIGNvbHVtbiBwcm9maWxlIGVsZW1lbnRzLg0KDQoNCiMjIDMuMiBDaGktc3F1YXJlZCBkaXN0YW5jZQ0KDQpUaGUgY29uY2VwdCBvZiBkaXN0YW5jZSBvciAoZGlzLSlzaW1pbGFyeSBiZXR3ZWVuIHZhcmlhYmxlcyBpbiBhIGNvcnJlc3BvbmRlbmNlIGFuYWx5c2lzIG1hcCBpcyBiYXNlZCBvbiB0aGUgY2hpLXNxdWFyZWQgZGlzdGFuY2U6IHRoZSBzbWFsbGVyIENoaS1zcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHByb2ZpbGVzLCB0aGUgbW9yZSBzaW1pbGFyIHRoZXkgYXJlLg0KDQo+IENoaS1zcXVhcmVkIGRpc3RhbmNlOiB3ZWlnaHRlZCBFdWNsaWRlYW4gZGlzdGFuY2UgbWVhc3VyZSBiZXR3ZWVuIHByb2ZpbGVzLA0Kd2hlcmUgZWFjaCBzcXVhcmVkIGRpZmZlcmVuY2UgYmV0d2VlbiBwcm9maWxlIGVsZW1lbnRzIGlzIGRpdmlkZWQgYnkgdGhlDQpjb3JyZXNwb25kaW5nIGVsZW1lbnQgb2YgdGhlIGF2ZXJhZ2UgcHJvZmlsZS4NCg0KKGNmLiBHcmVlbmFjcmUgMjAwNzoyNjMpDQoNCg0KSW4gdGhlIHByb2ZpbGUgc3BhY2UsIHdoaWNoIGlzIGNhbGN1bGF0ZWQgbGF0ZXIsIHRoZSBncmVhdGVyIHRoZSBDaGktc3F1YXJlZCBkaXN0YW5jZSBvZiBhIHByb2ZpbGUgZnJvbSB0aGUgYXZlcmFnZSBwcm9maWxlLCB0aGUgZ3JlYXRlciB0aGUgZGlzdGFuY2Ugb2YgdGhlIGNvcnJlc3BvbmRpbmcgcG9pbnQgZnJvbSB0aGUgb3JpZ2luIG9mIHRoZSBjb29yZGluYXRlIHN5c3RlbSBpbiB0aGUgcHJvZmlsZSBzcGFjZS4gQWxzbywgdGhlIGdyZWF0ZXIgdGhlIENoaS1zcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gdHdvIHByb2ZpbGVzLCB0aGUgZ3JlYXRlciB0aGUgZGlzdGFuY2UgaW4gc3BhY2UuIENoaS1zcXVhcmVkIGRpc3RhbmNlIGFyZSBkZWZpbmVkIG9ubHkgYmV0d2VlbiB0d28gcm93IHByb2ZpbGVzIG9yIHR3byBjb2x1bW4gcHJvZmlsZXMgKGFzIHdlbGwgYXMgdGhvc2UgdG8gdGhlIGF2ZXJhZ2UgcHJvZmlsZSkuIEJ1dCBub3QgYmV0d2VlbiByb3cgcHJvZmlsZXMgYW5kIGNvbHVtbiBwcm9maWxlcy4gIA0KDQpOb3RlOiBJZiB5b3UgYXJlIGludGVyZXN0ZWQsIHlvdSBtYXkgY29uc2lkZXIgYSBkaXNjdXNzaW9uIG9mIEJyZWl0dW5nICgyMDIzKSBjcml0aWNpemluZyBzb21lIHVuZGVzaXJhYmxlIGZlYXR1cmVzIG9mIGNoaS1zcXVhcmVkIGRpc3RhbmNlIHdoZW4gYXBwbGllZCBpbiBjb3JyZXNwb25kZW5jZSBhbmFseXNpcy4NCg0KRm9yIHRoZSBjYWxjdWxhdGlvbiB3ZSBzdGFydCBieSBzdW1taW5nIHRoZSBzcXVhcmVkIGRldmlhdGlvbnMgb2Ygb2JzZXJ2ZWQgYW5kIGV4cGVjdGVkIHZhbHVlcyBvZiB0aGUgaW5kaXZpZHVhbCBjZWxscywgYW5kIGRpdmlkZSBieSB0aGUgcmVzcGVjdGl2ZSBleHBlY3RlZCB2YWx1ZXMuDQoNCkNoaS1zcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gcm93IHByb2ZpbGVzIChjZi4gR3JlZW5hY3JlIHAuMzEpDQphfmlqfiA6IHRoZSBqdGggZWxlbWVudCBvZiB0aGUgcm93IHByb2ZpbGUgb2Ygcm93IGk7IGN+an4gOiB0aGUgbWFzcyBvZiB0aGUganRoIGNvbHVtbi4NCg0KJCRcc3FydCB7XHN1bV9qe1xmcmFjeyhhX3tpan0tYV97aSdqfSleMn17Y19qfX19JCQNCg0KDQpJZiB5b3UgY29tcGFyZSBpdCB0byB0aGUgZm9ybXVsYSBmb3IgRXVjbGVkZWFuIGRpc3RhbmNlIHlvdSBzZWUgdGhlIGRpZmZlcmVuY2UgaW4gdGhhdCB0aGUgZm9ybWVyIHVzZXMgd2VpZ2h0aW5nOg0KDQokJFxzcXJ0IHtcc3VtX2p7KGFfe2lqfS1hX3tpJ2p9KV4yfX0kJA0KDQoNCg0KDQpDaGktc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGNvbHVtbiBwcm9maWxlcyANCmJ+aWp+IC0gdGhlIGkudGggZWxlbWVudCBvZiB0aGUgY29sdW1uIHByb2ZpbGUgb2YgY29sdW1uIGo7IHJ+aX46IHRoZSBtYXNzIG9mIHRoZSBpLnRoIHJvdw0KDQokJFxzcXJ0IHtcc3VtX2l7XGZyYWN7KGJfe2lqfS1iX3tpaid9KV4yfXtyX2l9fX0kJA0KDQpDaGktc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIHJvdyBwcm9maWxlIGFuZCBhdmVyYWdlIHJvdyBwcm9maWxlICANCg0KJCRcc3FydCB7XHN1bV9qe1xmcmFjeyhhX3tpan0tY19qKV4yfXtjX2p9fX0kJA0KDQpDaGktc3F1YXJlZCBkaXN0YW5jZSBiZXR3ZWVuIGNvbHVtbiBwcm9maWxlIGFuZCBhdmVyYWdlIGNvbHVtbiBwcm9maWxlIA0KDQokJFxzcXJ0IHtcc3VtX2l7XGZyYWN7KGJfe2lqfS1yX2kpXjJ9e3JfaX19fSQkDQoNCg0KDQpMZXQncyBpbGx1c3RyYXRlIHRoZSBjYWxjdWxhdGlvbiBvZiB0aGUgY2hpLXNxdWFyZWQgZGlzdGFuY2UgZnJvbSB0aGUgZmlyc3Qgcm93IG9mIHRoZSByb3cgcHJvZmlsZSAoJyphbmQgdGhhdConKSB0byB0aGUgYXZlcmFnZSByb3cgb3IgdG8gdGhlIGNlbnRyb2lkIG9mIHRoZSByb3cgcHJvZmlsZSAoWikNCg0KYGBge3J9DQoNCiMgQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGFuZCBkaXZpZGUgYnkgY29sdW1uIHByb2ZpbGVzDQpkaWZmMSA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSwxXSAtIGNvbC5wcm9maWxlcy5hdi5tYXNzWzcsMV0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDFdDQpkaWZmMiA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSwyXSAtIGNvbC5wcm9maWxlcy5hdi5tYXNzWzcsMl0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDJdDQpkaWZmMyA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSwzXSAtIGNvbC5wcm9maWxlcy5hdi5tYXNzWzcsM10pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDNdDQpkaWZmNCA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw0XSAtIGNvbC5wcm9maWxlcy5hdi5tYXNzWzcsNF0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDRdDQpkaWZmNSA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw1XSAtIGNvbC5wcm9maWxlcy5hdi5tYXNzWzcsNV0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDVdDQpkaWZmNiA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw2XSAtIGNvbC5wcm9maWxlcy5hdi5tYXNzWzcsNl0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDZdDQoNCiMgU3VtIHRoZSBkaWZmZXJlbmNlcyBhbmQgdGFrZSB0aGUgc3F1YXJlIHJvb3QNCmQyX2FuZHRoYXRfYXYgPC0gc3FydChkaWZmMSArIGRpZmYyICsgZGlmZjMgKyBkaWZmNCArIGRpZmY1ICsgZGlmZjYpDQoNCg0KZDJfYW5kdGhhdF9hdg0KYGBgDQoNCg0KTm90ZSB3ZSBjb3VsZCBhbHNvIHVzZSBhIHNob3J0ZXIgYWx0ZXJuYXRpdmUgKGluZWxlZ2FudCkgc29sdXRpb24gd2l0aCBhIGxvb3A6IA0KDQpGb3Igaiwgd2UgbG9vcCBmcm9tIDEgdG8gdGhlIGxhc3QgbnVtYmVyIG9mIGRpbWVuc2lvbnMgZnJvbSBvdXIgdGFibGUgTiAoNikgYWxvbmcgdGhlIHJvdyBwcm9maWxlIGFuZCBzdWJ0cmFjdCBpbiB0aGUgZmlyc3Qgcm93IGZvciBhbGwgY29sdW1ucyAxLTYgZnJvbSB0aGUgY2VsbCB2YWx1ZSB0aGUgY29sdW1uIG1hc3Mgb2YgdGhlIHJlc3BlY3RpdmUgY29sdW1uLCBzcXVhcmUgdGhpcyBhbmQgZGl2aWRlIGJ5IHRoZSBjb2x1bW4gbWFzcyBvZiB0aGUgcmVzcGVjdGl2ZSBjb2x1bW4uIEZyb20gdGhlIHZhbHVlcyBzdW1tZWQgaW4gY2hpZGlzdCwgd2UgdGFrZSB0aGUgcm9vdC4gKGNmLiBHcmVlbmFjcmUgMjAwNzoyMTgpDQoNCmBgYHtyfQ0KY2hpZGlzdCAgICAgICA8LSAwDQpmb3IoaiBpbiAxOmRpbShOKSBbMl0pew0KICBjaGlkaXN0IDwtIGNoaWRpc3QrKHJvdy5wcm9maWxlcy5hdi5tYXNzWzEsal0tY29sdW1uLm1hc3Nlc1tqXSleMi9jb2x1bW4ubWFzc2VzW2pdDQogIH0NCnNxcnQoY2hpZGlzdCkNCmBgYA0KDQoNCkNoaS1zcXVhcmVkIGRpc3RhbmNlIGJldHdlZW4gZmlyc3QgKCcqYW5kIHRoYXQqJykgYW5kIHNlY29uZCByb3cgKCcqYW5kIGFsbCB0aGF0KicpIG9mIHRoZSByb3cgcHJvZmlsZS4NCg0KYGBge3J9DQoNCiMgQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGFuZCBkaXZpZGUgYnkgY29sdW1uIHByb2ZpbGVzDQpkaWZmMSA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSwxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsMV0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDFdDQpkaWZmMiA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSwyXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsMl0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDJdDQpkaWZmMyA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSwzXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsM10pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDNdDQpkaWZmNCA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw0XSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsNF0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDRdDQpkaWZmNSA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw1XSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsNV0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDVdDQpkaWZmNiA8LSAocm93LnByb2ZpbGVzLmF2Lm1hc3NbMSw2XSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsNl0pXjIgLyBjb2wucHJvZmlsZXMuYXYubWFzc1s3LDZdDQoNCiMgU3VtIHRoZSBkaWZmZXJlbmNlcyBhbmQgdGFrZSB0aGUgc3F1YXJlIHJvb3QNCmQyX2FuZHRoYXRfYW5kYWxsdGhhdCA8LSBzcXJ0KGRpZmYxICsgZGlmZjIgKyBkaWZmMyArIGRpZmY0ICsgZGlmZjUgKyBkaWZmNikNCg0KZDJfYW5kdGhhdF9hbmRhbGx0aGF0DQpgYGANCg0KDQpGb3IgdGhlIGNhbGN1bGF0aW9uIG9mIGFsbCBDaGktc3F1YXJlZCBkaXN0YW5jZXMgd2UgY2FuIHVzZSB0aGUgZm9sbG93aW5nIGZ1bmN0aW9uOiANCmBkaXN0KClgIGNhbGN1bGF0ZXMgYXMgZGVmYXVsdCBhIEV1Y2xpZGVhbiBkaXN0YW5jZSBtYXRyaXggYmV0d2VlbiB0aGUgcm93cyBvZiBhIG1hdHJpeC4NClRoZSBvcHRpb25zIHNldCBmb3IgYHN3ZWVwKClgIGFyZSAyIChtb3ZlIGRvd24gdGhlIGNvbHVtbnMpLCB0aGUgcm9vdCBvZiB0aGUgY29sdW1uIG1hc3NlcyBpcyB1c2VkIGFzIGEgdmVjdG9yLCBhbmQgdGhlIG9wZXJhdGlvbiB1c2VkIGlzIGRpdmlzaW9uIChjZi4gR3JlZW5hY3JlIDIwMDc6MjE5KS4NCg0KYGBge3J9DQpkaXN0Lm1hdHJpeC5yb3cgPC0gZGlzdChzd2VlcChyb3cucHJvZmlsZXMuYXYsIDIsIHNxcnQoY29sdW1uLm1hc3NlcyksIEZVTj0iLyIpKSANCmRpc3QubWF0cml4LnJvdw0KDQpjYV92YWxpZGF0aW9uJHJvd2Rpc3QNCmBgYA0KDQpJbiB0aGUgYWJvdmUgb3V0cHV0IHlvdSBjYW4gY29tcGFyZSB0aGUgcm93IGNoaS1zcXVhcmVkIGRpc3RhbmNlcyB0byB0aGUgY2VudHJvaWQgKGF2ZXJhZ2Ugcm93IHByb2ZpbGUpIHRvIHRoZSByZXRyaWV2ZWQgc29sdXRpb24gZnJvbSB0aGUgY2EgcGFja2FnZTogYCRyb3dkaXN0YC4gTm90ZSB0aGF0IGRpc3RhbmNlcyBhcmUgb25seSBkZWZpbmVkIGJldHdlZW4gcm93cyAoYW5kIGF2ZXJhZ2Ugcm93KS4gDQoNCg0KTm93LCBsZXQncyBhbmFsb2dvdXNseSBtb3ZlIG9uICB0byB0aGUgQ2hpLXNxdWFyZWQgZGlzdGFuY2UgYmV0d2VlbiBjb2x1bW4gcHJvZmlsZXM6IHdlIGNhbGN1bGF0ZSBpdCBmb3IgdGhlIHNha2Ugb2YgaWxsdXN0cmF0aW9uIGZvciB0aGUgMXN0IGNvbHVtbiAoKlJlYWRpbmdfTUMqKSBhbmQgYXZlcmFnZSBjb2x1bW4gcHJvZmlsZSBvciBjZW50cm9pZCBvZiB0aGUgY29sdW1uIHByb2ZpbGU6DQoNCg0KYGBge3J9DQoNCiMgQ2FsY3VsYXRlIHRoZSBzcXVhcmVkIGRpZmZlcmVuY2VzIGFuZCBkaXZpZGUgYnkgcm93IHByb2ZpbGVzDQpkaWZmMSA8LSAoY29sLnByb2ZpbGVzLmF2Lm1hc3NbMSwxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzEsN10pXjIgLyByb3cucHJvZmlsZXMuYXYubWFzc1sxLDddDQpkaWZmMiA8LSAoY29sLnByb2ZpbGVzLmF2Lm1hc3NbMiwxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzIsN10pXjIgLyByb3cucHJvZmlsZXMuYXYubWFzc1syLDddDQpkaWZmMyA8LSAoY29sLnByb2ZpbGVzLmF2Lm1hc3NbMywxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzMsN10pXjIgLyByb3cucHJvZmlsZXMuYXYubWFzc1szLDddDQpkaWZmNCA8LSAoY29sLnByb2ZpbGVzLmF2Lm1hc3NbNCwxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzQsN10pXjIgLyByb3cucHJvZmlsZXMuYXYubWFzc1s0LDddDQpkaWZmNSA8LSAoY29sLnByb2ZpbGVzLmF2Lm1hc3NbNSwxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzUsN10pXjIgLyByb3cucHJvZmlsZXMuYXYubWFzc1s1LDddDQpkaWZmNiA8LSAoY29sLnByb2ZpbGVzLmF2Lm1hc3NbNiwxXSAtIHJvdy5wcm9maWxlcy5hdi5tYXNzWzYsN10pXjIgLyByb3cucHJvZmlsZXMuYXYubWFzc1s2LDddDQoNCiMgU3VtIHRoZSBkaWZmZXJlbmNlcyBhbmQgdGFrZSB0aGUgc3F1YXJlIHJvb3QNCmQyX1JlYWRNQ19hdiA8LSBzcXJ0KGRpZmYxICsgZGlmZjIgKyBkaWZmMyArIGRpZmY0ICsgZGlmZjUgKyBkaWZmNikNCg0KDQpkMl9SZWFkTUNfYXYNCg0KYGBgDQoNCg0KSW4gb3JkZXIgdG8gY2FsY3VsYXRlIHRoZSBkaXN0YW5jZSBtYXRyaXggZm9yIGNvbHVtbnMgYnkgdXNpbmcgYGRpc3QoKWAgYW5kIGBzd2VlcCgpYCwgd2UgdHJhbnNwb3NlIHRoZSBtYXRyaXggb2YgdGhlIGNvbHVtbiBwcm9maWxlcy4gQmVsb3cgeW91IGNhbiB2ZXJpZnkgdGhlIGNvcnJlY3QgcmVzdWx0IGFuZCBjb21wYXJlIGl0IHRvIHRoZSBvdXRwdXQgb2YgdGhlICRjb2xkaXN0IHZhcmlhYmxlIGZyb20gdGhlIGNhIG9iamVjdC4gDQoNCmBgYHtyfQ0KY29sLnByb2ZpbGVzLmF2LnQgPC0gdChjb2wucHJvZmlsZXMuYXYpDQpkaXN0Lm1hdHJpeC5jb2wgIDwtIGRpc3Qoc3dlZXAoY29sLnByb2ZpbGVzLmF2LnQsIDIsIHNxcnQocm93Lm1hc3NlcyksIEZVTj0iLyIpKSANCmRpc3QubWF0cml4LmNvbA0KY2FfdmFsaWRhdGlvbiRjb2xkaXN0DQpgYGANCg0KDQojIDQuIFJlc2lkdWFscywgc3RhbmRhcmRpemVkIFJlc2lkdWFscw0KDQo+UmVzaWR1YWxzLCBzdGFuZGFyZGl6ZWQgcmVzaWR1YWxzOiBSZXNpZHVhbHMgYXJlIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIG9ic2VydmVkIGFuZCBleHBlY3RlZCBmcmVxdWVuY2llcy4gVGhlIHN0YW5kYXJkaXplZCByZXNpZHVhbCBpbiByb3cgaWogaXMgb2J0YWluZWQgYnkgZGl2aWRpbmcgdGhlIHJlc2lkdWFsIGJ5IHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgZXhwZWN0ZWQgZnJlcXVlbmN5IG9mIHRoZSBjZWxsLiBDb3JyZXNwb25kZW5jZSBhbmFseXNpcyB1c2VzIHN0YW5kYXJkaXplZCByZXNpZHVhbHMgY29udmVydGVkIHRvIHByb3BvcnRpb24gdmFsdWVzLg0KKGNmLiBIYXV0eiAmIEJsZXVlbCAyMDE4OiAyMjEpDQoNCiMjIDQuMSBSZXNpZHVhbHMNCg0KDQpUaGUgcmVzaWR1YWxzIGFyZSBjYWxjdWxhdGVkIGJ5IHN1YnRyYWN0aW5nIHRoZSBleHBlY3RlZCBwcm9wb3J0aW9ucyBmcm9tIHRoZSBvYnNlcnZlZCBwcm9wb3J0aW9ucy4gTm9ybWFsbHksIHJlc2lkdWFscyBhcmUgY2FsY3VsYXRlZCBpbiBzdGF0aXN0aWNzIHRvIGRldGVybWluZSB0aGUgbWFnbml0dWRlIG9mIGVycm9yIGluIGEgbW9kZWwuDQoNCkluIGNvcnJlc3BvbmRlbmNlIGFuYWx5c2lzLCB0aGlzIGlzIGRpZmZlcmVudDsgdGhlIGZvY3VzIGlzIG9uIGV4YW1pbmluZyB0aGUgcmVzaWR1YWxzLiBUaGV5IHF1YW50aWZ5IHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdGhlIG9ic2VydmVkIGRhdGEgYW5kIHdoYXQgd2Ugd291bGQgZXhwZWN0IGlmIHRoZXJlIHdlcmUgbm8gcmVsYXRpb25zaGlwIGJldHdlZW4gcm93IGFuZCBjb2x1bW4gY2F0ZWdvcmllcy4NCg0KYGBge3J9DQpSID0gUCAtIEUNClINCmBgYA0KDQpUaGUgZXhhbXBsZXMgaW4gdGhlIGNhdGVnb3JpZXMgJyphbmQgdGhhdConIGFuZCAnKlJlYWRpbmdfV0MqJyBzaG93IGEgaGlnaCByZXNpZHVhbCB2YWx1ZSBvZiAwLjAzMS4NClRoZSBvYnNlcnZlZCBwcm9wb3J0aW9uIHdhcyBhYm91dCA2LjMlIHdoaWNoIGlzIDMlIGhpZ2hlciB0aGFuIHRoZSBleHBlY3RlZCB2YWx1ZSBvZiAzLjIlIGFzc3VtaW5nIHRoYXQgdGhlcmUgaXMgbm8gcmVsYXRpb25zaGlwIGJldHdlZW4gY2F0ZWdvcmllcy4NCg0KYGBge3J9DQpQWzEsMl0NCkVbMSwyXQ0KUlsxLDJdDQpgYGANCg0KVGhpcyBzdWdnZXN0cyB0aGF0IGluIHRoZSBleGFtcGxlIHNlbnRlbmNlcyBvZiAnKmFuZCB0aGF0KicgYW5kICcqUmVhZGluZ19XQyonIGl0IGlzIG1vcmUgbGlrZWx5IHRoYXQgdGhlIGV4dGVuZGVyIGlzIHVzZWQgdGhhbiBpbiB0aGUgYXZlcmFnZSBzZW50ZW5jZS4NCg0KDQojIyA0LjIgIENhbGN1bGF0aW9uIG9mIHRoZSBzdGFuZGFyZGl6ZWQgcmVzaWR1YWwgWiANCg0KDQpUaGUgc3RhbmRhcmRpemVkIHJlc2lkdWFsIFogcHJvdmlkZXMgYSB3ZWlnaHRpbmcgb2YgdGhlIFNWRCAoU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbikuIENlbGxzIHdpdGggYSBoaWdoZXIgZXhwZWN0ZWQgcHJvcG9ydGlvbiBhcmUgZ2l2ZW4gYSBncmVhdGVyIHdlaWdodCBpbiB0aGUgZGF0YS4gVGhlIGV4cGVjdGVkIHZhbHVlcyBhcmUgcmVsYXRlZCB0byB0aGUgZGF0YSBzZXQgc2l6ZS4gVGhlIHdlaWdodGluZyBtZWFucyB0aGF0IHNtYWxsZXIgY2VsbHMgaW4gdGhlIHRhYmxlLCBmb3Igd2hpY2ggdGhlIHNhbXBsaW5nIGVycm9yIHdpbGwgYmUgbGFyZ2VyLCBhcmUgd2VpZ2h0ZWQgbG93ZXIuIFRoaXMgbWFrZXMgdGhlIGNvcnJlc3BvbmRlbmNlIGFuYWx5c2lzIHJlbGF0aXZlbHkgcm9idXN0IGluIGRlYWxpbmcgd2l0aCBvdXRsaWVycyBjYXVzZWQgYnkgc2FtcGxpbmcgZXJyb3Igd2hlbiB0aGUgdGFibGUgaXMgYW5hbHl6ZWQgYXMgYSBjb250aW5nZW5jeSB0YWJsZS4gDQoNCkZvcm11bGEgZm9yIHRoZSBjYWxjdWxhdGlvbiBvZiBhbiBlbGVtZW50IG9mIHRoZSB0YWJsZSBvZiBzdGFuZGFyZGl6ZWQgcmVzaWR1YWxzOiANCkRldmlhdGlvbiBvZiBvYnNlcnZlZCBmcm9tIGV4cGVjdGVkIHByb3BvcnRpb25zIGRpdmlkZWQgYnkgdGhlIHJvb3Qgb2YgdGhlIGV4cGVjdGVkIHByb3BvcnRpb25zLg0KDQokJGFfe2lqfSA9IFxmcmFjeyhwX3tpan0gLSByX2ljX2opfXtcc3FydHtyX2ljX2p9fSQkICAoY2YuIEJsYXNpdXMgMjAwMTo4OSkNCg0KYGBge3J9DQpaIDwtIFIvc3FydChFKQ0KWg0KYGBgDQoNCklmIHRoZSBlbGVtZW50cyBvZiB0aGUgc3RhbmRhcmRpemVkIHJlc2lkdWFscyBhcmUgc3F1YXJlZCwgbXVsdGlwbGllZCBieSB0aGUgdG90YWwgZnJlcXVlbmN5LCBhbmQgdGhlbiBzdW1tZWQsIHRoZSByZXN1bHQgaXMgQ2hpXjJeIChkZXRlcm1pbmVkIGVhcmxpZXIpOg0KYGBge3J9DQpjaGkyLmF1cy5yZXMgPC0gc3VtKCgoWileMikqbikNCmNoaTIuYXVzLnJlcw0KY2hpMg0KYGBgDQoNCiMgNS4gU2luZ3VsYXIgVmFsdWUgRGVjb21wb3NpdGlvbiANCg0KQ29ycmVzcG9uZGVuY2UgYW5hbHlzaXMgc2Vla3MgYSBsb3ctZGltZW5zaW9uYWwgc3Vic3BhY2Ugd2hpY2ggc2hvdWxkIGJlIGFzIGNsb3NlIGFzIHBvc3NpYmxlIHRvIGFsbCBwb2ludHMtIHRoZSBwb2ludHMgYXJlIHRoZW4gcHJvamVjdGVkIGludG8gdGhlIG9wdGltYWwgc3Vic3BhY2UgdGhhdCBjYXB0dXJlcyBhcyBtdWNoIG9mIHRoZSB2YXJpYXRpb24gaW4gdGhlIGRhdGEgYXMgcG9zc2libGUuIA0KDQpXaXRoIHJlc3BlY3QgdG8gdGhpcyBvYmplY3RpdmUsIGl0IGlzIG5lY2Vzc2FyeSB0byBkZWZpbmUgd2hhdCBwcm94aW1pdHkgb2YgcG9pbnRzIHRvIHRoZSBzdWJzcGFjZSBtZWFucy4gSW50dWl0aXZlbHksIG9uZSB3b3VsZCB3YW50IHRvIGZpbmQgZGlzdGFuY2VzIG9mIGFsbCBwcm9maWxlcyB0byBhbiBpbWFnaW5hcnkgbGluZSBmb3Igd2hpY2ggdGhlIHN1bSBvZiB0aGUgZGlzdGFuY2VzIGlzIHNtYWxsZXN0IChidXQgdGhpcyBpbnZvbHZlcyBjb21wbGljYXRlZCBtYXRoZW1hdGljcykuDQoNCkluc3RlYWQsIHRoZSBwcm9ibGVtIGNhbiBiZSBzaW1wbGlmaWVkIGJ5IGRlZmluaW5nIGEgY3JpdGVyaW9uIGZvciB0aGUgc3VtIG9mIHNxdWFyZWQgZGlzdGFuY2VzLCB3aGljaCBpcyBtYXRoZW1hdGljYWxseSBlcXVpdmFsZW50IHRvIGEgbGVhc3Qtc3F1YXJlcyBtZXRob2QgZm9yIGZpbmRpbmcgYW4gb3B0aW1hbCBzdWJzcGFjZS4gDQoNCkluIGNvcnJlc3BvbmRlbmNlIGFuYWx5c2lzLCB0aGUgd2VpZ2h0ZWQgc3VtIG9mIHNxdWFyZWQgZGlzdGFuY2VzIGlzIG5vdyB0YWtlbiBhcyB0aGUgY3JpdGVyaW9uLiAoY2YuIEdyZWVuYWNyZSBwLiA0NykNCg0KV2UgYXNzdW1lIGkgcHJvZmlsZSBwb2ludHMgaW4gYSBtdWx0aWRpbWVuc2lvbmFsIHNwYWNlIGFuZCBhIGxvdy1kaW1lbnNpb25hbCBzdWJzcGFjZSBTIGFzIGNhbmRpZGF0ZXMgZm9yIHRoZSBvcHRpbWFsIHN1YnNwYWNlLiANCkZvciB0aGUgaS50aCBwcm9maWxlIHBvaW50IHdpdGggbWFzcyBtfml+IHdlIGNhbGN1bGF0ZSB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0aGUgcG9pbnQgYW5kIFMgZGVub3RlZCBieSBkfml+KFMpLiBUaGUgcHJveGltaXR5IG9mIHRoZSBwcm9maWxlIHRvIHRoZSBzdWJzcGFjZSBpcyBtfml+W2R+aX4oUyldXjJeLCBvciB0aGUgc3F1YXJlZCBkaXN0YW5jZSB3ZWlnaHRlZCBieSB0aGUgbWFzcy4gVGhlIGNsb3NlbmVzcyBvZiBhbGwgcHJvZmlsZXMgaXMgb2J0YWluZWQgYnkgc3VtbWF0aW9uLg0KDQokJGNsb3NlbmVzc1w6dG9cOlMgPSBcc3VtX2kge21faVtkX2koUyldXjJ9ICQkDQoNCg0KVGhlIG9wdGltYWwgc3Vic3BhY2UgbXVzdCBzYXRpc2Z5IHRoaXMgY3JpdGVyaW9uLiANCg0KVGhlIGNvbXB1dGF0aW9uIG9mIHRoZSBzb2x1dGlvbiBvZiB0aGlzIHByb2JsZW0gY2FuIGJlIGFjaGlldmVkIGJ5IHRoZSBzaW5ndWxhciB2YWx1ZSBkZWNvbXBvc2l0aW9uLCBhIHByb2NlZHVyZSB0aGF0IGlzIGNydWNpYWwgZm9yIHZhcmlvdXMgbWV0aG9kcyBvZiBkaW1lbnNpb24gcmVkdWN0aW9uLiBJbiBjb3JyZXNwb25kZW5jZSBhbmFseXNpcywgaXQgaXMgYXBwbGllZCB0byB0aGUgbWF0cml4IG9mIHN0YW5kYXJkaXplZCByZXNpZHVhbHMuIA0KDQoqKlNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24qKg0KDQo+IGEgbWF0cml4IGRlY29tcG9zaXRpb24gc2ltaWxhciB0byB0aGF0IG9mIGVpZ2VudmFsdWVzIGFuZCBlaWdlbnZlY3RvcnMsIGJ1dCBhcHBsaWNhYmxlIHRvIHJlY3Rhbmd1bGFyIG1hdHJpY2VzOyB0aGUgc3F1YXJlcyBvZiB0aGUgc2luZ3VsYXIgdmFsdWVzIGFyZSBlaWdlbnZhbHVlcyBvZiBwYXJ0aWN1bGFyIHNxdWFyZSBtYXRyaWNlcywgYW5kIHRoZSBsZWZ0IGFuZCByaWdodCBzaW5ndWxhciB2ZWN0b3JzIGFyZSBhbHNvIGVpZ2VudmVjdG9ycw0KDQpBIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gaXMgYSBnZW5lcmFsaXphdGlvbiBvZiB0aGUgZWlnZW52YWx1ZSBkZWNvbXBvc2l0aW9uIChmb3Igc3F1YXJlIG1hdHJpY2VzKSBhbmQgY2FuIGJlIGFwcGxpZWQgdG8gYW55IHJlY3Rhbmd1bGFyIG1hdHJpY2VzLg0KDQpUaGUgbWF0cml4IGlzIGJyb2tlbiBkb3duIGludG8gY29tcG9uZW50cywgb3JkZXJlZCBmcm9tIGltcG9ydGFudCB0byB1bmltcG9ydGFudC4gVGhlIGFsZ2VicmFpYyBub3Rpb24gb2YgKnJhbmsqIG9mIGEgbWF0cml4IGlzIGdlb21ldHJpY2FsbHkgZXF1aXZhbGVudCB0byB0aGUgbm90aW9uIG9mIGRpbWVuc2lvbnMuDQoNClRoZSBkaW1lbnNpb25zIG9mIHRoZSBvcHRpbWFsIHN1YnNwYWNlIGFyZSBmb3JtZWQgd2l0aCBhIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24tIGZvciB0aGlzIHB1cnBvc2UgYSBmaXJzdCBkaW1lbnNpb24gaXMgY29uc3RydWN0ZWQsIHdoaWNoIGV4cGxhaW5zIGEgbWF4aW11bSBwb3J0aW9uIG9mIHRoZSB2YXJpYXRpb24gb2YgdGhlIGRhdGEuIFRoZW4sIGEgc2Vjb25kIGRpbWVuc2lvbiBpcyBjb25zdHJ1Y3RlZCBzdWNoIHRoYXQgaXQgaXMgb3J0aG9nb25hbCB0byB0aGUgZmlyc3QgYW5kIGFnYWluIGNhcHR1cmVzIGEgbWF4aW11bSBmcmFjdGlvbiBvZiB0aGUgcmVtYWluaW5nIHZhcmlhdGlvbi4gIA0KSW4gdGhpcyB3YXksIHRoZSBTVkQgc3VjY2Vzc2l2ZWx5IHBhcnRpdGlvbnMgdGhlIHRvdGFsIGluZXJ0aWEgb3IgKnRvdGFsIGluZXJ0aWEqIM67fkd+IGFtb25nIHRoZSBkaW1lbnNpb25zLiANCg0KVGhlIHNpbmd1bGFyIHZhbHVlIGRlY29tcG9zaXRpb24gYWxzbyBwcm92aWRlcyB0aGUgY29vcmRpbmF0ZXMgb2YgdGhlIHJvdyBhbmQgY29sdW1uIHBvaW50cyBpbiBzcGFjZSBpbiBmdXJ0aGVyIHN0ZXBzIG9mIGNhbGN1bGF0aW9uLg0KDQoNCg0KIyMgNS4xIFNpbmd1bGFyIFZhbHVlIERlY29tcG9zaXRpb24gKFNWRCkgDQoNClRoZSBkZWNvbXBvc2l0aW9uIG9mIGEgbWF0cml4IEEgaXMgZGVmaW5lZCBhcyB0aGUgcHJvZHVjdCBvZiB0aHJlZSBtYXRyaWNlcw0KDQokJEEgPSBVXDpcR2FtbWFcOlZeVCQkDQoNCg0KR2FtbWEgaXMgdGhlIGRpYWdvbmFsIG1hdHJpeCB3aXRoIHNpbmd1bGFyIHZhbHVlcyBpbiBkZXNjZW5kaW5nIG9yZGVyDQokJFxnYW1tYV8xIFxnZXEgXGdhbW1hXzIgXGdlcS4uLlxnZXEgXGdhbW1hX2sgXGdlcS4uLlxnZSAwJCQgDQoNCkluIGEgZGlhZ29uYWwgbWF0cml4LCBhbGwgdmFsdWVzIGV4Y2VwdCB0aGUgZGlhZ29uYWwgYXJlIHplcm9zLiAoRm9yIHRoZSBjYWxjdWxhdGlvbiBpbiBSIGEgcmVwcmVzZW50YXRpb24gYXMgYSB2ZWN0b3IgaXMgc3VmZmljaWVudC4pIFRoZSBsYXN0IHZhbHVlIGlzIGluIHByaW5jaXBsZSAwIGFuZCBpbiB0aGUgcHJlc2VudCBjYXNlLCB0aGlzIGNhbiBiZSBpZ25vcmVkLCBhcyB3ZWxsIGFzIHRoZSBsYXN0IGNvbHVtbnMgaW4gdSBhbmQgdiwgd2hpY2ggYXJlIG11bHRpcGxpZWQgYnkgMC4NCg0KVGhlIGNvbHVtbnMgb2YgdGhlIG1hdHJpeCBVIGFyZSBjYWxsZWQgbGVmdCBzaW5ndWxhciB2ZWN0b3JzIGFuZCB0aG9zZSBvZiBWIGFyZSBjYWxsZWQgcmlnaHQgc2luZ3VsYXIgdmVjdG9ycy4gVGhlIGxlZnQgc2luZ3VsYXIgdmVjdG9ycyBjb3JyZXNwb25kIHRvIHRoZSByb3dzLCBhbmQgdGhlIHJpZ2h0IHNpbmd1bGFyIHZlY3RvcnMgY29ycmVzcG9uZCB0byB0aGUgY29sdW1ucy4gVGhlIG1hdHJpeCBWXlReIHdhcyB0cmFuc3Bvc2VkLiANCg0KQ2FsY3VsYXRpb24gaXMgZG9uZSB3aXRoIHRoZSBgc3ZkKClgIGZ1bmN0aW9uLCB0aGUgcmVzdWx0aW5nIG9iamVjdCBpcyBuYW1lZCBTVkQuDQoNCg0KYGBge3J9DQpTVkQgPSBzdmQoWikNCnJvd25hbWVzKFNWRCR1KSA9IHJvd25hbWVzKFApDQpyb3duYW1lcyhTVkQkdikgPSBjb2xuYW1lcyhQKQ0KU1ZEDQpgYGANCg0KDQoNCkVhY2ggc2luZ3VsYXIgdmFsdWUgYW5kIHRoZSBjb3JyZXNwb25kaW5nIHZlY3RvcnMgKGUuZy4gdGhlIGNvbHVtbnMgb2YgdSBhbmQgdikgY29ycmVzcG9uZCB0byBvbmUgZGltZW5zaW9uLiBBIHByb3BlcnR5IG9mIFUgYW5kIFYgaXMgdGhhdCB0aGUgY29sdW1ucyBvZiBVIGFyZSBvcnRob2dvbmFsIHRvIGVhY2ggb3RoZXIgYW5kIHRoYXQgdGhlIGNvbHVtbnMgb2YgViBhcmUgb3J0aG9nb25hbCB0byBlYWNoIG90aGVyLg0KDQoNCiMjIDUuMiBFaWdlbnZhbHVlcw0KDQpUaGUgc3F1YXJlZCBzaW5ndWxhciB2YWx1ZXMgYXJlIGNhbGxlZCAqZWlnZW52YWx1ZXMqLg0KDQpgYGB7cn0NCmVpZ2VudmFsdWVzID0gU1ZEJGReMg0KZWlnZW52YWx1ZXMNCmBgYA0KDQoNClRoZSBpbmVydGlhIGFtb3VudCB3aGljaCBpcyBjb3ZlcmVkIGJ5IGEgcHJpbmNpcGFsIGF4aXMsIHRoZSBzby1jYWxsZWQgKnByaW5jaXBhbCBpbmVydGlhKiwgd2l0aCByZWZlcmVuY2UgdG8gdGhlIGZpcnN0IHByaW5jaXBhbCBheGlzLCBpcyBhbHNvIGNhbGxlZCAqZmlyc3QgcHJpbmNpcGFsIGluZXJ0aWEqLiBJdCBpcyBhbHNvIG9mdGVuIGNhbGxlZCBhbiBlaWdlbnZhbHVlIGJlY2F1c2Ugb2YgdGhlIHdheSBpdCBjYW4gYmUgY2FsY3VsYXRlZCwgYXMgYW4NCmVpZ2VudmFsdWUgb2YgYSBzcXVhcmUgc3ltbWV0cmljIG1hdHJpeC4NCg0KVGhlIGVpZ2VudmFsdWUgY29ycmVzcG9uZHMgdG8gdGhlIGZyYWN0aW9uIG9mIHRoZSB0b3RhbCBpbmVydGlhIGFjY291bnRlZCBmb3IgYnkgZGltZW5zaW9uIGsgYW5kIGlzIG5vdGF0ZWQgYXMgzrt+a34uIFRoZSBzdW0gb2YgdGhlIGVpZ2VudmFsdWVzIG9mIGFsbCBkaW1lbnNpb25zIGlzIGVxdWFsIHRvIHRoZSB0b3RhbCBpbmVydGlhIM67fkd+LiANClRoZSBmcmFjdGlvbiBvZiB0aGUgdG90YWwgaW5lcnRpYSBhY2NvdW50ZWQgZm9yIGJ5IDEgb3IgMTAwIHBlcmNlbnQgZGltZW5zaW9uIM67fmt+IGlzIGNhbGxlZCB0aGUgZWlnZW52YWx1ZSBmcmFjdGlvbiBvZiB0aGUga3RoIGRpbWVuc2lvbiAoY2FsY3VsYXRlZCBieSDOu35rfi/Ou35HfikuDQoNCltOb3RlOiAqSyogaXMgdGhlIGRpbWVuc2lvbmFsaXR5IG9mIHRoZSBtYXRyaXggaW4gc3BhY2Ugb3IgcmFuaywgd2UgYWxzbyBzcGVhayBvZiBmYWN0b3JzIGFuZCBhc3NpZ24gcHJvcGVydGllcyB0byB0aGUgZGltZW5zaW9ucy4NCiprKiBpcyB0aGUgbnVtYmVyIG9mIGZhY3RvcnMsIGsgaXMgYWxzbyB1c2VkIGFzIGFuIGluZGV4LiBJbiB0ZXJtcyBvZiBpbmVydGlhIHdlaWdodHMsIHdlIHNwZWFrIG9mIGEgd2VpZ2h0fmt+IGFzIGJlaW5nIG9uIHRoZSBrdGggYXhpcywgYW5kIGluIHRlcm1zIG9mIGNvb3JkaW5hdGVzIH5rfiB3ZSBzcGVhayBvZiBhIGNvb3JkaW5hdGUgb24gdGhlIGt0aCBmYWN0b3JdLg0KDQoNClRoZSBzdW0gb2YgdGhlIGVpZ2VudmFsdWVzIGFnYWluIGdpdmVzIHRoZSB0b3RhbCBpbmVydGlhOiAod2UgaGFkIGFscmVhZHkgZGV0ZXJtaW5lZCB0aGlzIGluIDMuMS4xKS4gDQoNCmBgYHtyfQ0KaW5lcnRpYS5zdW0gPSBzdW0oZWlnZW52YWx1ZXMpDQppbmVydGlhLnN1bQ0KdG90YWwuaW5lcnRpYQ0KYGBgDQoNClRoZSBlaWdlbnZhbHVlIGNvbXBvbmVudHMgb2YgdGhlIGZpcnN0IGRpbWVuc2lvbnMgYXJlIGRldGVybWluZWQgYXMgZm9sbG93czogd2UgZGl2aWRlIGVhY2ggZWlnZW52YWx1ZSBieSB0aGUgdG90YWwgaW5lcnRpYSBhbmQgZXhwcmVzcyB0aGVtIGFzIHByb3BvcnRpb25zLg0KYGBge3J9DQpwcm9wLmluZXJ0aWFzID0gZWlnZW52YWx1ZXMvdG90YWwuaW5lcnRpYQ0KcHJvcC5pbmVydGlhcw0KcGVyYy5pbmVydGlhczwtcm91bmQocHJvcC5pbmVydGlhcyoxMDAsIDMpDQpwZXJjLmluZXJ0aWFzDQpgYGANCg0KDQpBYm92ZSwgd2UgaGF2ZSBjYWxjdWxhdGVkIHRoYXQgdGhlIGZpcnN0IGRpbWVuc2lvbiBvZiB0aGUgY29ycmVzcG9uZGVuY2UgYW5hbHlzaXMgZXhwbGFpbnMgNzMuNiUgb2YgdGhlIHZhcmlhdGlvbiBpbiB0aGUgZGF0YSBhbmQgdGhlIHNlY29uZCBleHBsYWlucyAxOC4xJS4gVGhlIHRoaXJkIGRpbWVuc2lvbiBleHBsYWlucyA1LjElIGFuZCB0aGUgZm91cnRoIDMlLiANCg0KIyMjIDUuMi4xIFNjcmVlLVBsb3QNCg0KSW4gY29ycmVzcG9uZGVuY2UgYW5hbHlzaXMsIHdlIHVzdWFsbHkgaW5zcGVjdCBhIGJhciBjaGFydCAob3Igc2ltaWxhciByZXByZXNlbnRhdGlvbikgd2l0aCB0aGUgaW5lcnRpYSB2YWx1ZXMgYXMgcGVyY2VudGFnZXMgdG8gY2hlY2sgZm9yIHRoZSBudW1iZXIgb2YgZGltZW5zaW9ucyB0byBiZSBjb25zaWRlcmVkIGZvciB0aGUgYW5hbHlzaXMuIEEgcnVsZSBvZiB0aHVtYiBpcyB0byBsb29rIGZvciBhIGJvdyBpbiB0aGUgZ3JhcGggYW5kIGNob29zZSB0aGUgZGltZW5zaW9ucyBiZWZvcmUgdGhlIGJvdy4gVGhlIGlkZWEgaXMgdG8gYW5hbHlzZSB0aGUgZGltZW5zaW9ucyB3aGljaCBjYW4gYWNjb3VudCBmb3IgbW9zdCB2YXJpYXRpb24gaW4gdGhlIGRhdGEuIA0KDQpUbyBjcmVhdGUgdGhlIHNjcmVlLXBsb3QgZm9yIHRoZSBpbmVydGlhIHZhbHVlcywgZmlyc3QsIHRoZSBheGVzIGFyZSBjb3VudGVkIG92ZXIgdGhlIGxlbmd0aCBvZiB0aGUgdmVjdG9yIHRvIG5hbWUgdGhlbS4NCkluIHRoZSBzZWNvbmQgc3RlcCwgYSBiYXIgY2hhcnQgb2YgdGhlIHJvdW5kZWQgaW5lcnRpYSB2YWx1ZXMgaW4gcGVyY2VudCBpcyBjcmVhdGVkLiBUaGUgYmFycyBhcmUgbmFtZWQgdXNpbmcgdGhlIHByZXZpb3VzbHkgZGVmaW5lZCBuYW1lcy4gDQoNCkZvciBgeWxpbWAsIHRoZSByb3VuZGVkIHZhbHVlIG9mIHRoZSBsYXJnZXN0IHNpbmd1bGFyIHZhbHVlIGluY3JlYXNlZCBieSAyMCUgaXMgY2hvc2VuIGFzIHRoZSBheGlzIG1heGltdW0uIFdpdGggYHNwYWNlPWAgdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGNvbHVtbnMgaXMgZGV0ZXJtaW5lZCBhbmQgYGxhcz0xYCBsYWJlbHMgdGhlIFktYXhpcyBob3Jpem9udGFsbHkuIA0KYHRleHQoKWAgZ2V0cyBhcyBYLWNvb3JkaW5hdGUgYSB2ZWN0b3IgY29udGFpbmluZyB0aGUgbnVtYmVycyBmcm9tIDEgdG8gdGhlIG51bWJlciBvZiBDQS1heGVzIG9yIHBlcmNlbnQgdmFsdWVzLCBkZWNyZWFzZWQgYnkgMC41LiBBcyB0aGUgWS1jb29yZGluYXRlIHRoZSBwZXJjZW50IHZhbHVlcyBhcmUgY2hvc2VuLiBUaGUgbnVtYmVycyBhYm92ZSB0aGUgYmFycyBnaXZlIHRoZSBwZXJjZW50YWdlIHZhbHVlcy4gDQoNCg0KYGBge3J9DQpuYW0gPC0gcGFzdGUoIkF4aXMiLCAxOmxlbmd0aChwZXJjLmluZXJ0aWFzKSkgIA0KYmFycGxvdChwZXJjLmluZXJ0aWFzLCBuYW1lcy5hcmcgPSBuYW0sIGNvbCA9IDgsICB5bGltPWMoMCxyb3VuZChtYXgocGVyYy5pbmVydGlhcykrbWF4KHBlcmMuaW5lcnRpYXMpLzUsMSkpLHNwYWNlPTAsIGxhcz0xKQ0KIHRleHQoKDE6bGVuZ3RoKHBlcmMuaW5lcnRpYXMpKS0wLjUsIHBlcmMuaW5lcnRpYXMsIHBlcmMuaW5lcnRpYXMsIHBvcz0zKSANCiB0aXRsZShtYWluPSJQcmluY2lwYWwgSW5lcnRpYXMgJSIsIGZvbnQ9MikgDQpgYGANCg0KDQoNCiMjIDUuMyBDb29yZGluYXRlcw0KDQoNCiMjIyA1LjMuMSBQcmluY2lwYWwgQ29vcmRpbmF0ZXMNCg0KVGhlIHByaW5jaXBhbCBjb29yZGluYXRlcyBpbmRpY2F0ZSB0aGUgY29vcmRpbmF0ZSBwb3NpdGlvbnMgb2YgdGhlIHByb2ZpbGVzLiBTaW5jZSB0aGUgY29vcmRpbmF0ZXMgcmVmZXIgdG8gdGhlIHByb2ZpbGVzIG9uIHRoZSBwcmluY2lwYWwgYXhlcywgdGhleSBhcmUgYWxzbyBjYWxsZWQgcHJpbmNpcGFsIGNvb3JkaW5hdGVzLiANCg0KPiAgQ29vcmRpbmF0ZXMgb2YgYSBzZXQgb2YgcG9pbnRzIHByb2plY3RlZCBvbnRvIGENCnByaW5jaXBhbCBheGlzLCBzdWNoIHRoYXQgdGhlaXIgd2VpZ2h0ZWQgc3VtIG9mIHNxdWFyZXMgYWxvbmcgYW4gYXhpcyBlcXVhbHMNCnRoZSBwcmluY2lwYWwgaW5lcnRpYSBvbiB0aGF0IGF4aXMuIChjZi4gR3JlZW5hY3JlIDIwMDc6MjY1KQ0KDQpGb3IgdGhlIGxvY2FsaXphdGlvbiBvZiB0aGUgaS10aCByb3cgb24gdGhlIGstdGggYXhpcy9mYWN0b3INCndlIGNhbGN1bGF0ZSB0aGUgcHJvZHVjdCBvZiB0aGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZiB0aGUgbWF0cml4IFUgb2YgdGhlIGxlZnQgc2luZ3VsYXIgdmVjdG9ycyBmb3Igb25lIHJvdyBvbiBvbmUgYXhpcyBhbmQgdGhlIHNpbmd1bGFyIHZhbHVlIG9mIHRoZSBrLXRoIGF4aXMgZGl2aWRlZCBieSB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIG1hc3Mgb2YgdGhlIGktdGggcm93Lg0KDQoNCiQkZl97aWt9ID0gdV97aWt9XDpcZ2FtbWFfa1w6LyBcc3FydHtyX2l9JCQNCihjZi4gQmxhc2l1cyAyMDAxOjkyKQ0KDQpUbyBpbGx1c3RyYXRlIHRoZSBwcm9jZWR1cmUsIHdlIGNhbGN1bGF0ZSB0aGUgdmFsdWVzIGZvciB0aGUgcG9zaXRpb24gb2YgdGhlIHJvdyAnKmFuZCBzdHVmZionIG9uIHRoZSBmaXJzdCBheGlzIGFuZCBvbiB0aGUgc2Vjb25kIGF4aXMuIFRoZXJlZm9yIHdlIG11bHRpcGx5IHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcyBmcm9tIHRoZSBtYXRyaXggVSBvZiB0aGUgbGVmdCBzaW5ndWxhciB2ZWN0b3JzIGFuZCB0aGUgdmFsdWUgb2YgdGhlIGF4aXMgZGl2aWRlZCBieSB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIG1hc3Mgb2YgdGhlIDNyZCByb3cuDQoNCmBgYHtyfQ0KDQojIHBvc2l0aW9uIG9uIHRoZSBmaXJzdCBheGlzDQpTVkQkdVszLDFdKlNWRCRkWzFdL3NxcnQocm93LnByb2ZpbGVzLmF2Lm1hc3NbMyw3XSkNCg0KIyBwb3NpdGlvbiBvbiB0aGUgc2Vjb25kIGF4aXMNClNWRCR1WzMsMl0qU1ZEJGRbMl0vc3FydChyb3cucHJvZmlsZXMuYXYubWFzc1szLDddKQ0KDQoNCmBgYA0KDQpUaGUgY29tcGxldGUgbWF0cml4IEYgb2YgcHJpbmNpcGFsIGNvb3JkaW5hdGVzIG9mIHRoZSByb3dzIGlzIGNhbGN1bGF0ZWQgYnkgdXNpbmcgYHN3ZWVwYCBhZ2FpbjoNCmBgYHtyfQ0KcHJvIDwtIHN3ZWVwKFNWRCR1LCAyLCBTVkQkZCwgIioiKQ0KcHJpbmNpcGFsLmNvb3JkaW5hdGVzLnJvd3MgPC0gc3dlZXAocHJvLCAxLCAoc3FydChyb3cubWFzc2VzKSksICIvIikNCnByaW5jaXBhbC5jb29yZGluYXRlcy5yb3dzDQpgYGANCg0KV2UgY29udGludWUgd2l0aCB0aGUgY2FsY3VsYXRpb24gb2YgdGhlIHByaW5jaXBhbCBjb29yZGluYXRlcyBvZiB0aGUgY29sdW1ucy4NCkZvciB0aGUgbG9jYWxpemF0aW9uIG9mIHRoZSBqLXRoIGNvbHVtbiBvbiB0aGUgay10aCBheGlzL2ZhY3Rvcg0KY2FsY3VsYXRlIHRoZSBwcm9kdWN0IG9mIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlIG9mIHRoZSBtYXRyaXggViBvZiB0aGUgcmlnaHQgc2luZ3VsYXIgdmVjdG9ycyBmb3IgYSBjb2x1bW4gb24gYW4gYXhpcyBhbmQgdGhlIHNpbmd1bGFyIHZhbHVlIG9mIHRoZSBrLXRoIGF4aXMgZGl2aWRlZCBieSB0aGUgcm9vdCBvZiB0aGUgbWFzcyBvZiB0aGUgai10aCBjb2x1bW4uDQoNCg0KDQokJGdfe2prfSA9IHZfe2prfVw6XGdhbW1hX2sgLyBcc3FydHtjX2p9JCQNCkNhbGN1bGF0aW9uIG9mIHRoZSBtYXRyaXggRyBvZiBwcmluY2lwYWwgY29vcmRpbmF0ZXMgb2YgdGhlIGNvbHVtbnM6DQpgYGB7cn0NCnByb3MgPC0gc3dlZXAoU1ZEJHYsIDIsIFNWRCRkLCAiKiIpDQpwcmluY2lwYWwuY29vcmRpbmF0ZXMuY29sdW1ucyA8LSBzd2VlcChwcm9zLCAxLCAoc3FydChjb2x1bW4ubWFzc2VzKSksICIvIikNCnByaW5jaXBhbC5jb29yZGluYXRlcy5jb2x1bW5zDQpgYGANCg0KIyMjIDUuMy4yIFN0YW5kYXJkIGNvb3JkaW5hdGVzDQoNCg0KPiBDb29yZGluYXRlcyBvZiBhIHNldCBvZiBwb2ludHMgc3VjaCB0aGF0IHRoZWlyIHdlaWdodGVkIHN1bSBvZiBzcXVhcmVzIGFsb25nIGFuIGF4aXMgZXF1YWxzIDEuIChjZi4gR3JlZW5hY3JlIDIwMDc6MjY2KQ0KDQoNClRoZSBzdGFuZGFyZCBjb29yZGluYXRlcyBzdGFuZCBmb3IgdGhlIGNvb3JkaW5hdGUgcG9zaXRpb25zIG9mIHRoZSB2ZXJ0aWNlcyAoaW4gZ2VvbWV0cnkgY29ybmVyIG9mIGEgcG9seWdvbiB3aXRoIGF0IGxlYXN0IHRocmVlIGNvcm5lcnMpLiBUaGV5IGFyZSBzdGFuZGFyZGl6ZWQgKG1lYW4gPSAwLCBzdGFuZGFyZCBkZXZpYXRpb24gPSAxKS4NCkFzIGEgcmVtaW5kZXI6IHRoZSB2ZXJ0aWNlcyBkZWZpbmUgdGhlIGJvdW5kYXJpZXMgb2YgdGhlIHByb2ZpbGUgc3BhY2UgYW5kIGNvcnJlc3BvbmQgdG8gZXh0cmVtZSAod2VpZ2h0ZWQpIHByb2ZpbGVzLCB0aGUgbGFiZWxzIGFyZSBpZGVudGljYWwgd2l0aCB0aGUgdmFyaWFibGUgdmFsdWVzLCBidXQgbm90IHRoZWlyIHByb2ZpbGVzLiBJbiBzaXgtZGltZW5zaW9uYWwgc3BhY2UgZS5nLiAxLDAsMCwwLDAsMDsgMCwxLDAsMCwwLDA7IDAsMCwxLDAsMCwwOyAwLDAsMCwxLDAsMDsgMCwwLDAsMCwxLDA7IDAsMCwwLDAsMCwxIGkuZS4gdGhlcmUgd291bGQgYmUgZS5nLiBhbiBleHRlbmRlciB3aG9zZSBleGFtcGxlcyB3b3VsZCBhbGwgb2NjdXIgd2l0aCBvbmUgc29jaWFsLWdlb2dyYXBoaWNhbCBncm91cC4NCg0KDQokJHhfe2lrfSA9IHVfe2lrfVw6LyBcc3FydHtyX2l9JCQNCg0KDQpUbyBjYWxjdWxhdGUgdGhlbSwgd2UgZGl2aWRlIGVhY2ggY2VsbCBvZiB0aGUgbGVmdCBzaW5ndWxhciB2ZWN0b3JzIGJ5IHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgcm93IG1hc3Nlcy4gV2UgdGh1cyBvYnRhaW4gdGhlIHN0YW5kYXJkIGNvb3JkaW5hdGVzIG9mIHRoZSByb3dzOiANCg0KYGBge3J9DQpzdGFuZGFyZC5jb29yZGluYXRlcy5yb3dzID0gc3dlZXAoU1ZEJHUsIDEsIHNxcnQocm93Lm1hc3NlcyksICIvIikNCnN0YW5kYXJkLmNvb3JkaW5hdGVzLnJvd3MNCmBgYA0KDQokJHlfe2prfSA9IHZfe2prfVw6IC8gXHNxcnR7Y19qfSAkJA0KVGhlIHNhbWUgY2FsY3VsYXRpb24gaXMgYXBwbGllZCB0byB0aGUgcmlnaHQgc2luZ3VsYXIgdmVjdG9ycywgd2hlcmUgY29sdW1uIG1hc3NlcyBhcmUgdXNlZC4NCg0KDQpgYGB7cn0NCnN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMgPSBzd2VlcChTVkQkdiwgMSwgc3FydChjb2x1bW4ubWFzc2VzKSwgIi8iKQ0Kc3RhbmRhcmQuY29vcmRpbmF0ZXMuY29sdW1ucw0KYGBgDQoNCiMjIyA1LjMuMyBSZWNpcHJvY2FsIGNhbGN1bGF0aW9uIG9mIHRoZSBjb29yZGluYXRlcw0KDQpUaGUgc3F1YXJlIHJvb3Qgb2YgcHJpbmNpcGFsIGluZXJ0aWEgc2VydmVzIGFzIGEgc2NhbGluZyBmYWN0b3IgdG8gZ2V0IGZyb20gdmVydGV4IHBvaW50cyBwb3NpdGlvbnMnIHRvIHByb2ZpbGUgcG9pbnQgcG9zaXRpb25zIChjZi4gR3JlZW5hY3JlIDIwMDcgcC4gNjApLg0KDQoNClRvIGdldCBmcm9tIHZlcnRpY2VzIHRvIHByb2ZpbGVzLCBtdWx0aXBseSBieSB0aGUgcm9vdCBvZiBwcmluY2lwYWwgaW5lcnRpYS4gQWx0ZXJuYXRpdmVseSwgd2UgY291bGQgbXVsdGlwbHkgYnkgdGhlIHNpbmd1bGFyIHZhbHVlIChzaW5jZSB0aGUgc3F1YXJlZCBzaW5ndWxhciB2YWx1ZXMgYXJlIHRoZSBlaWdlbnZhbHVlcykuDQoNCiQkcHJvZmlsZVw6Y29vcmRpbmF0ZSA9IHZlcnRleFw6Y29vcmRpbmF0ZVw6eCBcc3FydCB7cHJpbmNpcGFsXDppbmVydGlhfSQkDQoNCg0KSW4gdGhlIGNvZGUgYmVsb3csIHdlIHVzZSB0aGUgY29sdW1uIHZlcnRleCBwb2ludCBjb29yZGluYXRlIHRvIGNhbGN1bGF0ZSB0aGUgY29sdW1uIHByb2ZpbGUgY29vcmRpbmF0ZXMuDQoNCg0KYGBge3J9DQpwcmluY2lwYWwuY29vcmRpbmF0ZXMuY29sdW1ucy4yIDwtIHN3ZWVwKHN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMsIDIsIChzcXJ0KGVpZ2VudmFsdWVzKSksICIqIikNCnByaW5jaXBhbC5jb29yZGluYXRlcy5jb2x1bW5zLjINCg0KcHJpbmNpcGFsLmNvb3JkaW5hdGVzLmNvbHVtbnMuMyA8LSBzd2VlcChzdGFuZGFyZC5jb29yZGluYXRlcy5jb2x1bW5zLCAyLCBTVkQkZCwgIioiKQ0KcHJpbmNpcGFsLmNvb3JkaW5hdGVzLmNvbHVtbnMuMw0KDQpwcmluY2lwYWwuY29vcmRpbmF0ZXMuY29sdW1ucw0KYGBgDQoNCg0KVG8gZ28gYmFjayBmcm9tIHByb2ZpbGUgdG8gdmVydGV4IHBvaW50cyBtdWx0aXBseSB0aGUgcHJvZmlsZSBjb29yZGluYXRlIHZhbHVlIGJ5IHRoZSBpbnZlcnNlIG9mIHRoZSBzcXVhcmUgcm9vdCBvZiB0aGUgcHJpbmNpcGFsIGluZXJ0aWEuIChPciBpbiBzaW1wbGVyIHRlcm1zOiBkaXZpZGUgdGhlIHByb2ZpbGUgY29vcmRpbmF0ZSBieSB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHByaW5jaXBhbCBpbmVydGlhLikNCg0KDQoNCiQkdmVydGV4XDpjb29yZGluYXRlID0gcHJpbmNpcGFsXDpjb29yZGluYXRlXDp4XDoxL1xzcXJ0e3ByaW5jaXBhbFw6aW5lcnRpYX0gJCQNCmBgYHtyfQ0Kc3RhbmRhcmQuY29vcmRpbmF0ZXMuY29sdW1ucy4yIDwtIHN3ZWVwKHByaW5jaXBhbC5jb29yZGluYXRlcy5jb2x1bW5zLCAyLCAoMS8oc3FydChlaWdlbnZhbHVlcykpKSwgIioiKQ0Kc3RhbmRhcmQuY29vcmRpbmF0ZXMuY29sdW1ucy4yDQoNCnN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMNCmBgYA0KQWx0ZXJuYXRpdmVseSwgdGhlIHN0YW5kYXJkIGNvb3JkaW5hdGVzIGNhbiBiZSBjYWxjdWxhdGVkIGZyb20gdGhlIHByaW5jaXBhbCBjb29yZGluYXRlcyBieSBtZWFucyBvZiBkaXZpc2lvbiBieSB0aGUgc2luZ3VsYXIgdmFsdWVzOiBoZXJlIGZvciB0aGUgcm93czoNCg0KDQokJHhfe2lrfSA9IGZfe2lrfSAvIFxnYW1tYV9rJCQNCg0KDQpgYGB7cn0NCnN0YW5kYXJkLmNvb3JkaW5hdGVzLnJvd3MuMyA8LSBzd2VlcChwcmluY2lwYWwuY29vcmRpbmF0ZXMucm93cywgMiwgU1ZEJGQsICIvIikNCnN0YW5kYXJkLmNvb3JkaW5hdGVzLnJvd3MuMw0Kc3RhbmRhcmQuY29vcmRpbmF0ZXMucm93cw0KYGBgDQoNCkZvciB0aGUgY29sdW1uczoNCg0KJCR5X3tqa30gPSBnX3tqa30vIFxnYW1tYV9rJCQNCg0KDQpgYGB7cn0NCnN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMuMyA8LSBzd2VlcChwcmluY2lwYWwuY29vcmRpbmF0ZXMuY29sdW1ucywgMiwgU1ZEJGQsICIvIikNCnN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMuMw0Kc3RhbmRhcmQuY29vcmRpbmF0ZXMuY29sdW1ucw0KYGBgDQoNCg0KIyA2LiBSZXN1bHRzOiBOdW1lcmljYWwgdmFsdWVzIG9mIHRoZSBhbmFseXNpcyANCkFmdGVyIHdlIGhhdmUgY2FsY3VsYXRlZCB0aGUgY29vcmRpbmF0ZXMsIHdoaWNoIGNvcnJlc3BvbmRzIHRvIHRoZSBpbmZvcm1hdGlvbiBpbiBjb2x1bW5zIGs9MSBhbmQgaz0yIGluIHRoZSBzdW1tYXJ5IG9iamVjdCwgd2Ugd2lsbCBub3cgZ28gZm9yIHRoZSBjYWxjdWxhdGlvbiBvZiB2YWx1ZXMgaW5kaWNhdGluZyBpbmVydGlhIHdlaWdodHMgcmVsYXRlZCB0byBheGVzLCBxdWFsaXR5LCBjb3JyZWxhdGlvbiBhbmQgY29udHJpYnV0aW9uLg0KDQpgYGB7cn0NCnN1bW1hcnkoY2FfdmFsaWRhdGlvbikNCmBgYA0KDQoNCg0KIyMgNi4xIEZ1cnRoZXIgaW5lcnRpYSB3ZWlnaHRzDQoNCg0KDQpUbyBvYnRhaW4gYWJzb2x1dGUgaW5lcnRpYSB3ZWlnaHRzIG9mIHRoZSByb3dzIHJlbGF0ZWQgdG8gdGhlIGF4ZXMgd2l0aCBtYXJnaW5hbCBzdW1zLCB3ZSBtdWx0aXBseSB0aGUgcm93IG1hc3Mgd2l0aCB0aGUgc3F1YXJlZCBwcmluY2lwYWwgY29vcmRpbmF0ZXMNCm9mIHRoZSByb3dzLg0KDQoNCmBgYHtyfQ0KYWJzLmluLnJvd3MuYXggPC0gc3dlZXAocHJpbmNpcGFsLmNvb3JkaW5hdGVzLnJvd3NeMiwgMSwgcm93Lm1hc3NlcywgJyonKQ0KYWJzLmluLnJvd3MuYXhfdG90YWwgPC0gcmJpbmQoYWJzLmluLnJvd3MuYXgsIChjb2xTdW1zKGFicy5pbi5yb3dzLmF4KSkpDQpyb3duYW1lcyhhYnMuaW4ucm93cy5heF90b3RhbCkgWzddIDwtICJ0b3RhbCINCmFicy5pbi5yb3dzLmF4X3RvdGFsIDwtIGNiaW5kKGFicy5pbi5yb3dzLmF4X3RvdGFsLCAocm93U3VtcyhhYnMuaW4ucm93cy5heF90b3RhbCkpKQ0KY29sbmFtZXMoYWJzLmluLnJvd3MuYXhfdG90YWwpIDwtIGMoIlssMV0iLCJbLDJdIiwiWywzXSIsIlssNF0iLCJbLDVdIiwiWyw2XSIsInRvdGFsIikNCg0KYWJzLmluLnJvd3MuYXgNCmFicy5pbi5yb3dzLmF4X3RvdGFsDQpgYGANCg0KVGhlIGluZXJ0aWEgd2VpZ2h0cyBvZiB0aGUgYXhlcyBhcmUgdG8gYmUgcmVjb25zdHJ1Y3RlZCBmcm9tIHRoZSBjb2x1bW4gc3VtcyBvZiB0aGUgYWJzb2x1dGUgaW5lcnRpYSB3ZWlnaHRzLiANClRoZSBjb2x1bW4gc3VtIG9mIHRoZSBmaXJzdCBheGlzIHRodXMgY29ycmVzcG9uZHMgdG8gdGhlIGZpcnN0IGVpZ2VudmFsdWUuDQoNCg0KYGBge3J9DQphYnMuaW4ucm93cy5heF90b3RhbFs3LDFdDQplaWdlbnZhbHVlc1sxXQ0KYGBgDQoNCkRpc3BsYXkgZm9yIG5leHQgc3RlcCBpbiBjYWxjdWxhdGlvbjoNCmBgYHtyfQ0KcHJpbmNpcGFsLmNvb3JkaW5hdGVzLmNvbHVtbnMNCmNvbHVtbi5tYXNzZXMNCmBgYA0KDQoNCg0KQWJzb2x1dGUgaW5lcnRpYSB3ZWlnaHRzIG9mIHRoZSBjb2x1bW5zIG9uIHRoZSBheGVzIGNhbiBiZSBvYnRhaW5lZCBieQ0KbXVsdGlwbGljYXRpb24gb2YgdGhlIGNvbHVtbiBtYXNzIHdpdGggdGhlIHNxdWFyZWQgcHJpbmNpcGFsIGNvb3JkaW5hdGVzIG9mIHRoZSBjb2x1bW5zLg0KDQpgYGB7cn0NCmFicy5pbi5jb2xzLmF4IDwtIHN3ZWVwKHByaW5jaXBhbC5jb29yZGluYXRlcy5jb2x1bW5zXjIsIDEsIGNvbHVtbi5tYXNzZXMsICcqJykNCmFicy5pbi5jb2xzLmF4X3RvdGFsIDwtIHJiaW5kKGFicy5pbi5jb2xzLmF4LCAoY29sU3VtcyhhYnMuaW4uY29scy5heCkpKQ0Kcm93bmFtZXMoYWJzLmluLmNvbHMuYXhfdG90YWwpIFs3XSA8LSAidG90YWwiDQphYnMuaW4uY29scy5heF90b3RhbCA8LSBjYmluZChhYnMuaW4uY29scy5heF90b3RhbCwgKHJvd1N1bXMoYWJzLmluLmNvbHMuYXhfdG90YWwpKSkNCmNvbG5hbWVzKGFicy5pbi5jb2xzLmF4X3RvdGFsKSA8LSBjKCJbLDFdIiwiWywyXSIsIlssM10iLCJbLDRdIiwiWyw1XSIsIlssNl0iLCJ0b3RhbCIpDQoNCmFicy5pbi5jb2xzLmF4X3RvdGFsDQpgYGANCg0KU2luY2UgdGhlIGFic29sdXRlIGluZXJ0aWEgd2VpZ2h0cyBvZiB2YXJpYWJsZSBleHByZXNzaW9uIGFyZSBkaWZmaWN1bHQgdG8gaW50ZXJwcmV0LCB0aGUgcmVsYXRpdmUgaW5lcnRpYSB3ZWlnaHRzIG9mIHZhcmlhYmxlIGV4cHJlc3Npb24gYXJlIHJlcG9ydGVkLiANCg0KDQojIyMgNi4xLjEgQ29udHJpYnV0aW9uIG9mIHRoZSByb3dzIHJlbGF0ZWQgdG8gdGhlIGF4ZXMgIChgY3RyYC12YWx1ZSBvZiB0aGUgc3VtbWFyeSkgDQoNClJlbGF0aXZlIGluZXJ0aWEgd2VpZ2h0cyBvZiB0aGUgcm93cyByZWxhdGVkIHRvIHRoZSBjb2x1bW5zIGNhbiBiZSBvYnRhaW5lZCBieSBkaXZpZGluZyB0aGUgYWJzb2x1dGUgaW5lcnRpYSB3ZWlnaHRzIGJ5IHRoZSBjb2x1bW4gc3VtcyBvZiBhYnNvbHV0ZSBpbmVydGlhIHdlaWdodHMuDQoNCmBgYHtyfQ0KcmVsLmluLnJvd3MuYXggPC0gc3dlZXAoYWJzLmluLnJvd3MuYXgsIDIsIGNvbFN1bXMoYWJzLmluLnJvd3MuYXgpLCAnLycpDQpyZWwuaW4ucm93cy5heA0KYGBgDQpUaGUgdmFsdWUgb2YgcmVsYXRpdmUgaW5lcnRpYSB3ZWlnaHRzIGluZGljYXRlcyB0aGF0IGluIHRoZSByb3cgcmVwcmVzZW50YXRpb24gdGhlIGZpcnN0IHJvdyAnKmFuZCB0aGF0KicgaGVscHMgaW4gZXhwbGFpbmluZyB0aGUgZ2VvbWV0cmljYWwgYWxpZ25tZW50IG9mIHRoZSBmaXJzdCBheGlzIGJ5IDU1LjYlLiANCihFeHBsYW5hdGlvbiBvZiBob3cgbXVjaCBvZiB0aGUgdmFyaWF0aW9uIG9mIHRoZSBpbmRpdmlkdWFsIGF4ZXMgY2FuIGJlIGV4cGxhaW5lZCB3aXRoIHRoZSBoZWxwIG9mIHRoZSB2YXJpYWJsZSB2YWx1ZXMpIFRoZSByZWxhdGl2ZSBpbmVydGlhIHdlaWdodCByZWxhdGVkIHRvIHRoZSBheGVzIGlzIGxpc3RlZCBpbiB0aGUgY2Egc3VtbWFyeSBhcyBgY3RyYCBmb3IgY29udHJpYnV0aW9uLg0KDQpWYXJpYXRpb24gb24gdGhlIGZpcnN0IGF4aXMgaXMgaGlnaGx5IGRldGVybWluZWQgYnkgJyphbmQgdGhhdConLCAnKmFuZCBzdHVmZionLCAnKmFuZCB0aGluZ3MqJyAsIGFuZCB2YXJpYXRpb24gb24gdGhlIHNlY29uZCBpcyBoaWdobHkgZGV0ZXJtaW5lZCBieSAnKmFuZCBzdHVmZionLCBhbmQgJypvciBzb21ldGhpbmcqJy4NCg0KV2UgY29udGludWUgYnkgY2FsY3VsYXRpbmcgcmVsYXRpdmUgaW5lcnRpYSB3ZWlnaHRzIG9mIHRoZSBjb2x1bW5zIHdpdGggcmVzcGVjdCB0byB0aGUgYXhlcy4NCg0KDQpgYGB7cn0NCnJlbC5pbi5jb2xzLmF4IDwtIHN3ZWVwKGFicy5pbi5jb2xzLmF4LCAyLCBjb2xTdW1zKGFicy5pbi5jb2xzLmF4KSwgJy8nKQ0KcmVsLmluLmNvbHMuYXgNCmBgYA0KDQoNCkZyb20gdGhlIHBvaW50IG9mIHZpZXcgb2YgdGhlIGNhdGVnb3JpZXMgb2YgdGhlIGNvbHVtbnMsICcqUmVhZGluZ19NQyonLCAnKlJlYWRpbmdfV0MqJyBhbmQgJypIdWxsX1dDKicgZGV0ZXJtaW5lIHRoZSBmaXJzdCBheGlzIGFuZCAnKlJlYWRpbmdfTUMqJyBhbmQgJypIdWxsX01DKicgZGV0ZXJtaW5lIHRoZSBzZWNvbmQuDQoNCg0KIyMjIDYuMS4yIEluZXJ0aWEgb2YgdGhlIHJvd3MgYW5kIGNvbHVtbnM6ICBgaW5yYC0gdmFsdWUgb2YgdGhlIHN1bW1hcnkgDQoNCg0KSW4gdGhpcyBzdGVwLCB3ZSBjb21lIGJhY2sgdG8gdGhlIGFic29sdXRlIGluZXJ0aWEgd2VpZ2h0cyBmcm9tIHRhYmxlIGBhYnMuaW4ucm93cy5heF90b3RhbGA6DQpGcm9tIHRoZSBzdW1zIG9mIHRoZSByb3dzLCBpdCBpcyBwb3NzaWJsZSB0byBpbmRpY2F0ZSB3aGF0IHByb3BvcnRpb24gb2YgdGhlIGdlb21ldHJpYyBhbGlnbm1lbnQgb2YgYWxsIGF4ZXMgZWFjaCB2YXJpYWJsZSB2YWx1ZSBoYXMuIFRoaXMgaW5mb3JtYXRpb24gY2FuIGJlIGFic29sdXRlIGFuZCByZWxhdGl2ZToNCg0KVGhlIGFic29sdXRlIHZhbHVlcyBjYW4gYWxyZWFkeSBiZSBmb3VuZCBpbiB0aGUgdGFibGUgaW4gdGhlIHJvdyB0b3RhbHM6DQoNCg0KYGBge3J9DQphYnMuaW4ucm93cy5heF90b3RhbFsxOjYsN10NCmBgYA0KDQoNClRvIG9idGFpbiB0aGUgcmVsYXRpdmUgaW5lcnRpYSB3ZWlnaHQsIHRoZSBhYnNvbHV0ZSB2YWx1ZXMgb2YgdGhlIHJvdyB0b3RhbHMgYXJlIGRpdmlkZWQgYnkgdGhlIHRvdGFsIHN1bSBvciB0aGUgdG90YWwgaW5lcnRpYSB3ZWlnaHQ6DQoNCmBgYHtyfQ0KIyB0b3RhbCBzdW0NCmFicy5pbi5yb3dzLmF4X3RvdGFsWzcsN10NCiMgdG90YWwgaW5lcnRpYSB3ZWlnaHQNCnRvdGFsLmluZXJ0aWENCmBgYA0KDQpgYGB7cn0NCmFicy5pbi5yb3dzIDwtIGFicy5pbi5yb3dzLmF4X3RvdGFsWzE6Niw3XQ0KIyBjYWxjdWxhdGUgcmVsYXRpdmUgaW5lcnRpYSB3ZWlnaHQNCnJlbC5pbi5yb3dzIDwtIGFicy5pbi5yb3dzL2Ficy5pbi5yb3dzLmF4X3RvdGFsWzcsN10NCmBgYA0KDQpgYGB7cn0NCmFicy5pbi5yb3dzDQoNCmBgYA0KDQoNCmBgYHtyfQ0KcmVsLmluLnJvd3MNCg0KYGBgDQoNCg0KRnJvbSB0aGUgdGFibGUgd2l0aCB0aGUgcmVsYXRpdmUgdmFsdWVzIGl0IGZvbGxvd3MgdGhhdCBieSBtZWFucyBvZiB0aGUgZmlyc3Qgcm93ICcqYW5kIHRoYXQqJyA0MS4zJSBvZiB0aGUgZ2VvbWV0cmljIGFsaWdubWVudCBvZiB0aGUgd2hvbGUgbW9kZWwgY2FuIGJlIGV4cGxhaW5lZC4gDQoNClRoZSByZWxhdGl2ZSBpbmVydGlhIHdlaWdodHMgZm9yIGEgcm93IG9yIGNvbHVtbiBhcmUgbGlzdGVkIGFzIGBpbnJgIGluIHRoZSBzdW1tYXJ5IG9mIHRoZSBjb3JyZXNwb25kZW5jZSBhbmFseXNpcy4gVGh1cywgdGhleSBzaG93IGhvdyBoaWdoIHRoZSBwcm9wb3J0aW9uIG9mIGEgY2F0ZWdvcnkgaXMgZm9yIGV4cGxhaW5pbmcgdGhlIHRvdGFsIHZhcmlhdGlvbi4NCg0KWW91IGNhbiB2ZXJpZnkgdGhlIGNhbGN1bGF0aW9uIGJ5IGxvb2tpbmcgYXQgdGhlIGNhIG9iamVjdC4NCg0KYGBge3J9DQpjYV92YWxpZGF0aW9uJHJvd2luZXJ0aWENCmFicy5pbi5yb3dzDQpgYGANCg0KV2UgZGV0ZXJtaW5lIGFuYWxvZ291c2x5IHRoZSByZWxhdGl2ZSBpbmVydGlhIHdlaWdodCBvZiB0aGUgY29sdW1ucw0KDQpgYGB7cn0NCmFicy5pbi5jb2xzIDwtIGFicy5pbi5jb2xzLmF4X3RvdGFsWzE6Niw3XQ0KcmVsLmluLmNvbHMgPC0gYWJzLmluLmNvbHMvYWJzLmluLmNvbHMuYXhfdG90YWxbNyw3XQ0KYGBgDQoNClZhbGlkYXRpb24gYnkgbWVhbnMgb2YgYCRjb2xpbmVydGlhYA0KYGBge3J9DQphYnMuaW4uY29scw0KY2FfdmFsaWRhdGlvbiRjb2xpbmVydGlhDQoNCmBgYA0KDQpgYGB7cn0NCnJlbC5pbi5jb2xzDQoNCmBgYA0KDQoNCg0KIyMgNi4yIFZhbHVlcyBvZiBjb3JyZWxhdGlvbnMgd2l0aCB0aGUgYXhlcyAoYGNvcmApIGFuZCBxdWFsaXR5IChgcWx0YCB2YWx1ZSBvZiB0aGUgc3VtbWFyeSkNCg0KSWYgd2UgcmVsYXRlIHRoZSBpbmVydGlhIHdlaWdodHMgb2YgdGhlIHJvd3Mgb24gdGhlIGF4ZXMgdG8gdGhlIHN1bSBvZiB0aGUgaW5lcnRpYSB3ZWlnaHRzIG9mIHRoZSByb3dzIChkaXZpZGUgYnkgdGhlbSksIHdlIGNhbiBpbmRpY2F0ZSBob3cgbXVjaCB0aGUgdmFyaWFibGUgZXhwcmVzc2lvbnMgYXJlIGRldGVybWluZWQgYnkgdGhlIGluZGl2aWR1YWwgYXhlcy4gRm9yIGV4YW1wbGUsIDk5JSBvZiB0aGUgdmFyaWF0aW9uIG9mICcqYW5kIHRoYXQqJyBpcyBleHBsYWluZWQgYnkgdGhlIGZpcnN0IGF4aXMuIA0KVGhlIHZhbHVlIGZvciB0aGUgY29ycmVsYXRpb24gYmV0d2VlbiBhIHByaW5jaXBhbCBheGlzIGFuZCBhIHBhcnRpY3VsYXIgcm93IG9yIGNvbHVtbiBpcyBsaXN0ZWQgaW4gdGhlIGNhIHN1bW1hcnkgYXMgYGNvcmAuDQoNCg0KYGBge3J9DQpzcXJ0LmZsIDwtIGFicy5pbi5yb3dzLmF4L2Ficy5pbi5yb3dzLmF4X3RvdGFsWzE6Niw3XQ0Kc3FydC5mbA0KYGBgDQoNCkhlbmNlLCBpbiBjb3JyZXNwb25kZW5jZSBhbmFseXNpcyBpdCBpcyBhbHNvIHBvc3NpYmxlIHRvIGNhbGN1bGF0ZSB0aGUgcXVhbGl0eSBvZiB0aGUgaW5kaXZpZHVhbCBwb2ludHMuIFRoZSBmYXJ0aGVyIGEgcG9pbnQgaXMgZnJvbSB0aGUgb3JpZ2luLCB0aGUgYmV0dGVyIHRoZSBwb2ludCBpcyBleHBsYWluZWQgYnkgdGhlIGNvcnJlc3BvbmRlbmNlIGFuYWx5c2lzLiANCg0KQWx0ZXJuYXRpdmVseSwgd2UgY2FuIHNxdWFyZSB0aGUgcHJpbmNpcGFsIGNvb3JkaW5hdGVzIGFuZCBleHByZXNzIHRoZW0gYXMgcm93IHByb3BvcnRpb25zLCBhbmQgd2UgZ2V0IHRoZSBtZWFzdXJlcyBvZiBxdWFsaXR5IGZyb20gZWFjaCBkaW1lbnNpb24gZm9yIGVhY2ggcG9pbnQuIFRoZXNlIGFyZSBhbHNvIGNhbGxlZCBzcXVhcmVkIGNvcnJlbGF0aW9ucyAob3IgKnNxdWFyZWQgY29zaW5lcyopLiANCg0KDQoNCmBgYHtyfQ0Kc3FydC5jb3Iucm93ID0gcHJvcC50YWJsZShwcmluY2lwYWwuY29vcmRpbmF0ZXMucm93cyBeMiwgMSkNCnNxcnQuY29yLnJvdw0KDQpzcXJ0LmNvci5jb2wgPSBwcm9wLnRhYmxlKHByaW5jaXBhbC5jb29yZGluYXRlcy5jb2x1bW5zIF4yLCAxKQ0Kc3FydC5jb3IuY29sDQoNCnN1bS5zcXJ0LmNvci5yb3cgPC0gYXBwbHkoc3FydC5jb3Iucm93LCAxICxzdW0gKQ0Kc3VtLnNxcnQuY29yLnJvdw0Kc3VtLnNxcnQuY29yLmNvbCA8LSAgYXBwbHkoc3FydC5jb3IuY29sLCAxICxzdW0gKQ0Kc3VtLnNxcnQuY29yLmNvbA0KYGBgDQoNCg0KVGhlIHF1YWxpdHkgb2YgdGhlIG1hcCBmb3IgYSBnaXZlbiBjYXRlZ29yeSBpcyB1c3VhbGx5IGRlZmluZWQgYXMgdGhlIHN1bSBvZiB0aGUgc2NvcmVzIGl0IHJlY2VpdmVzIGZvciB0d28gZGltZW5zaW9ucy4gDQoNCkluIHRoZSBjYSBzdW1tYXJ5IHRoZSB2YWx1ZXMgYXJlIGxpc3RlZCB1bmRlciBgcWx0YC4gVGhleSByZXByZXNlbnQgdGhlIHF1YWxpdHkgb2YgdmlzdWFsaXphdGlvbiBvciBtYXBwaW5nIHF1YWxpdHksIElmIHRoZSBxdWFsaXR5IGlzIGxvdyAoYmVsb3cgNTAlKSwgdGhlIGNhdGVnb3JpZXMgbXVzdCBiZSBpbnRlcnByZXRlZCB3aXRoIGNhdXRpb24uIA0KSW4gdGhlIGV4YW1wbGUgdGhleSBhZGQgdXAgdG8gMTAwJS4NCg0KDQojIDcuMCBWYWxpZGF0aW9uIGJ5IGBjYWAgcGFja2FnZSANCg0KSW4gdGhpcyBzZWN0aW9uIHdlIGFyZSBub3cgZGlyZWN0bHkgY3Jvc3MtY2hlY2tpbmcgb3VyIGNhbGN1bGF0aW9ucyB0byBtYWtlIHN1cmUgd2UgZGlkIHRoZW0gY29ycmVjdGx5Lg0KDQojIyA3LjEgVmFsaWRhdGlvbiBvZiByb3cgYW5kIGNvbHVtbiBtYXNzZXMgDQoNCmBgYHtyfQ0KY2FfdmFsaWRhdGlvbiRyb3dtYXNzDQpyb3cubWFzc2VzDQoNCmNhX3ZhbGlkYXRpb24kY29sbWFzcw0KY29sdW1uLm1hc3Nlcw0KYGBgDQoNCg0KIyMgNy4yIFZhbGlkYXRpb24gb2YgY2hpLXNxdWFyZWQgZGlzdGFuY2VzDQoNCldlIGNyb3NzLWNoZWNrIHRoZSByb3cgYW5kIGNvbHVtbiBkaXN0YW5jZXMgYWdhaW5zdCB0aGUgYXZlcmFnZSByb3cgYW5kIGNvbHVtbiBwcm9maWxlLg0KYGBge3J9DQpjYV92YWxpZGF0aW9uJHJvd2Rpc3QNCmRpc3QubWF0cml4LnJvdw0KYGBgDQpgYGB7cn0NCmNhX3ZhbGlkYXRpb24kY29sZGlzdA0KZGlzdC5tYXRyaXguY29sDQpgYGANCg0KDQojIyA3LjMgVmFsaWRhdGlvbiBvZiBzdGFuZGFyZCBjb29yZGluYXRlcyBvZiByb3cgYW5kIGNvbHVtbnMgDQoNCldlIGNyb3NzLWNoZWNrIHRoZSB2YXJpYWJsZXMgKnJvd2Nvb3JkKiBhbmQgKmNvbGNvb3JkKiBvZiB0aGUgY2Egb2JqZWN0IGFnYWluc3QgdGhlIHZhbHVlcyB3ZSBjYWxjdWxhdGVkLiANCmBgYHtyfQ0KY2FfdmFsaWRhdGlvbiRyb3djb29yZA0Kc3RhbmRhcmQuY29vcmRpbmF0ZXMucm93cw0KDQpgYGANCg0KDQpgYGB7cn0NCmNhX3ZhbGlkYXRpb24kY29sY29vcmQNCnN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMNCg0KDQpgYGANCg0KV2UgY291bGQgYWxzbyBjb21wYXJlIGFnYWluc3QgdGhlIHByaW50ZWQgY2Egb2JqZWN0IGJ1dCBJIHByZWZlciB0aGUgYWJvdmUgbWV0aG9kIGZvciByZWFkYWJpbGl0eS4gDQoNCiMjIDcuNCBWYWxpZGF0aW9uIG9mIHByaW5jaXBhbCBjb29yZGluYXRlcyANCg0KVGhlIHByaW5jaXBhbCBjb29yZGluYXRlcyByZXN1bHRpbmcgZnJvbSB0aGUgY2EtcGFja2FnZSBhcHBlYXIgd2hlbiBjYWxsaW5nIHRoZSBzdW1tYXJ5IG9mIHRoZSBjYSBvYmplY3QgaW4gdGhlIGNvbHVtbnMgZm9yIGluZGl2aWR1YWwgZGltZW5zaW9ucyAoaz0xLCBrPTIpLiBOb3RlIHdoZW4gcHJpbnRpbmcgdGhlIGNhIG9iamVjdCBpdHNlbGYgaXQgd2lsbCBzaG93IHRoZSBzdGFuZGFyZCBjb29yZGluYXRlcyBpbnN0ZWFkLg0KDQpgYGB7cn0NCnN1bW1hcnkoY2FfdmFsaWRhdGlvbikNCnJvdW5kKHByaW5jaXBhbC5jb29yZGluYXRlcy5yb3dzKjEwMDApDQpyb3VuZChwcmluY2lwYWwuY29vcmRpbmF0ZXMuY29sdW1ucyoxMDAwKQ0KYGBgDQoNCg0KDQojIyA3LjUgVmFsaWRhdGlvbiBvZiBpbmVydGlhLXZhbHVlcyAoaW5lcnRpYSB3ZWlnaHRzKSANCg0KDQpGaXJzdCwgbGV0J3MgY29tcGFyZSB0aGUgYGlucmAgdmFsdWVzIG9mIHJlbGF0aXZlIGluZXJ0aWEgd2VpZ2h0cy4NCg0KDQpgYGB7cn0NCnN1bW1hcnkoY2FfdmFsaWRhdGlvbikNCnByaW50KCJpbnIgcm93cyIpDQpyb3VuZChyZWwuaW4ucm93cyoxMDAwKQ0KcHJpbnQoImluciBjb2xzIikNCnJvdW5kKHJlbC5pbi5jb2xzKjEwMDApDQpgYGANClNlY29uZCwgYGN0cmAgYXJlIHRoZSByZWxhdGl2ZSBpbmVydGlhIHdlaWdodHMgcmVsYXRlZCB0byBheGVzIHRoYXQgd2Ugbm93IGNvbXBhcmUuDQoNCmBgYHtyfQ0Kc3VtbWFyeShjYV92YWxpZGF0aW9uKQ0KcHJpbnQoImN0ciByb3dzIikNCnJvdW5kKHJlbC5pbi5yb3dzLmF4KjEwMDApDQpwcmludCgiY3RyIGNvbHMiKQ0Kcm91bmQocmVsLmluLmNvbHMuYXgqMTAwMCkNCg0KYGBgDQoNCg0KIyMgNy42IFZhbGlkYXRpb24gb2YgYGNvcmAgYW5kIGBxbHRgIHZhbHVlcyANCg0KVGhlIGBjb3JgIHZhbHVlIGFwcGVhcnMgaW4gdGhlIGNvbHVtbiBhZnRlciB0aGUgY29vcmRpbmF0ZSB2YWx1ZSBpbiB0aGUgZGltZW5zaW9ucy4NCmBgYHtyfQ0Kc3VtbWFyeShjYV92YWxpZGF0aW9uKQ0KcHJpbnQoImNvciByb3dzIikNCnJvdW5kKHNxcnQuY29yLnJvdyoxMDAwKQ0KcHJpbnQoImNvciBjb2xzIikNCnJvdW5kKHNxcnQuY29yLmNvbCoxMDAwKQ0KDQpgYGANCg0KVGhlIGBxbHRgIHZhbHVlcyBhcmUgaW4gdGhlIGNvbHVtbiBhZnRlciB0aGUgbWFzc2VzIG9mIHRoZSBzdW1tYXJ5LiBXZSBhcmUgdG8gY29tcGFyZSB0aGVtIG5vdy4NCg0KYGBge3J9DQpzdW1tYXJ5KGNhX3ZhbGlkYXRpb24pDQoNCigicWx0IHJvd3MiKQ0Kcm91bmQoc3VtKHNxcnQuY29yLnJvd1sxXSxzcXJ0LmNvci5yb3dbN10pKjEwMDApDQpyb3VuZChzdW0oc3FydC5jb3Iucm93WzJdLHNxcnQuY29yLnJvd1s4XSkqMTAwMCkNCnJvdW5kKHN1bShzcXJ0LmNvci5yb3dbM10sc3FydC5jb3Iucm93WzldKSoxMDAwKQ0Kcm91bmQoc3VtKHNxcnQuY29yLnJvd1s0XSxzcXJ0LmNvci5yb3dbMTBdKSoxMDAwKQ0Kcm91bmQoc3VtKHNxcnQuY29yLnJvd1s1XSxzcXJ0LmNvci5yb3dbMTFdKSoxMDAwKQ0Kcm91bmQoc3VtKHNxcnQuY29yLnJvd1s2XSxzcXJ0LmNvci5yb3dbMTJdKSoxMDAwKQ0KDQpwcmludCgicWx0IGNvbHMiKQ0Kcm91bmQoc3VtKHNxcnQuY29yLmNvbFsxXSxzcXJ0LmNvci5jb2xbN10pKjEwMDApDQpyb3VuZChzdW0oc3FydC5jb3IuY29sWzJdLHNxcnQuY29yLmNvbFs4XSkqMTAwMCkNCnJvdW5kKHN1bShzcXJ0LmNvci5jb2xbM10sc3FydC5jb3IuY29sWzldKSoxMDAwKQ0Kcm91bmQoc3VtKHNxcnQuY29yLmNvbFs0XSxzcXJ0LmNvci5jb2xbMTBdKSoxMDAwKQ0Kcm91bmQoc3VtKHNxcnQuY29yLmNvbFs1XSxzcXJ0LmNvci5jb2xbMTFdKSoxMDAwKQ0Kcm91bmQoc3VtKHNxcnQuY29yLmNvbFs2XSxzcXJ0LmNvci5jb2xbMTJdKSoxMDAwKQ0KDQoNCmBgYA0KDQpJbiBzdW0sIHdlIGhhdmUgbWFkZSBzdXJlIG5vdyB0aGF0IG91ciBjYWxjdWxhdGlvbnMgd2VyZSBkb25lIGluIHRoZSBjb3JyZWN0IHdheS4gDQoNCiMgOC4gRGlmZmVyZW50IFZpc3VhbGlzYXRpb25zDQoNCg0KIyMgOC4xIE1ldGhvZDogU3ltbWV0cmljIG1hcDogDQoNCihEZWZhdWx0OikgVGhlIHJvdyBhbmQgY29sdW1uIHBvaW50cyBhcmUgc2NhbGVkIHNvIHRoYXQgdGhlaXIgaW5lcnRpYSAod2VpZ2h0ZWQgdmFyaWFuY2UpIGlzIGVxdWFsIHRvIHRoZSBwcmluY2lwYWwgaW5lcnRpYSAoZWlnZW52YWx1ZSBvciBzaW5ndWxhciB2YWx1ZSkgYWxvbmcgdGhlIHByaW5jaXBhbCBheGVzLCBpLmUuIHJvd3MgYW5kIGNvbHVtbnMgYXJlIGdpdmVuIGluIHByaW5jaXBhbCBjb29yZGluYXRlcy4NCmBgYHtyfQ0KcGxvdChjYV92YWxpZGF0aW9uLCBkaW0gPSBjKDEsMiksIG1hcCA9ICJzeW1tZXRyaWMiLCB3aGF0ID0gYygiYWxsIiwgImFsbCIpLCANCiAgICAgICAgICAgICAgIG1hc3MgPSBjKEZBTFNFLCBGQUxTRSksIGNvbnRyaWIgPSBjKCJub25lIiwgIm5vbmUiKSwgDQogICAgICAgICAgICAgICBjb2wgPSBjKCJibHVlIiwgInJlZCIpLCANCiAgICAgICAgICAgICAgIHBjaCA9IGMoMTYsIDIxLCAxNywgMjQpLCANCiAgICAgICAgICAgICAgIGxhYmVscyA9IGMoMiwgMiksIA0KICAgICAgICAgICAgICAgYXJyb3dzID0gYyhGQUxTRSwgRkFMU0UpLCANCiAgICAgICAgICAgICAgIGxpbmVzID0gYyhGQUxTRSwgRkFMU0UpLCANCiAgICAgICAgICAgICAgIGx3ZD0xLA0KICAgICAgICAgICAgICAgeGxhYiA9ICJfYXV0b18iLCB5bGFiID0gIl9hdXRvXyIsIA0KICAgICAgICAgICAgICAgeGxpbSA9IGMoLTIuMCwgMi4wKSwNCiAgICAgICAgICAgICAgIHlsaW0gPSBjKC0xLjAsIDEuMCksDQogICAgICAgICAgICAgICBjb2wubGFiID0gYygiYmx1ZSIsICJyZWQiKSkgDQpgYGANCg0KDQpgYGB7cn0NCnByaW5jaXBhbC5jb29yZGluYXRlcy5yb3dzDQpwcmluY2lwYWwuY29vcmRpbmF0ZXMuY29sdW1ucw0KYGBgDQoNCg0KIyMgOC4yIE1ldGhvZDogInJvd3ByaW5jaXBhbCINCg0KQXN5bW1ldHJpYyByZXByZXNlbnRhdGlvbjogQ29tbW9uIHJlcHJlc2VudGF0aW9uIG9mIHJvd3MgYW5kIGNvbHVtbnMsIHRoZSB0d28gc2V0cyBvZiBwb2ludHMgYXJlIHNjYWxlZCBkaWZmZXJlbnRseSAobm9ybWFsaXplZCksIHdpdGggcm93cyBpbiBwcmluY2lwYWwgY29vcmRpbmF0ZXMgYW5kIGNvbHVtbnMgaW4gc3RhbmRhcmQgY29vcmRpbmF0ZXMgKGJpcGxvdHMpLg0KDQpgYGB7cn0NCnBsb3QoY2FfdmFsaWRhdGlvbiwgZGltID0gYygxLDIpLCBtYXAgPSAicm93cHJpbmNpcGFsIiwgd2hhdCA9IGMoImFsbCIsICJhbGwiKSwgDQogICAgICAgICAgICAgICBtYXNzID0gYyhGQUxTRSwgRkFMU0UpLCBjb250cmliID0gYygibm9uZSIsICJub25lIiksIA0KICAgICAgICAgICAgICAgY29sID0gYygiYmx1ZSIsICJyZWQiKSwgDQogICAgICAgICAgICAgICBwY2ggPSBjKDE2LCAyMSwgMTcsIDI0KSwgDQogICAgICAgICAgICAgICBsYWJlbHMgPSBjKDIsIDIpLCANCiAgICAgICAgICAgICAgIGFycm93cyA9IGMoRkFMU0UsIEZBTFNFKSwgDQogICAgICAgICAgICAgICBsaW5lcyA9IGMoRkFMU0UsIEZBTFNFKSwgDQogICAgICAgICAgICAgICBsd2Q9MSwNCiAgICAgICAgICAgICAgIHhsYWIgPSAiX2F1dG9fIiwgeWxhYiA9ICJfYXV0b18iLA0KICAgICAgICAgICAgICAgY29sLmxhYiA9IGMoImJsdWUiLCAicmVkIikpIA0KYGBgDQoNCmBgYHtyfQ0KcHJpbmNpcGFsLmNvb3JkaW5hdGVzLnJvd3MNCnN0YW5kYXJkLmNvb3JkaW5hdGVzLmNvbHVtbnMNCmBgYA0KDQoNCg0KIyMgOC4zIE1ldGhvZDogImNvbHByaW5jaXBhbCINCg0KYXN5bW1ldHJpYzogd2l0aCBjb2x1bW5zIGluIHByaW5jaXBhbCBjb29yZGluYXRlcyBhbmQgcm93cyBpbiBzdGFuZGFyZCBjb29yZGluYXRlcyAoYmlwbG90KQ0KYGBge3J9DQpwbG90KGNhX3ZhbGlkYXRpb24sIGRpbSA9IGMoMSwyKSwgbWFwID0gImNvbHByaW5jaXBhbCIsIHdoYXQgPSBjKCJhbGwiLCAiYWxsIiksIA0KICAgICAgICAgICAgICAgbWFzcyA9IGMoRkFMU0UsIEZBTFNFKSwgY29udHJpYiA9IGMoIm5vbmUiLCAibm9uZSIpLCANCiAgICAgICAgICAgICAgIGNvbCA9IGMoImJsdWUiLCAicmVkIiksIA0KICAgICAgICAgICAgICAgcGNoID0gYygxNiwgMjEsIDE3LCAyNCksIA0KICAgICAgICAgICAgICAgbGFiZWxzID0gYygyLCAyKSwgDQogICAgICAgICAgICAgICBhcnJvd3MgPSBjKEZBTFNFLCBGQUxTRSksIA0KICAgICAgICAgICAgICAgbGluZXMgPSBjKEZBTFNFLCBGQUxTRSksIA0KICAgICAgICAgICAgICAgbHdkPTEsDQogICAgICAgICAgICAgICB4bGFiID0gIl9hdXRvXyIsIHlsYWIgPSAiX2F1dG9fIiwNCiAgICAgICAgICAgICAgIGNvbC5sYWIgPSBjKCJibHVlIiwgInJlZCIpKSANCmBgYA0KDQpgYGB7cn0NCnByaW5jaXBhbC5jb29yZGluYXRlcy5jb2x1bW5zDQpzdGFuZGFyZC5jb29yZGluYXRlcy5yb3dzDQpgYGANCg0KDQpUaGVyZSBhcmUgbW9yZSB2aXN1YWxpemF0aW9uIG1ldGhvZHMgaW4gdGhlIGNhIHBhY2thZ2UsICdzeW1iaXBsb3QnLCAncm93Z3JlZW4nIGFuZCAnY29sZ3JlZW4nLCB0aGF0IGFyZSBub3QgZGlzY3Vzc2VkIGhlcmUuDQoNCg0KDQoNCiMgUmVmZXJlbmNlcw0KQmxhc2l1cywgSi4gKDIwMDEpLiAqS29ycmVzcG9uZGVuemFuYXlsc2UqLiBEZSBHcnV5dGVyLiANCg0KQnJlaXR1bmcsIEouICgyMDIzKS4gRHIuIFN0cmFuZ2Vsb3ZlIG9yOiBIb3cgSSBMZWFybmVkIHRvIFN0b3AgV29ycnlpbmcgYW5kIExvdmUgdGhlIENvcnJlc3BvbmRlbmNlIEFuYWx5c2lzLiBVUkwgaHR0cHM6Ly93aXNvc3RhdC51bmkta29lbG4uZGUvZmlsZWFkbWluL3NpdGVzL3N0YXRpc3Rpay9DZWxpYnJhdGVfSm9lcmcucGRmDQoNCkNoZXNoaXJlLCBKLiAoMjAwNykuIERpc2NvdXJzZSBWYXJpYXRpb24sIEdyYW1tYXRpY2FsaXNhdGlvbiBhbmQgU3R1ZmYgTGlrZSBUaGF0LiAqSm91cm5hbCBvZiBTb2Npb2xpbmd1aXN0aWNzIDExICgyKSosIDE1NeKAkzE5My4gIGRvaToxLjExMTEvai4xNDY3LTk4NDEuMjAwNy4wMDMxN3guIGh0dHA6Ly9keC5kb2kuDQpvcmcvMTAuMTExMS9qLjE0NjctOTg0MS4yMDA3LjAwMzE3LnguDQoNCkRlc2FndWxpZXIsIEcuICgyMDE3KS4gKkNvcnB1cyBMaW5ndWlzdGljcyBhbmQgU3RhdGlzdGljcyB3aXRoIFIuIEludHJvZHVjdGlvbiB0byBRdWFudGl0YXRpdmUgTWV0aG9kcyBpbiBMaW5ndWlzdGljcy4gU3ByaW5nZXIuIGRvaToxMC4xMDA3Lzk3OC0zLTMxOS02NDU3Mi04LiBBZGRpdGlvbmFsIG1hdGVyaWFsczogDQoNCkdyZWVuYWNyZSwgTS4gKDIwMDcpLiAqQ29ycmVzcG9uZGVuY2UgQW5hbHlzaXMgaW4gUHJhY3RpY2UqLiBDaGFwbWFuICYgSGFsbC4gDQoNCkhhdXR6LCBQLiAmIEJsZXVlbCwgRi4gKDIwMTgpLiBEaWUgS29ycmVzcG9uZGVuemFuYWx5c2UgenVyIEF1c3dlcnR1bmcgdW5kIFZpc3VhbGlzaWVydW5nIGluaGFsdHNhbmFseXRpc2NoZXIgRGF0ZW4uIEluOiBQZXRlcnNlbiwgVGhvbWFzICYgU2Nod2VuZGVyLCBDbGVtZW5zIChFZHMpLCAqRGllIEVudHNjaGzDvHNzZWx1bmcgZGVyIEJpbGRlcjogTWV0aG9kZW4genVyIEVyZm9yc2NodW5nIHZpc3VlbGxlciBLb21tdW5pa2F0aW9uLiogKHBwLiAxOTctMjIyKS4gSGFsZW0uDQoNCldhc3NlcnN0ZWluLCBSLiBMLiAmIExhemFyLCBOLiBBLiAoMjAxNikgVGhlIEFTQSdzIFN0YXRlbWVudCBvbiBwLVZhbHVlczogQ29udGV4dCwgUHJvY2VzcywgYW5kIFB1cnBvc2UsICpUaGUgQW1lcmljYW4gU3RhdGlzdGljaWFuLCA3MDoyKiwgMTI5LTEzMy4NCg==</div>



</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->
<script>
$(document).ready(function () {
  window.initializeSourceEmbed("MathCA22complete.Rmd");
});
</script>


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
